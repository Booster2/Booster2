// Grammar for the Booster25 language
// By default, based on an example "entity language" syntax

module Booster25

imports Common	
        AbstractBoosterModel	
        Relational


context-free start-symbols

  System

context-free syntax

  System.System = <
  	system <ID>
  	
  		<{SystemComponent "\n\n"}*>
  > 
  System.System = <
  	System <ID>
  	
  		<{SystemComponent "\n\n"}*>
  > 
  BoosterTerm = System 
  SystemComponent = SetDef 
  SystemComponent = Class 
  BoosterTerm = SystemComponent 
  SetDef.SetDef = <set <ID> { <{ID ", "}+> }> 
  BoosterTerm = SetDef 
  Class.Class = <
  	class <ID> <Extends?>{
  		<{ClassComponents "\n"}*>
  	}
  > 
  BoosterTerm = Class 
  Extends.Extend = <extends <{Extension ","}+> > 
  BoosterTerm = Extends 
  Extension.Extension = ID 
  ClassComponents.Attributes = <
  	attributes
  		<{Attribute "\n"}*>
  > 
  ClassComponents.Methods = <
  	methods
  		<{Method "\n"}*>
  > 
  ClassComponents.Invariant = <
  	invariants
  		<{Constraint "\n"}*>
  > 
  ClassComponents.Workflows = <
  	workflows
  		<{WorkflowComponent "\n"}*>
  > 
  BoosterTerm = ClassComponents 
  Attribute.Attribute = <<ID> <Decoration*>: <TypeDecl>> 
  BoosterTerm = Attribute 
  Identity.Identity = <(<>ID<>) > 
  Decoration = Identity 
  TypeDecl = PrimTypeDecl 
  TypeDecl.Optional = <[ <PrimTypeDecl> ]> 
  TypeDecl.Set = <set ( <PrimTypeDecl> ) <Multiplicity>> 
  TypeDecl.Set = <SET ( <PrimTypeDecl> ) <Multiplicity>> 
  BoosterTerm = TypeDecl 
  PrimTypeDecl.BasicType = BasicTypeDecl 
  PrimTypeDecl.UniDirectional = ID 
  PrimTypeDecl.BiDirectional = <<ID>.<ID>> 
  BoosterTerm = PrimTypeDecl 
  BasicTypeDecl.String = <STRING>  
  BasicTypeDecl.String = <String>  
  BasicTypeDecl.String = <string>
  BasicTypeDecl.Int = <INT> 
  BasicTypeDecl.Int = <Int> 
  BasicTypeDecl.Int = <int> 
  BasicTypeDecl.Decimal = <DECIMAL> 
  BasicTypeDecl.Decimal = <Decimal>
  BasicTypeDecl.Decimal = <decimal> 
  BasicTypeDecl.Date = <DATE> 
  BasicTypeDecl.Date = <Date> 
  BasicTypeDecl.Time = <TIME> 
  BasicTypeDecl.DateTime = <DATETIME> 
  BasicTypeDecl.DateTime = <DateTime> 
  BasicTypeDecl.DateTime = <dateTime> 
  BasicTypeDecl.Boolean = <BOOLEAN> 
  BasicTypeDecl.Boolean = <Boolean> 
  BasicTypeDecl.Password = <PASSWORD> 
  BasicTypeDecl.Password = <Password> 
  Multiplicity.MultMinAndMax = <[ <INT> .. <INT> ]> 
  Multiplicity.MultJustMax = <[ .. <INT> ]> 
  Multiplicity.MultJustMin = <[<><INT> .. *<>]> 
  Multiplicity.MultJustMin = <[ <INT> .. ]> 
  Multiplicity.MultSingle = <[ <INT> ]> 
  Multiplicity.MultAny = <[ * ]> 
  Multiplicity.MultAny =  
  BoosterTerm = Multiplicity 
  Method.Method = <<ID> { <ConstraintOrGuardedCommand> }> 
  ConstraintOrGuardedCommand = Constraint
  ConstraintOrGuardedCommand = GuardedCommand
  BoosterTerm = Method 
  Constraint.True = <true> 
  Constraint.False = <false> 
  Constraint = Relation 
  Constraint.Not = <not <Constraint>> 
  Constraint.And = <<Constraint> & <Constraint>> {assoc}
  Constraint.Or = <<Constraint> or <Constraint>> {assoc}
  Constraint.Implies = <<Constraint> =\> <Constraint>> {assoc}
  Constraint.Then = <<Constraint> ; <Constraint>> {assoc}
  Constraint = <( <Constraint> )> {bracket}
  Constraint.Conjuncts = <conjuncts <{Constraint "&"}*>> {deprecated}
  Constraint.Disjuncts = <disjuncts <{Constraint "or"}*>> {deprecated}
  Constraint.Exists = <exists <ID> : <Expression> @ <Constraint>> 
  Constraint.Forall = <forall <ID> : <Expression> @ <Constraint>> 
  Constraint = MethodReference 
  BoosterTerm = Constraint 
  Relation.BinRel = <<Expression> <BinRel> <Expression>> 
  BoosterTerm = Relation 
  BinRel.Equal = <=> 
  BinRel.NotEqual = </=> 
  BinRel.In = <:> 
  BinRel.NotIn = </:> 
  BinRel.LessThan = <\<> 
  BinRel.GreaterThan = <\>> 
  BinRel.LessThanEquals = <\<=> 
  BinRel.GreaterThanEquals = <\>=> 
  BinRel.Subset = <\<:> 
  BinRel.SubsetEquals = <\<\<:> 
  BinRel.Superset = <:\>> 
  BinRel.SupersetEquals = <:\>\>> 
  Expression = ValueExpression 
  Expression.UnOp = <<UnOp> <Expression>> {left}
  Expression = <( <Expression> )> {bracket}
  Expression.BinOp = <<Expression> <BinOp> <Expression>> {left}
  BoosterTerm = Expression 
  ValueExpression.BasicValue = BasicValue 
  ValueExpression.TypeExtent = TypeExtent 
  ValueExpression = Path 
  ValueExpression.Null = <null> {prefer}
  ValueExpression.SetComprehension = <{ <ID> : <Expression> @ <Path> }> 
  ValueExpression.SetComprehension = <{ <ID> : <Expression> | <Constraint> @ <Path> }> 
  ValueExpression.SetExtent = <{ <{Expression ","}*> }> 
  BoosterTerm = ValueExpression 
  BasicValue.Integer = INT 
  BasicValue.String = STRING 
  BasicValue.Decimal = DECIMAL 
  BasicValue.True = <true> 
  BasicValue.False = <false> 
  BasicValue.CurrentDateTime = <currentdatetime> 
  BasicValue.CurrentDateTime = <CurrentDateTime> 
  BasicValue.CurrentDateTime = <currentDateTime> 
  BasicValue.CurrentDate = <currentdate> 
  BasicValue.CurrentTime = <currenttime> 
  TypeExtent.String = <STRING> {prefer}
  TypeExtent.String = <string> {prefer}
  TypeExtent.Int = <INT> {prefer}
  TypeExtent.Int = <int> {prefer}
  TypeExtent.Decimal = <DECIMAL> {prefer}
  TypeExtent.Decimal = <decimal> {prefer}
  TypeExtent.Date = <DATE> {prefer}
  TypeExtent.Date = <date> {prefer}
  TypeExtent.Time = <TIME> {prefer}
  TypeExtent.Time = <time> {prefer}
  TypeExtent.DateTime = <DATETIME> {prefer}
  TypeExtent.DateTime = <datetime> {prefer}
  TypeExtent.Boolean = <BOOLEAN> {prefer}
  TypeExtent.Boolean = <boolean> {prefer}
  TypeExtent.Password = <PASSWORD> {prefer}
  TypeExtent.Password = <password> {prefer}
  Path = PathStart 
  Path.Path = <<Path>.<PathComponent>> {prefer}
  BoosterTerm = Path 
  PathStart = Input 
  PathStart = Output 
  PathStart = This 
  PathStart = ThisPrimed 
  PathStart.PathStart = <<ID><Primed?>> 
  BoosterTerm = PathStart 
  Input.Input = <<ID>?> 
  Output.Output = <<ID>!> 
  This.This = <this> 
  ThisPrimed.ThisPrimed = <this'> 
  Primed.Primed = <'> 
  BoosterTerm = Primed 
  PathComponent.PathComponent = <<ID><Primed?>> 
  PathComponent.PathComponent =  {deprecated}
  BoosterTerm = PathComponent 
  UnOp.Head = <head> 
  UnOp.Tail = <tail> 
  UnOp.Cardinality = <card> 
  UnOp.Negative = <-> 
  BinOp.Plus = <+> 
  BinOp.Minus = <-> 
  BinOp.Times = <*> 
  BinOp.Divide = </> 
  BinOp.Maximum = <max> 
  BinOp.Minimum = <min> 
  BinOp.Intersection = </\\> 
  BinOp.Union = <\\/> 
  BinOp.Concat = <++> 
  MethodReference.MethodReference = <<Path> ( <{Subst ","}*> )> 
  Subst.Subst = <<Input> = <Expression>> 
  BoosterTerm = MethodReference 
  WorkflowComponent = SeqWf 
  WorkflowComponent = ParWf 
  SeqWf.SeqWf = <seq <ID> : <SeqWfExpression>> 
  ParWf.ParWf = <par <ID> : <ParWfExpression>> 
  ParWf.ParWf2 = <par <Constraint> & <ID> : <ParWfExpression>> 
  SeqWfExpression.Skip = <Skip>  
  SeqWfExpression.Skip = <SKIP> 
  SeqWfExpression.Choice = <<GuardedAction> -\> <SeqWfExpression> [] <GuardedAction> -\> <SeqWfExpression>> 
  SeqWfExpression.Wait = <WAIT{ <{INT ","}+> } -\> <SeqWfExpression>>
  SeqWfExpression.Wait = <Wait{ <{INT ","}+> } -\> <SeqWfExpression>> 
  SeqWfExpression.WorkflowReference = ID 
  SeqWfExpression.Prefix = <<GuardedAction> -\> <SeqWfExpression>> 
  SeqWfExpression = <( <SeqWfExpression> )> {bracket}
  GuardedAction.GA = <<Guard> & <MethodReference>> 
  GuardedAction = <( <GuardedAction> )> {bracket}
  Guard.Normal = Constraint 
  Guard.Delayed = <Delayed <Constraint>> 
  ParWfExpression.Single = ID 
  ParWfExpression.Multiple = <<ID> ||| <ParWfExpression>> 

context-free priorities

		SeqWfExpression.Prefix 
	> 
		SeqWfExpression.Choice 

context-free priorities
	
	{
		Constraint.Forall
		Constraint.Exists
	}
	>
		Constraint.Not
	>
		Constraint.And
	>
		Constraint.Or
	>
		Constraint.Implies
	>
		Constraint.Then

context-free priorities

		Expression = ValueExpression //TODO: this isn't supported in SDF3 anymore
	>
		Expression.UnOp
	>
		Expression.BinOp
