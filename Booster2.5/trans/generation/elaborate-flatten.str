module trans/generation/elaborate-flatten

imports
	include/booster25
	trans/names
	trans/api/_runtime
	trans/api/_runtime-constructors
	trans/api/class
	trans/api/method
	
rules
	
	flatten-class-hierarchy(|ast):
	c@Class(cname, ext, cmember*) -> 
		Class(cname, ext, cmember'*)
			with
				superclass*       := <_relation-lookup(|"<sub:");nub;reverse>cname;
				// <strip-annos;debug>cname;
				// <map(_pp-uri);debug><_relation-lookup(|"<sub:")>cname;
				// <map(_pp-uri);debug>superclass*;
				superclass-def*   := <map(class-get-definition(|ast))>superclass*
			with // attributes: only pull in ones that are not defined allready (and pull in most specific ones)
				attr*             := <class-get-attributes>c;
				superclass-attr*  := <map(class-get-attributes);concat>superclass-def*;
				all-attr*         := [superclass-attr*,attr*]
			with // invariants: pull all invariants in
				inv*              := <class-get-invariants>c;
				superclass-inv*   := <map(class-get-invariants);concat>superclass-def*;
				all-inv*          := [superclass-inv*,inv*]
			with // methods: pull all methods in not defined + pull all bodies of methods defined
				method*           := <class-get-methods>c;
				superclass-meth*  := <map(class-get-methods);concat>superclass-def*;
				all-meth*         := [superclass-meth*,method*];
				all-meth'*        := <reverse;method-conjoin-all;reverse>all-meth*
			with
				new-attr* := <?a;if ?[] then ![] else ![Attributes(a)] end>all-attr*;
				new-inv*  := <?b;if ?[] then ![] else ![Invariant (b)] end>all-inv*;
				new-meth* := <?d;if ?[] then ![] else ![Methods   (d)] end>all-meth'*;
				cmember'* := [new-attr*, new-inv*, new-meth*]
	