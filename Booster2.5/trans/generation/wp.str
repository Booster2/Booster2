module trans/generation/wp

imports
	
	include/Booster25
	trans/api/guarded-command
	trans/api/_runtime
	trans/desugar
	trans/api/constraint
	
	trans/lib/eq
	
	trans/pp
	
	
	api/path
	
rules
	
	// Subsets: gets all subsets of a list

	subsets: 		[] -> [[]]		
	subsets:		[x, xs*] -> <union> (<subsets> [xs*], <map(\ p -> <union>([x], p)\)> <subsets> [xs*] )

rules
	
	wp = 
		?ast;
		try(sometd(method-wp(|ast)))

rules
	
	method-wp(|ast): Method(name, Both(c, gc)) -> Method(name, gc'')
		with
	 		all-model-invariants* := <collect-all(?Invariant(_,_))>ast;
			assign-paths* := <map(\Assign(path, expr) -> path \)><collect-all(?Assign(_,_))> gc;
			invariant := <conjoin-constraints><nub><concat><map(\ path -> <filter(invariant-matches-path(|path))> all-model-invariants* \)> assign-paths*;
			//<debug> "method-wp";
			//<debug> <pp-Constraint-string> <conjoin-constraints><nub><concat><map(\ path -> <literal-subst>(<filter(invariant-matches-path(|path))> all-model-invariants*, [(This(), <path-prefix> path) ]) \)> assign-paths*;
			//<debug> <map(\ path -> <literal-subst>(<filter(invariant-matches-path(|path))> all-model-invariants*, [(This(), <path-prefix> path) ]) \)> assign-paths*;
			(c', gc') := <gc-wp(|ast,And(<make-pre-state> c, invariant))>gc;
			gc'' := Guard(c', gc')
			//g|[~c' --> ~gc']|

rules
	
	gc-wp(|ast,c): |[skip]| -> (c, Skip())
	
	gc-wp(|ast, c): Assign(path, expr) -> (c', Assign(path, expr)) 
		where
			c' := <aliasing-subst(|path, expr)> c

	gc-wp(|ast, c): New(o, cl) -> (c', New(o,cl))
		where	
			c' := <aliasing-subst(|PathStart(cl, None()), Union(PathStart(cl, None()), SetExtent([Output(o)])))>c;
			<debug> "wp";
			<debug> c'

	gc-wp(|ast, c): Guard(g,p) -> (And(c,c'), Guard(g, p'))
		where
			(c', p') := <gc-wp(|ast, c)> p	

	gc-wp(|ast, c): Sequence(p1,p2) -> (c'', Sequence(p1',p2'))
		where
			(c', p2') := <gc-wp(|ast, c)> p2;
			(c'', p1') := <gc-wp(|ast, c')> p1

	gc-wp(|ast, c): Parallel(p1,p2) -> ( c'', Parallel(p1',p2'))
		where
			(c', p2') := <gc-wp(|ast, c)> p2;
			(c'', p1') := <gc-wp(|ast, c')> p1




	// catch all
	gc-wp(|ast,c): gc -> (c, gc)


	invariant-matches-path(|path):
			Invariant(iname, invp) -> invp'
	where
			attsMentioned* := <_relation-lookup(|"<hasInv:")> iname;
			<elem> (<_nabl-collect-use;_nabl-uri> path, attsMentioned*);
			invp' := <conjoin-constraints><nub-an><map(\p1 -> <literal-subst>(invp, [(p1, path)]) \)><filter(\p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , <_nabl-collect-use;_nabl-uri> path) \)> <collect-all-paths> invp		


	// Class names cannot be aliased!
	aliasing-subst(|path, expr): constraint -> <literal-subst> (constraint, [(path, expr)])
		where
			PathStart(p, _) := path;
			<is-class-name> p

	aliasing-subst(|path, expr): constraint -> constraint'
		where
			path-uri := <_nabl-collect-use;_nabl-uri> path;

			// this will collect duplicate paths - n is the same as n, but their locations are different.
			// nub cannot fix this - do it some other way!
			matching-paths* := <nub-an> <filter(\ p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , path-uri) \)> <collect-all-paths> constraint;
			constraint' := <conjoin-constraints> <map(\s -> <generate-constraint> (s, <diff>(matching-paths*, s), path, expr, constraint)\)><subsets> matching-paths*
			
			
	literal-subst: (constraint, substs) -> constraint'
		where
			substs' := <map(\ (t,e) -> ( <remove-all-annotations> t , e) \)> substs;
			constraint' := <bottomup(try(\ trm -> <lookup> (<remove-all-annotations> trm  , substs')\))> constraint
			
	remove-all-annotations = bottomup(try(\ t -> t {}\)) 
		
		
	generate-constraint: ([], neg, path, expr, constraint) -> True()

	generate-constraint: (pos, [], path, expr, constraint) -> Implies(constraint1, constraint3)
		where
			constraint1 := <conjoin-constraints> <map(\ p -> Equal(<path-prefix> p, <path-prefix> path) \)> pos;
			constraint3 := <literal-subst> (constraint, <map(\ p -> (p, expr)\)> pos)

	generate-constraint: (pos, neg, path, expr, constraint) -> Implies(And(constraint1, constraint2), constraint3)
		where
			constraint1 := <conjoin-constraints> <map(\ p -> Equal(<path-prefix> p, <path-prefix> path) \)> pos;
			constraint2 := <conjoin-constraints> <map(\ q -> NotEqual(<path-prefix> q, <path-prefix> path) \)> neg;
			constraint3 := <literal-subst> (constraint, <map(\ p -> (p, expr)\)> pos)
			 
rules
	


	
rules

