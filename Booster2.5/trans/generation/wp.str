module trans/generation/wp

imports
	
	include/Booster25
	trans/api/guarded-command
	trans/api/_runtime
	trans/desugar
	trans/api/constraint
	
	api/path
	
rules
	
	// Subsets: gets all subsets of a list

	subsets: 		[] -> [[]]		
	subsets:		[x, xs*] -> <union> (<subsets> [xs*], <map(\ p -> <union>([x], p)\)> <subsets> [xs*] )

rules
	
	wp = 
		?ast;
		try(sometd(method-wp(|ast)))

rules
	
	method-wp(|ast): Method(name, Both(c, gc)) -> Method(name, gc'')
		with
	 		all-model-invariants* := <collect-all(?Invariant(_,_))>ast;
			assign-paths* := <map(\Assign(path, expr) -> path \)><collect-all(?Assign(_,_))> gc;
			invariant := <conjoin-constraints><nub><concat><map(\ path -> <filter(invariant-matches-path(|path))> all-model-invariants* \)> assign-paths*;
			
			(c', gc') := <gc-wp(|ast,And(<make-pre-state> c, invariant))>gc;
			gc'' := Guard(c', gc')
			//g|[~c' --> ~gc']|

rules
	
	gc-wp(|ast,c): Skip() -> (c, Skip())
	
	gc-wp(|ast, c): Assign(path, expr) -> (c', Assign(path, expr)) 
		where
			c' := <aliasing-subst(|path, expr)> c

	gc-wp(|ast, c): New(o, cl) -> (c, New(o,cl))

	gc-wp(|ast, c): Guard(g,p) -> (And(c,c'), Guard(g, p'))
		where
			(c', p') := <gc-wp(|ast, c)> p	

	gc-wp(|ast, c): Sequence(p1,p2) -> (c'', Sequence(p1',p2'))
		where
			(c', p2') := <gc-wp(|ast, c)> p2;
			(c'', p1') := <gc-wp(|ast, c')> p1

	gc-wp(|ast, c): Parallel(p1,p2) -> ( c'', Parallel(p1',p2'))
		where
			(c', p2') := <gc-wp(|ast, c)> p2;
			(c'', p1') := <gc-wp(|ast, c')> p1




	// catch all
	gc-wp(|ast,c): gc -> (c, gc)


	invariant-matches-path(|path):
			inv -> invp
	where
			Invariant(iname, invp) := inv;
			attsMentioned* := <_relation-lookup(|"<hasInv:")> iname
			
			
	where
			<elem> (<_nabl-collect-use;_nabl-uri> path, attsMentioned*)

	aliasing-subst(|path, expr): constraint -> constraint'
		where
			//<debug> "aliasing-subst";
			path-uri := <_nabl-collect-use;_nabl-uri> path;
			//<debug> <_pp-uri> path-uri;

			// this will collect duplicate paths - n is the same as n, but their locations are different.
			// nub cannot fix this - do it some other way!
			
			matching-paths* := <filter(\ p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , path-uri) \)> <collect-all-paths> constraint;
			constraint' := <conjoin-constraints> <map(\s -> <generate-constraint> (s, <diff>(matching-paths*, s), path, expr, constraint)\)><subsets> matching-paths*
			//<debug> constraint'
			
			
	literal-subst: (constraint, substs) -> constraint'
		where
			//<debug> "literal-substitute";
			substs' := <map(\ (t,e) -> ( <remove-annotations> t , e) \)> substs;
			//<debug> substs';
			//<debug> constraint;
			constraint' := <bottomup(try(\ trm -> <lookup> (<remove-annotations> trm  , substs')\))> constraint
			
	remove-annotations = bottomup(try(\ t -> t {}\)) 
		
		
	generate-constraint: (pos, neg, path, expr, constraint) -> Implies(And(constraint1, constraint2), constraint3)
		where
			constraint1 := <conjoin-constraints> <map(\ p -> Equal(<path-prefix> p, <path-prefix> path) \)> pos;
			constraint2 := <conjoin-constraints> <map(\ q -> NotEqual(<path-prefix> q, <path-prefix> path) \)> neg;
			//<debug> "pos";
			//<debug> pos;
			//<debug> "neg";
			//<debug> neg;
			constraint3 := <literal-subst> (constraint, <map(\ p -> (p, expr)\)> pos)
			 
rules
	

