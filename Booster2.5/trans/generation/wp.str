module trans/generation/wp

imports
	
	include/Booster25
	trans/api/guarded-command
	trans/api/_runtime
	trans/desugar
	trans/api/constraint
	trans/api/attribute
	
	trans/lib/eq
	
	trans/pp
	
	
	api/path
	
rules
	
	// Subsets: gets all subsets of a list

	subsets: 		[] -> [[]]		
	subsets:		[x, xs*] -> <union> (<subsets> [xs*], <map(\ p -> <union>([x], p)\)> <subsets> [xs*] )

rules
	
	wp = 
		?ast;
		try(sometd(method-wp(|ast)))

rules
	
	method-wp(|ast): Method(name, Both(c, gc)) -> Method(name, gc'')
		with
			//<debug> "method-wp";
			//<debug> name;
			cname := <_nabl-uri ; _nabl-uri-parent ; _nabl-uri-name> name;
	 		all-model-invariants* := <collect-all(?Invariant(_,_))>ast;
			assign-paths* := <map(\Assign(path, expr) -> path \)><collect-all(?Assign(_,_))> gc;
			//<debug> "all invariants";
			//<debug> all-model-invariants*;
			//<debug> "all paths";
			//<debug> assign-paths*;
			invariant := <conjoin-constraints><nub><concat><map(\ path -> <filter(invariant-matches-path(|path, cname))> all-model-invariants* \)> assign-paths*;
			//<debug> "invariant";
			//<debug> <pp-Constraint-string> invariant;
			//<debug> <pp-Constraint-string> <conjoin-constraints><nub><concat><map(\ path -> <literal-subst>(<filter(invariant-matches-path(|path))> all-model-invariants*, [(This(), <path-prefix> path) ]) \)> assign-paths*;
			//<debug> <map(\ path -> <literal-subst>(<filter(invariant-matches-path(|path))> all-model-invariants*, [(This(), <path-prefix> path) ]) \)> assign-paths*;
			(c', gc') := <gc-wp(|ast,And(<make-pre-state> c, invariant))>gc;
			gc'' := Guard(c', gc')
			//g|[~c' --> ~gc']|

rules
	
	gc-wp(|ast,c): |[skip]| -> (c, Skip())
	
	gc-wp(|ast, c): Assign(path, expr) -> (c', Assign(path, expr)) 
		where
			//<debug> "assign";
			//<debug> <pp-Constraint-string> c;
			//<debug> <pp-Path-string> path;
			//<debug> <pp-Constraint-string> Equal(expr, expr);
			c' := <aliasing-subst(|path, expr)> c
			//<debug> <pp-Constraint-string> c'

	gc-wp(|ast, c): New(o, cl) -> (c', New(o,cl))
		where	
			c' := <aliasing-subst(|PathStart(cl, None()), Union(PathStart(cl, None()), SetExtent([Output(o)])))>c

	gc-wp(|ast, c): Guard(g,p) -> (And(c,c'), Guard( And(c', g), p'))
		where
			(c', p') := <gc-wp(|ast, c)> p	

	gc-wp(|ast, c): Sequence(p1,p2) -> (c'', Sequence(p1',p2'))
		where
			(c', p2') := <gc-wp(|ast, c)> p2;
			(c'', p1') := <gc-wp(|ast, c')> p1

	gc-wp(|ast, c): Parallel(p1,p2) -> ( c'', Parallel(p1',p2'))
		where
			(c', p2') := <gc-wp(|ast, c)> p2;
			(c'', p1') := <gc-wp(|ast, c')> p1

	gc-wp(|ast, c): Choice(p1,p2) -> ( Or(c1,c2), Choice(Guard(c1, p1'),Guard(c2, p2')))
		where
			(c1, p2') := <gc-wp(|ast, c)> p2;
			(c2, p1') := <gc-wp(|ast, c)> p1




	// catch all
	gc-wp(|ast,c): gc -> (c, gc)
		where 
			<debug> "wp failure!!";
			<debug> gc


	invariant-matches-path(|path, C):
			Invariant(iname, invp) -> invp'
	where
			attsMentioned* := <_relation-lookup(|"<hasInv:")> iname;
			<elem> (<_nabl-collect-use;_nabl-uri> path, attsMentioned*);
			
			/* Going to transform the invariant, as per the documentation */
			/* Find the paths A.p.x and C.q.x */
			/* And calculate the invariant in terms of C.q.~p.x */
			
			/* A is the class in which the invariant was defined */
			A := <_nabl-uri ; _nabl-uri-parent ; _nabl-uri-name> iname;
			//<debug> "A";
			//<debug> A;
			//<debug> "C";
			//<debug> C;
			//<debug> "C.q.x";
			//<debug> <pp-Path-string> path;
			
			Apxs := <filter(\p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p, <_nabl-collect-use;_nabl-uri> path)\)><collect-all(is-path)> invp;
			//<debug> "A.p.x";
			//<debug> <map(pp-Path-string)>Apxs;
			Cqpxs := <map(\p -> <join-paths> (<path-prefix> path, <path-prefix> p)\)> Apxs;
			
			//<debug> "C.q.~p.x";
			//<debug> <map(pp-Path-string)> Cqpxs;

			//<debug> "new inv";
			invp' := <conjoin-constraints><nub-an><map(contextualize-invariant(|invp))> Cqpxs
			//<debug> <pp-Constraint-string> invp'
			
			//<debug> "Invariant matches path!";
			//<debug> <pp-Constraint-string> invp;
			//<debug> "path";
			//<debug> <pp-Path-string> path;
			//<debug> "invariant parent";
			//<debug> <_nabl-uri ; _nabl-uri-parent ; _nabl-uri-name> iname;
			//<debug> "paths mentioned";
			//<debug> <map(pp-Path-string)><collect-all(is-path)> invp;
			
			//<debug> "all paths";
			//<debug> <collect-all-paths> invp;
			
			//<debug> <filter(\p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , <_nabl-collect-use;_nabl-uri> path) \)> <collect-all-paths> invp;
			//<debug> <map(\p1 -> <literal-subst>(invp, [(p1, path)]) \)><filter(\p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , <_nabl-collect-use;_nabl-uri> path) \)> <collect-all-paths> invp;	
			//<debug> path;			
			//invp' := <conjoin-constraints><nub-an><map(\p1 -> <literal-subst>(invp, [(p1, path)]) \)><filter(\p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , <_nabl-collect-use;_nabl-uri> path) \)> <collect-all-paths> invp		
			//<debug> <pp-Constraint-string> invp'

	contextualize-invariant(|const) : 
		path -> Forall("o", path , <literal-subst>(const, [(This(), PathStart("o", None()))]))
		where
			<attr-is-set> path

	contextualize-invariant(|const) : 
		path -> <literal-subst>(const, [(This(), path)])
		where
			<not(attr-is-set)> path
	


	// Class names cannot be aliased!
	aliasing-subst(|path, expr): constraint -> <literal-subst> (constraint, [(path, expr)])
		where
			PathStart(p, _) := path;
			<is-class-name> p

	aliasing-subst(|path, expr): Not(a) -> Not(<aliasing-subst(|path, expr)> a)
	aliasing-subst(|path, expr): And(a,b) -> And(<aliasing-subst(|path, expr)> a, <aliasing-subst(|path, expr)> b)
	aliasing-subst(|path, expr): Or(a,b) -> Or(<aliasing-subst(|path, expr)> a, <aliasing-subst(|path, expr)> b)
	aliasing-subst(|path, expr): Implies(a,b) -> Implies(<aliasing-subst(|path, expr)> a, <aliasing-subst(|path, expr)> b)
	aliasing-subst(|path, expr): Forall(i, expr',a) -> Forall(i, expr', <aliasing-subst(|path, expr)> a)
	aliasing-subst(|path, expr): Exists(i, expr',a) -> Exists(i, expr', <aliasing-subst(|path, expr)> a)


	aliasing-subst(|path, expr): constraint -> constraint'
		where
			path-uri := <_nabl-collect-use;_nabl-uri> path;
			// this will collect duplicate paths - n is the same as n, but their locations are different.
			// nub cannot fix this - do it some other way!
			matching-paths* := <nub-an> <filter(\ p -> p where <equal>(<_nabl-collect-use;_nabl-uri> p , path-uri) \)> <collect-all-paths> constraint;
			constraint' := <conjoin-constraints> <map(\s -> <generate-constraint> (s, <diff>(matching-paths*, s), path, expr, constraint)\)><subsets> matching-paths*
			
			
	literal-subst: (constraint, substs) -> constraint''
		where
			//<debug> "literal-subst";
			//<debug> <pp-Constraint-string> constraint;
			constraint' := <bottomup(try(path-add-this))> constraint;
			//<debug> <pp-Constraint-string> constraint';
			substs' := <map(\ (t,e) -> ( <remove-all-annotations><bottomup(try(path-add-this))> t , e) \)> substs;
			//<debug> substs';
			constraint'' := <bottomup(try(\ trm -> <lookup> (<remove-all-annotations><path-add-this> trm  , substs')\))> constraint'
			
	remove-all-annotations = bottomup(try(\ t -> t {}\)) 
		
		
		
//	generate-constraint: ([], neg, path, expr, constraint) -> constraint

	generate-constraint: (pos, [], path, expr, constraint) -> Implies(constraint1, constraint3)
		where
			constraint1 := <conjoin-constraints> <map(\ p -> Equal(<path-prefix> p, <path-prefix> path) \)> pos;
			constraint3 := <literal-subst> (constraint, <map(\ p -> (p, expr)\)> pos)

	generate-constraint: (pos, neg, path, expr, constraint) -> Implies(And(constraint1, constraint2), constraint3)
		where
			constraint1 := <conjoin-constraints> <map(\ p -> Equal(<path-prefix> p, <path-prefix> path) \)> pos;
			constraint2 := <conjoin-constraints> <map(\ q -> NotEqual(<path-prefix> q, <path-prefix> path) \)> neg;
			constraint3 := <literal-subst> (constraint, <map(\ p -> (p, expr)\)> pos)
			 
rules
	


	
rules

