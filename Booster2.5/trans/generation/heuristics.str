module trans/generate/heuristics

imports
	include/booster25
	trans/api/_runtime
	trans/api/_runtime-constructors
	trans/api/constraint
	trans/lib/search
	trans/names
	
rules
	
	heuristics = 
		try(sometd(method-heuristics))
	
rules
	
	method-heuristics: Method(name, const) -> Method(name, Both(const, gc))
		with
			gc := <program>const

rules
	
	// @type Constraint -> GuardedCommand
	program:  |[true]|       ->  |[skip]|
	program:  |[false]|      ->  |[false --> skip]|
	program:  |[~c1 & ~c2]|  ->  |[~p1 || ~p2]|                        with p1 := <program>c1; p2 := <program>c2
	program:  |[~c1 or ~c2]| ->  |[~p1 [ ] ~p2]|                       with p1 := <program>c1; p2 := <program>c2
	program: c|[~c1 ; ~c2]|  -> g|[~p1 ; ~p2]|                         with p1 := <program>c1; p2 := <program>c2
	program:  |[~c1 => ~c2]| ->  |[~c1 --> ~p2 [ ] not ~c1 --> skip]|  with p2 := <program>c2
	program:  |[not ~c1]|    ->  |[not ~c1 --> skip]|
	
	program: Exists(name, expr, c1) -> Any(name, expr, <program>c1)
	program: Forall(name, expr, c1) -> All(name, expr, <program>c1)
		where
			<not(is-pre-state)> c1
	
	program: |[x_a.x_b ' = ~e]|  ->  |[x_a.x_b := ~e]| 
		where
			<is-pre-state>e
			
	program: |[~e : x_a.x_b ']|  ->  |[x_a.x_b := x_a.x_b \/ {~e}]| 
		where
			<is-pre-state>e
			
	program: |[x_output ! : x_c1 ']|  ->  |[new x_output ! : x_c1]|

	program: x -> Skip()
		where
			log(|Warning(), "cannot determine program", x)

rules