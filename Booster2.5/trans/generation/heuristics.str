module trans/generation/heuristics

imports
	include/Booster25
	trans/api/_runtime
	trans/api/_runtime-constructors
	trans/api/attribute
	trans/api/constraint
	trans/api/expression
	trans/lib/search
	trans/names
	trans/pp
	
rules
	
	heuristics = 
		try(sometd(method-heuristics))
	
rules
	
	method-heuristics: Method(name, const) -> Method(name, Both(const, gc))
		with
			gc := <program>const

rules
	
	// @type Constraint -> GuardedCommand
	
	program:  |[true]|       ->  |[skip]|		
	program:  |[false]|      ->  |[false --> skip]|
	program:  |[~c1 & ~c2]|  ->  |[~p1 || ~p2]|                        with p1 := <program>c1; p2 := <program>c2
	program:  |[~c1 or ~c2]| ->  |[~p1 [ ] ~p2]|                       with p1 := <program>c1; p2 := <program>c2
	program: c|[~c1 ; ~c2]|  -> g|[~p1 ; ~p2]|                         with p1 := <program>c1; p2 := <program>c2
	program:  |[~c1 => ~c2]| ->  |[~c1 --> ~p2 [ ] not ~c1 --> skip]|  with p2 := <program>c2

	program:  |[not ~c1]|    ->  |[not ~c1 --> skip]|
	
	program: |[exists x : ~e @ ~c1 ]| -> |[ANY x : ~e . ~p1]|                               with p1 := <program>c1
	program: |[forall x : ~e @ ~c1 ]| -> |[ALL x : ~e . ~p1]| where <not(is-pre-state)> c1  with p1 := <program>c1

	program: |[x_a '     = ~e]|       ->  |[x_a     := ~e]|                where <is-pre-state>e
	program: |[x_a.x_b ' = ~e]|       ->  |[x_a.x_b := ~e]|                where <is-pre-state>e
	program: |[~e : x_a.x_b ']|       ->  |[x_a.x_b := x_a.x_b \/ {~e}]|   where <is-pre-state>e
	program: |[x_output! : x_c1 ']|   ->  |[new x_output! : x_c1]|

rules // assign to bidirectional relations
	

// Mandatory -> Mandatory --- Add
	program: |[y ' = x!]| -> |[x! /: x_classX --> ( (new x! : x_classX) ; ((y := x!) || (x!.z := this)) )]|

		where
			z := <attr-get-inverse>y;
			<attr-is-mandatory>y;
			<attr-is-mandatory>z;
			x_classX := <_get-type>x


			
// Mandatory -> Optional --- Add
	program: |[y ' = ~e]| -> |[~e.z = null --> (y := ~e || ~e.z := this)]|
		where
			z := <attr-get-inverse>y;
			<attr-is-mandatory>y;
			<attr-is-optional>z;
			<is-obj-expression> e
	
// Mandatory -> Set-valued --- Add
	program: |[y ' = ~e]| -> |[(y := ~e || ~e.z := ~e.z \/ {this})]|
		where
			z := <attr-get-inverse>y;
			<attr-is-mandatory>y;
			<attr-is-set>z;
			<is-obj-expression> e

// Optional -> Mandatory --- Add
	program: |[y ' = x!]| -> |[y = null --> (new x! : x_classX) ; (( y := x! || x!.z := this))  ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-optional>y;
			<attr-is-mandatory>z;
			x_classX := <_get-type>x

// Optional -> Optional --- Add
	program: |[y ' = ~e]| -> |[~e.z = null --> (y := ~e || ~e.z := this || 
																(y /= null --> y.z := null
																[]
																y = null --> skip))]|
		where
			z := <attr-get-inverse>y;
			<attr-is-optional>y;
			<attr-is-optional>z;
			<is-obj-expression> e

// Optional -> Set-valued --- Add
	program: |[y ' = ~e]| -> |[(y := ~e || ~e.z := ~e.z \/ {this} || 
																(y /= null --> y.z := y.z /\ {this}
																[]
																y = null --> skip))]|
		where
			z := <attr-get-inverse>y;
			<attr-is-optional>y;
			<attr-is-set>z;
			<is-obj-expression> e

// Set-valued -> Mandatory --- Add
	program: |[x! : y ']| -> |[(new x! : x_classX) ; (( y := y \/ {x!} || x!.z := this))  ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-set>y;
			<attr-is-mandatory>z;
			x_classX := <_get-type>x

// Set-valued -> Optional --- Add
	program: |[~e : y ']| -> |[~e.z = null --> (y := y \/ {~e} || ~e.z := this ) ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-set>y;
			<attr-is-optional>z;
			<is-obj-expression> e

// Set-valued -> Set-valued --- Add
	program: |[~e : y ']| -> |[(y := y \/ {~e}) || (~e.z := ~e.z \/ {this})]|
		where
			z := <attr-get-inverse>y;
			<attr-is-set>y;
			<attr-is-set>z;
			<is-obj-expression> e

// Mandatory -> Anything --- Remove
	program: |[y ' = null]| -> |[false --> skip]|
		where
			z := <attr-get-inverse>y;
			<attr-is-mandatory>y

// Optional -> Mandatory --- Remove
	program: |[y ' = null]| -> |[false --> skip]|
		where
			z := <attr-get-inverse>y;
			<attr-is-optional>y;
			<attr-is-mandatory>z
	

// Optional -> Optional --- Remove
	program: |[y ' = null]| -> |[y /= null --> (y := null || y.z := null) ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-optional>y;
			<attr-is-optional>z
			
// Optional -> Set-valued --- Remove
	program: |[y ' = null]| -> |[y /= null --> (y := null || y.z := y.z /\ {this}) ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-mandatory>z

// Set-valued -> Mandatory --- Remove
	program: |[~e /: y ']| -> |[false --> skip]|
		where
			z := <attr-get-inverse>y;
			<attr-is-set>y;
			<attr-is-mandatory>z;
			<is-obj-expression> e

// Set-valued -> Optional --- Remove
	program: |[~e /: y ']| -> |[~e /: y --> (y := y /\ {~e} || y.z := null) ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-set>y;
			<attr-is-optional>z;
			<is-obj-expression> e

// Set-valued -> Set-valued --- Remove
	program: |[~e /: y ']| -> |[~e /: y --> (y := y /\ {~e} || y.z := y.z - {~e}) ]|
		where
			z := <attr-get-inverse>y;
			<attr-is-set>y;
			<attr-is-set>z;
			<is-obj-expression> e


			


rules // catch all not supported

	program: x -> Skip()
		where
			log(|Warning(), "cannot determine program", <pp-Constraint-string> x)

rules