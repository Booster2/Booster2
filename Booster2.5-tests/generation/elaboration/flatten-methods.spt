module generation-elaboration-flatten-attributes

language Booster25

setup Common [[
	system debug
]]

test Flatten single method [[
	class A           { attributes i : int methods	m {i' = i?}	}
	class B extends A {}
]] build elaborate-builder-ast to [[
	class A           { attributes i : int methods	m {i' = i?}	}
	class B extends A { attributes i : int methods	m {i' = i?}	}
]]

test Flatten single method transitively [[
	class A           { attributes i : int methods	m {i' = i?}	}
	class B extends A {}
	class C extends B {}
]] build elaborate-builder-ast to [[
	class A           { attributes i : int methods	m {i' = i?}	}
	class B extends A { attributes i : int methods	m {i' = i?}	}
	class C extends B { attributes i : int methods	m {i' = i?}	}
]]

test Flatten single method conjoin [[
	class A           { attributes i : int j : int methods	m {i' = i?}}
	class B extends A {                            methods	m {j' = j?}}
]] build elaborate-builder-ast to [[
	class A           { attributes i : int j : int methods	m {i' = i?}}
	class B extends A { attributes i : int j : int methods	m {i' = i? & j' = j?}}
]]

test Flatten single method conjoin transitively [[
	class A           { attributes i : int j : int k : int methods	m {i' = i?}}
	class B extends A {                                    methods	m {j' = j?}}
	class C extends B {                                    methods	m {k' = k?}}
]] build elaborate-builder-ast to [[
	class A           { attributes i : int j : int k : int methods	m {i' = i?}}
	class B extends A { attributes i : int j : int k : int methods	m {i' = i? & j' = j?}}
	class C extends B { attributes i : int j : int k : int methods	m {i' = i? & j' = j? & k' = k?}}
]]

test Flatten import two methods from hierarchy [[
	class A           { attributes i : int         methods	m {i' = i?}	}
	class B extends A { attributes j : int         methods	n {j' = j?}	}
	class C extends B {}
]] build elaborate-builder-ast to [[
	class A           { attributes i : int         methods	m {i' = i?}	}
	class B extends A { attributes i : int j : int methods	m {i' = i?} n {j' = j?}	}
	class C extends B { attributes i : int j : int methods	m {i' = i?} n {j' = j?}	}
]]

test Flatten import two methods from two supers [[
	class A             { attributes i : int         methods	m {i' = i?}	}
	class B             { attributes j : int         methods	n {j' = j?}	}
	class C extends A,B {}
]] build elaborate-builder-ast to [[
	class A             { attributes i : int         methods	m {i' = i?}	}
	class B             { attributes j : int         methods	n {j' = j?}	}
	class C extends A,B { attributes i : int j : int methods	m {i' = i?} n {j' = j?}	}
]]

test Flatten single method conjoin two supers [[
	class A             { attributes i1 : int j1 : int          methods	m {i1' = i?}}
	class B             { attributes k1 : int                   methods	m {k1' = k?}}
	class C extends A,B {                                       methods	m {j1' = j?}}
]] build elaborate-builder-ast to [[
	class A             { attributes i1 : int j1 : int          methods	m {i1' = i?}}
	class B             { attributes k1 : int                   methods	m {k1' = k?}}
	class C extends A,B { attributes i1 : int j1 : int k1 : int methods	m {i1' = i? & k1' = k? & j1' = j? }}
]]
