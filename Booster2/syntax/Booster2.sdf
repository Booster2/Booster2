%% Grammar for the Booster language
%% By default, based on an example "entities" syntax
module Booster2

imports Common AbstractBoosterModel Relational

exports

   context-free start-symbols
  	System
  	  	
  context-free syntax
    
  
	'system' ID ( SystemComponent )* -> System {cons("System")}
	System -> BoosterTerm

	
	SetDef -> SystemComponent
	Class -> SystemComponent
	SystemComponent -> BoosterTerm

	'class' ID '{' ClassComponents * '}' -> Class  {cons("Class")}
	Class -> BoosterTerm
	 
	'attributes' Attribute*  -> ClassComponents {cons("Attributes")}
	'methods' Method*  -> ClassComponents {cons("Methods")}
	'invariant' Constraint* -> ClassComponents {cons("Invariant")}
	ClassComponents -> BoosterTerm
	 
	 'set' ID '{' {ID ','}+ '}' -> SetDef {cons("SetDef")}
	 SetDef -> BoosterTerm
	 
	 ID ':' TypeDecl -> Attribute {cons("Attribute")}
	 ID Identity ':' TypeDecl -> Attribute {cons("Attribute")}
	 ID ':' TypeDecl -> Attribute {cons("Attribute")}
	 Attribute -> BoosterTerm
	 
	 '(' 'ID' ')' -> Identity {cons("Identity")}
  
	 ID '{' Constraint '}' -> Method {cons("Method")}
	 ID '{' GuardedCommand '}' -> Method {cons("Method")}
	 Method -> BoosterTerm
	 
	 PrimTypeDecl -> TypeDecl  
	 '[' PrimTypeDecl ']' -> TypeDecl {cons("Optional")} 
	 'set' '(' PrimTypeDecl ')' '[' Multiplicity ']' ->  TypeDecl {cons("Set")}
	 TypeDecl -> BoosterTerm
	 
	 BasicTypeDecl -> PrimTypeDecl {cons("BasicType")}
	 
	 
	 
	 'STRING' -> BasicTypeDecl {cons("String")}
	 'INT' -> BasicTypeDecl {cons("Int")}
	 'DATETIME' -> BasicTypeDecl {cons("DateTime")}
	 
	 ID -> PrimTypeDecl {cons("UniDirectional")}
	 ID '.' ID -> PrimTypeDecl {cons("BiDirectional")}
	 PrimTypeDecl -> BoosterTerm
	 
	 INT '..' INT -> Multiplicity {cons("MultMinAndMax")}
	     '..' INT -> Multiplicity {cons("MultJustMax")}
	 INT '..'     -> Multiplicity {cons("MultJustMin")}
	 INT '..' '*' -> Multiplicity {cons("MultJustMin")}
	      INT     -> Multiplicity {cons("MultSingle")}
	 	  '*'     -> Multiplicity {cons("MultAny")}
	 Multiplicity -> BoosterTerm
	 
  	 'true' 			-> Constraint {cons("True")}
  	 'false' 			-> Constraint {cons("False")}
  	 Relation 			-> Constraint 
  	 'not' Constraint		-> Constraint { cons("Not")}
  	 Constraint '&' Constraint 	-> Constraint { cons("And"), assoc}
  	 Constraint 'or' Constraint 	-> Constraint { cons("Or"), assoc}
 	 Constraint '=>' Constraint 	-> Constraint { cons("Implies"), assoc}
 	 Constraint ';' Constraint 	-> Constraint { cons("Then"), assoc}
 	 "(" Constraint ")" 		-> Constraint { bracket}
  	 MethodReference -> Constraint {cons("MethodRef")}
    'exists' ID
       ":" Expression
       "@" Constraint		-> Constraint {cons("Exists")}
    'forall' ID
       ":" Expression
       "@" Constraint		-> Constraint {cons("Forall")}
  	Constraint -> BoosterTerm 
  	 
  	Expression BinRel Expression -> Relation {cons("BinRel")}
  	 
  	'=' 	-> BinRel {cons("Equal")}
    '/=' 	-> BinRel {cons("NotEqual")}
    ':' 	-> BinRel {cons("In")}
    '/:' 	-> BinRel {cons("NotIn")}
    '<' 	-> BinRel {cons("LessThan")}
    '>' 	-> BinRel {cons("GreaterThan")}
    '<=' 	-> BinRel {cons("LessThanEquals")}
    '>=' 	-> BinRel {cons("GreaterThanEquals")}
    '<:' 	-> BinRel {cons("Subset")}
    '<<:' 	-> BinRel {cons("SubsetEquals")}
    ':>' 	-> BinRel {cons("Superset")}
    ':>>' 	-> BinRel {cons("SupersetEquals")}
    Relation -> BoosterTerm
    
    
    
    BasicValue -> ValueExpression {cons("BasicValue")}
    INT 		-> BasicValue {cons("Integer")}
    STRING		-> BasicValue {cons("String")}

    TypeExtent -> ValueExpression {cons("TypeExtent")}
  	"STRING"	-> TypeExtent {cons("String"), prefer}
  	"INT"		-> TypeExtent {cons("Int"), prefer}
  	"DATETIME"	-> TypeExtent {cons("DateTime"), prefer}

    Path		-> ValueExpression 
  	'null'		-> ValueExpression {cons("Null"), prefer}
    "{" {Expression "," }* "}" -> ValueExpression {cons("SetExtent")}
    ValueExpression -> BoosterTerm
    
    ValueExpression 	-> Expression
    'head' Expression	-> Expression {cons("Head"), avoid}
    'tail' Expression 	-> Expression {cons("Tail"), avoid}
    'card' Expression 	-> Expression {cons("Cardinality"), avoid}
    '-' Expression 		-> Expression {cons("Negative"), avoid}
    "(" Expression ")" 	-> Expression {bracket}
    
    
    Expression BinOp Expression -> Expression {left, cons("BinOp")}
    
    
    "+"		-> BinOp {left, cons("Plus")}
    "-" 	-> BinOp {left, cons("Minus")}
    "*" 	-> BinOp {left, cons("Times")}
    "/" 	-> BinOp {left, cons("Divide")}
    "max" 	-> BinOp {left, cons("Maximum")}
    "min" 	-> BinOp {left, cons("Minimum")}
    "/\\" 	-> BinOp {left, cons("Intersection")}
    "\\/" 	-> BinOp {left, cons("Union")}
    "++" 	-> BinOp {left, cons("Concat")}
    
    Expression -> BoosterTerm
    
    
    Path '(' { ( ID '?' '=' Expression) "," }* ')' -> MethodReference {cons("MethodReference")}
    MethodReference -> BoosterTerm
   
    PathStart -> Path
    Path '.' PathComponent -> Path {cons("Path")}
    Path -> BoosterTerm
    
    Input -> PathStart
    Output -> PathStart
    This -> PathStart
    ThisPrimed -> PathStart
    ID Decorator? -> PathStart {cons("PathStart")}
    PathStart -> BoosterTerm
  
    ID "?" -> Input {cons("Input")}
    ID "!" -> Output {cons("Output")}
    'this' -> This {cons("This")}
    'this' "'" -> ThisPrimed {cons("ThisPrimed")}

    "'" -> Decorator {cons("Primed")}
	Decorator -> BoosterTerm
	
  	ID Decorator? -> PathComponent {cons("PathComponent")}
  	PathComponent -> BoosterTerm
  	
 exports 
 variables
  	  "Name"[0-9]* -> ID {prefer}
  	  "Const"[0-9]* -> Constraint {prefer}
  	  "SystemComponents"[0-9]* "*" -> ( SystemComponent )* {prefer}

context-free priorities
	 'not' Constraint		-> Constraint 
	 > Constraint '&' Constraint 	-> Constraint 
  	 > Constraint 'or' Constraint 	-> Constraint
 	 > Constraint '=>' Constraint 	-> Constraint 
 	 > Constraint ';' Constraint 	-> Constraint 

context-free priorities
	'head' Expression	-> Expression
    > 'tail' Expression 	-> Expression
    > 'card' Expression 	-> Expression
    > '-' Expression 		-> Expression
    > Expression "max" Expression 	-> Expression
    > Expression "min" Expression 	-> Expression
    > Expression  "*"  Expression 	-> Expression
    > Expression  "/"  Expression 	-> Expression
    > Expression  "+"  Expression 	-> Expression
    > Expression  "-"  Expression 	-> Expression
    > Expression "/\\" Expression 	-> Expression
    > Expression "\\/" Expression 	-> Expression
    > Expression  "++" Expression 	-> Expression
