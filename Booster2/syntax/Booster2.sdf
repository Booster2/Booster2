%% Grammar for the Booster language
%% By default, based on an example "entities" syntax
module Booster2

imports Common AbstractBoosterModel Relational

exports

   context-free start-symbols
  	System
  	  	
  context-free syntax
    
	'system' ID ( SystemComponent )* -> System {cons("System")}
	System -> BoosterTerm

	
	SetDef -> SystemComponent
	Class -> SystemComponent
	
	SystemComponent -> BoosterTerm

	'class' ID Extends? '{' ClassComponents * '}' -> Class  {cons("Class")}
	Class -> BoosterTerm
	
	'extends' {Extension ','}+ -> Extends {cons("Extend")}
	Extends -> BoosterTerm
	
	ID -> Extension {cons("Extension")}
	 
	'attributes' Attribute*  -> ClassComponents {cons("Attributes")}
	'methods' Method*  -> ClassComponents {cons("Methods")}
	'invariants' Constraint* -> ClassComponents {cons("Invariant")}
	
	
	%% Workflow Stuff Begin
	'workflows' WorkflowComponent* -> ClassComponents {cons("Workflows")}
	%% Workflow Stuff End
	
	
	
	ClassComponents -> BoosterTerm
	 
	 'set' ID '{' {ID ','}+ '}' -> SetDef {cons("SetDef")}
	 SetDef -> BoosterTerm
	 
	 ID Decoration* ':' TypeDecl -> Attribute {cons("Attribute")}

	 Attribute -> BoosterTerm
	 
	 '(' 'ID' ')' -> Identity {cons("Identity")}
	 
	 Identity -> Decoration
  
	 ID '{' Constraint '}' -> Method {cons("Method")}
	 ID '{' Expression '}' -> Method {cons("Method"), deprecated}
	 ID '{' GuardedCommand '}' -> Method {cons("Method")}
	 Method -> BoosterTerm
	 
	 PrimTypeDecl -> TypeDecl  
	 '[' PrimTypeDecl ']' -> TypeDecl {cons("Optional")} 
	 'set' '(' PrimTypeDecl ')' '[' Multiplicity ']' ->  TypeDecl {cons("Set")}
	 TypeDecl -> BoosterTerm
	 
	 BasicTypeDecl -> PrimTypeDecl {cons("BasicType")}
	 
	 
	 
	 'STRING' -> BasicTypeDecl {cons("String")}
	 'INT' -> BasicTypeDecl {cons("Int")}
	 'DATETIME' -> BasicTypeDecl {cons("DateTime")}
	 'BOOLEAN' -> BasicTypeDecl {cons("Boolean")}
	 
	 ID -> PrimTypeDecl {cons("UniDirectional")}
	 ID '.' ID -> PrimTypeDecl {cons("BiDirectional")}
	 PrimTypeDecl -> BoosterTerm
	 
	 INT '..' INT -> Multiplicity {cons("MultMinAndMax")}
	     '..' INT -> Multiplicity {cons("MultJustMax")}
	 INT '..'     -> Multiplicity {cons("MultJustMin")}
	 INT '..' '*' -> Multiplicity {cons("MultJustMin")}
	      INT     -> Multiplicity {cons("MultSingle")}
	 	  '*'     -> Multiplicity {cons("MultAny")}
	 Multiplicity -> BoosterTerm
	 
  	 'true' 			-> Constraint {cons("True")}
  	 'false' 			-> Constraint {cons("False")}
  	 Relation 			-> Constraint 
  	 'not' Constraint		-> Constraint { cons("Not")}
  	 Constraint '&' Constraint 	-> Constraint { cons("And"), assoc}
  	 Constraint 'or' Constraint 	-> Constraint { cons("Or"), assoc}
 	 Constraint '=>' Constraint 	-> Constraint { cons("Implies"), assoc}
 	 Constraint ';' Constraint 	-> Constraint { cons("Then"), assoc}
 	 "(" Constraint ")" 		-> Constraint { bracket}
  	 MethodReference -> Constraint {cons("MethodRef")}
    'exists' ID
       ":" Expression
       "@" Constraint		-> Constraint {cons("Exists")}
    'forall' ID
       ":" Expression
       "@" Constraint		-> Constraint {cons("Forall")}
  	Constraint -> BoosterTerm 
  	 
  	Expression BinRel Expression -> Relation {cons("BinRel")}
  	 
  	'=' 	-> BinRel {cons("Equal")}
    '/=' 	-> BinRel {cons("NotEqual")}
    ':' 	-> BinRel {cons("In")}
    '/:' 	-> BinRel {cons("NotIn")}
    '<' 	-> BinRel {cons("LessThan")}
    '>' 	-> BinRel {cons("GreaterThan")}
    '<=' 	-> BinRel {cons("LessThanEquals")}
    '>=' 	-> BinRel {cons("GreaterThanEquals")}
    '<:' 	-> BinRel {cons("Subset")}
    '<<:' 	-> BinRel {cons("SubsetEquals")}
    ':>' 	-> BinRel {cons("Superset")}
    ':>>' 	-> BinRel {cons("SupersetEquals")}
    Relation -> BoosterTerm
    
    
    
    BasicValue -> ValueExpression {cons("BasicValue")}
    INT 		-> BasicValue {cons("Integer")}
    STRING		-> BasicValue {cons("String")}

    TypeExtent -> ValueExpression {cons("TypeExtent")}
  	'string'	-> TypeExtent {cons("String"), prefer}
  	'int'		-> TypeExtent {cons("Int"), prefer}
  	'datetime'	-> TypeExtent {cons("DateTime"), prefer}
  	'boolean'	-> TypeExtent {cons("Boolean"), prefer}

	Path		-> ValueExpression {} 
  	'null'		-> ValueExpression {cons("Null"), prefer}
    "{" {Expression "," }* "}" -> ValueExpression {cons("SetExtent")}
    ValueExpression -> BoosterTerm
    
    ValueExpression 	-> Expression
    'head' Expression	-> Expression {cons("Head")}
    'tail' Expression 	-> Expression {cons("Tail")}
    'card' Expression 	-> Expression {cons("Cardinality")}
    '-' Expression 		-> Expression {cons("Negative")}
    "(" Expression ")" 	-> Expression {bracket}
  
    
    Expression BinOp Expression -> Expression {cons("BinOp"), left}
    
    
    "+"		-> BinOp {cons("Plus")}
    "-" 	-> BinOp {cons("Minus")}
    "*" 	-> BinOp {cons("Times")}
    "/" 	-> BinOp {cons("Divide")}
    "max" 	-> BinOp {cons("Maximum")}
    "min" 	-> BinOp {cons("Minimum")}
    "/\\" 	-> BinOp {cons("Intersection")}
    "\\/" 	-> BinOp {cons("Union")}
    "++" 	-> BinOp {cons("Concat")}
    
    Expression -> BoosterTerm
    
    
    Path '(' { ( ID '?' '=' Expression) "," }* ')' -> MethodReference {cons("MethodReference")}
    MethodReference -> BoosterTerm
   
    PathStart -> Path
%%    PathStart '.' {PathComponent '.'}+  -> Path {cons("PathError"), prefer}    
    
    Path '.' PathComponent -> Path {cons("Path"), prefer}
    Path -> BoosterTerm
    
    
    
    Input -> PathStart
    Output -> PathStart
    This -> PathStart
    ThisPrimed -> PathStart
    ID Decorator? -> PathStart {cons("PathStart")}
    PathStart -> BoosterTerm
  
    ID "?" -> Input {cons("Input")}
    ID "!" -> Output {cons("Output")}
    'this' -> This {cons("This")}
    'this' "'" -> ThisPrimed {cons("ThisPrimed")}

    "'" -> Decorator {cons("Primed")}
	Decorator -> BoosterTerm
	
	 -> PathComponent {cons("PathComponent"), deprecated}
	
  	ID Decorator? -> PathComponent {cons("PathComponent")}
  	PathComponent -> BoosterTerm
  	
  	

%% *****************************************************************
%% ********** Workflow Stuff - BEGIN *******************************
%% *****************************************************************

  'Normal' Constraint 						-> Guard {cons("Normal")}
  'Delayed' Constraint 						-> Guard {cons("Delayed")}
  "(" Guard ")"								-> Guard {bracket}
  
  
  Guard '&' MethodReference					-> GuardedAction {cons("GA")}
  
  
  'Skip'									-> SeqWfExpression {cons("Skip")}
  
  GuardedAction '->' SeqWfExpression
  '[]' 
  GuardedAction '->' SeqWfExpression 		-> SeqWfExpression{cons("Choice")}
  
  'WAIT.' INT '.' INT '->' SeqWfExpression	-> SeqWfExpression {cons("Wait")}

  'seq' ID ':' SeqWfExpression 		-> SeqWf {cons("SeqWf")}
  
  %% The following definitions are supposed to be syntactic sugar and should be simplified before
  %% doing precondition calculation
  ID 										-> SeqWfExpression {cons("WorkflowReference")}
  
  GuardedAction '->' SeqWfExpression 		-> SeqWfExpression {cons("Prefix")}

  "(" SeqWfExpression ")" 					-> SeqWfExpression {bracket}

  
  
  %% Concurrent Workflows
  
  ID										-> ParWfExpression {cons("Single")}
  ID '|||' ParWfExpression					-> ParWfExpression {cons("Multiple")}
  
  'par' ID ':' ParWfExpression				-> ParWf {cons("ParWf")}
  
  
  
  
  SeqWf -> WorkflowComponent
  ParWf -> WorkflowComponent
    
%% *****************************************************************
%% ********** Workflow Stuff - END *********************************
%% *****************************************************************	  
  	
 exports 
 variables
  	  "Name"[0-9]* -> ID {prefer}
  	  "Const"[0-9]* -> Constraint {prefer}
  	  "SystemComponents"[0-9]* "*" -> ( SystemComponent )* {prefer}

context-free priorities
	 'not' Constraint		-> Constraint 
	 > Constraint '&' Constraint 	-> Constraint 
  	 > Constraint 'or' Constraint 	-> Constraint
 	 > Constraint '=>' Constraint 	-> Constraint 
 	 > Constraint ';' Constraint 	-> Constraint 
