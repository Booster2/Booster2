module generate

imports
  include/Booster2
  	
rules



		
/* 	generate-inputs-and-outputs:
		Takes a method constraint, and an Abstract Booster Model and 
		returns an Abstract Booster Model with the ins and outs filled in
*/

/*	generate-inputs-and-outputs:
		AbstractBoosterModel(systemname, sets, classes, extends, invariants, rinvariants, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, [], [], [])
			->
				AbstractBoosterModel(systemname, sets, classes, extends, invariants, rinvariants, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, inputs, outputs, [])
		with 
			inputs := <generate-method-inputs> (constraints, AbstractBoosterModel(systemname, sets, classes, extends, invariants, rinvariants, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, [], [], []));
			outputs := <generate-method-outputs> (constraints, AbstractBoosterModel(systemname, sets, classes, extends, invariants, rinvariants, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, [], [], []))
*/
			
/* 	generate-method-inputs:
		Takes a list of method constraints, and an Abstract Booster Model and 
		returns an list of pairs of pairs: 
			[(classname, methodname), (inputname, type)]
		I can't seem to curry this function, so the map function is built in 
*/

/*	generate-method-inputs:
		([], abm) -> []
			
	generate-method-inputs:
		([((classname, methodname), const), constraints*], abm) 
			-> <union>([((classname, methodname),ins1)], ins2)
		with 
			ins1 := <deduce-types> (classname, methodname, const, abm, "?");
			ins2 := <generate-method-inputs> ([constraints*], abm)		
*/

/* 	generate-method-outputs:
		Takes a list of method constraints, and an Abstract Booster Model and 
		returns an list of pairs of pairs: 
			[(classname, methodname), (outputname, type)]
		I can't seem to curry this function, so the map function is built in 
*/

/*	generate-method-outputs:
		([], abm) -> []
			
	generate-method-outputs:
		([((classname, methodname), const), constraints*], abm) 
			-> <union>([((classname, methodname),outs1)], outs2)
		with 
			outs1 := <deduce-types> (classname, methodname, const, abm,  "!");
			outs2 := <generate-method-outputs> ([constraints*], abm)		
*/

/* 	invert-invariant:
		takes the invariant as a mapping from class names to constraints, and 
		returns a mapping from attributes to constraints 
*/

/*	invert-invariant:
		AbstractBoosterModel(systemname, sets, classes, extends, invariants1, rinvariants, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, inputs, outputs, [])
			-> AbstractBoosterModel(systemname, sets, classes, extends, invariants1, invariants3, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, inputs, outputs, [])
		with
			invariants2 := <realign-invariants>(invariants1, AbstractBoosterModel(systemname, sets, classes, extends, invariants1, rinvariants, cinvariants, attributes, type, maxmult, minmult, ordering, opposite, operations, constraints, inputs, outputs, []));
			invariants3 := <invert-invariants>(attributes, invariants2)
*/

		

		



			
/*			
	split-class-constraints:
		(classname, True())
			-> (classname, [True()])

	split-class-constraints:
		(classname, False())
			-> (classname, [False()])

	split-class-constraints:
		(classname, Not(constraint1))
			-> (classname, [Not(constraint1)])

	split-class-constraints:
		(classname, Or(constraint1, constraint2))
			-> (classname, [Or(constraint1, constraint2)])

	split-class-constraints:
		(classname, Implies(constraint1, constraint2))
			-> (classname, [Implies(constraint1, constraint2)])

	split-class-constraints:
		(classname, Then(constraint1, constraint2))
			-> (classname, [Then(constraint1, constraint2)])
*/


		
			

		
	




		
			
/*
	apply-program
	defined
	pathsets
*/		

/*
	rewrite-invariants:
		[] -> []
*/		
		



