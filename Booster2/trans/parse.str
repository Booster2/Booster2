module parse

imports
  include/Booster2
  
  library/typeDecl
  library/multiplicity
  
rules
	
	
	/* parse: 
		Takes a system and produces a lookup table with all the information in it
	 parse : System
*/

	// Methods for retrieving different types of system components
	getClasses = filter(?Class(_,_,_))
	getSets = filter(?SetDef(_,_))
	
	// Methods for retrieving different types of class components
	getAttributes = <concat> <filter(\ Attributes(attrs) -> attrs \)>
	getMethods = <concat> <filter(\ Methods(meths) -> meths \)>
	getInvariants = <concat> <filter(\ Invariant(invs) -> invs \)>

	getClassComponents = \ Class(_, _, c) -> c \
	getClassName = \ Class(n, _, _) -> n \
	

	parse: 
   		System(name, components) -> 
   				System(name, components)
	with
   		<initialize-lookup-table> name;
   		sets := <map(organise-set)> <getSets> components;
   		classes := <getClasses> components;
   		classes' := <map(organise-class)> classes;
		attributes := []; // <map(organise-attribute)><concat><cart(id)>([name], <map(getClassComponents ; getAttributes)> classes);
		methods := []; //<map(organise-method)><concat><cart(id)>([name], <map(getClassComponents ; getMethods)> classes);
		log(|Error(), <zip>(<map(getClassName)> classes, <map(getClassComponents ; getAttributes)> classes));

		rules(
			LookupTable :+ "Name" ->  name
			LookupTable :+ "SetDef" -> sets 
			LookupTable :+ "Class" ->  classes'
			LookupTable :+ "Attribute" ->  attributes
			LookupTable :+ "Method" ->  methods
		)
	    

	initialize-lookup-table: 
		x -> x 
		with 
			rules(
				LookupTable :+ "Name" -> []
				LookupTable :+ "SetDef" -> []
				LookupTable :+ "Class" -> []
				LookupTable :+ "Attribute" -> []
				LookupTable :+ "Method" -> []
			)

				
		
	organise-set:
		SetDef(name, elements) -> (name, elements)
	
	organise-class:
		Class(name, extends, classComponents)
			-> (name, (extends', attributes, methods, constraints, workflows))
		where
			extends' := <\ None() -> [] \ <+ \ Some(Extend(es)) -> es \> extends;
			attributes := <map(\ Attribute(name, _,_) -> name \)><getAttributes> classComponents;			
			methods := <map(\ Method(name, _ ) -> name \)><getMethods> classComponents;	
			constraints := <getInvariants> classComponents;
			workflows := [];
		log(|Error(), (name, (extends, attributes, methods, constraints, workflows)))
	
	
 	organise-attribute:
 		Attribute(attName, decorators, type)
 			-> (attName, (decorators, type, opposite, minmult, maxmult))
 		where
 			opposite := [];
 			minmult := 1;
 			maxmult := 1
 			
 			 

 	organise-method:
 		(className, Method(methName, constraint))
 			-> ((className, methName), constraint) 
			
			

			
/* getSeq/ParWorfklows

*/
			
	get-class-wfs: 
		Class(name, extends,  classComponents)
			-> ((name,seqWfs),(name,parWfs))
		with
			allWfs := <get-class-wf_sections> Class(name, extends, classComponents);
			seqWfs := <filter(isSeqWf)> allWfs;
			parWfs := <filter(isParWf)> allWfs
	
	get-class-wf_sections:
 		Class(name, extends, classComponents)
 			-> meths
 		where
 			wfSections := <filter(isWorkflowSection)> classComponents;
 			meths := <foldr([], union)> wfSections

	isWorkflowSection:
		 Workflows(wfs) -> wfs
		 
	isSeqWf:
		SeqWf(n,expr) -> SeqWf(n,expr)  
		
	isParWf:
		ParWf(n,expr) -> ParWf(n,expr)  
	



/* get-attribute-type: 
		Takes an attribute and returns its type.
*/
 	
 	get-attribute-type:
 		Attribute(attName, decorations, attType)
 			-> type
 		with
 			type := <get-minimal-type> attType


/* get-attribute-max-mult: 
		Takes an attribute and returns its maximum multiplicity.
*/
 	
 	get-attribute-max-mult:
 		Attribute(attName, decorations, attType)
 			-> maxmult
 		with
 			maxmult := <get-max-mult> attType


/* get-attribute-min-mult: 
		Takes an attribute and returns its minimum multiplicity.
*//* has-opposite: 
		Returns the attribute if it has an opposite.
*/
 	

 	get-attribute-min-mult:
 		Attribute(attName, decorations, attType)
 			-> minmult
 		with
 			minmult := <get-min-mult> attType


/* get-attribute-min-mult: 
		Takes an attribute and returns its minimum multiplicity.
*/
 	
 	get-attribute-opposite:
 		Attribute(attName, decorations, attType)
 			-> opp
 		with
 			opp := <get-opposite> attType
 			
/* has-opposite: 
		Returns the attribute if it has an opposite.
*/
 	
 	has-opposite:
 		((name1, name2), (name3, name4))
 			-> ((name1, name2), (name3, name4))
 	


	attribute-is-id:
		Attribute(attName, identity, attType)
 			-> Attribute(attName, identity, attType)

		
 /* get-max-mult:
 		Takes a TypeDecl and returns its maximum multiplicity	
 
 */
 
	get-max-mult: 
		BasicType(t) -> 1
				
	get-max-mult:
		UniDirectional(name) -> 1
	
	get-max-mult:
		BiDirectional(name1,name2) -> 1
		
	get-max-mult:
		Optional(typedecl) -> 1
		
	get-max-mult:
		Set(typedecl, mult) -> x
	with x := <get-max> mult

 /* get-min-mult:
 		Takes a TypeDecl and returns its minimum multiplicity	
  */
 
	get-min-mult: 
		BasicType(t) -> 1
		
	get-min-mult:
		UniDirectional(name) -> 1
	
	get-min-mult:
		BiDirectional(name1,name2) -> 1
		
	get-min-mult:
		Optional(typedecl) -> 0
		
	get-min-mult:
		Set(typedecl, mult) -> x
	with x := <get-min> mult

 /* get-opposite:
 		Takes a TypeDecl and returns its opposite attribute	
  */
 
	get-opposite: 
		BasicType(t) -> ()
				
	get-opposite:
		UniDirectional(name) -> ()
	
	get-opposite:
		BiDirectional(name1,name2) -> (name1, name2)
		
	get-opposite:
		Optional(typedecl) -> x
	with x := <get-opposite> typedecl
		
	get-opposite:
		Set(typedecl, mult) -> x
	with x := <get-opposite> typedecl

