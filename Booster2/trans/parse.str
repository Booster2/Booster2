module parse

imports
  include/Booster2
  
  
rules
	
	
	/* parse: 
		Takes a system and produces a lookup table with all the information in it
	 parse : System
*/

	// Methods for retrieving different types of system components
	getClasses = filter(?Class(_,_,_))
	getSets = filter(?SetDef(_,_))
	
	// Methods for retrieving different types of class components
	getAttributes = <concat> <filter(\ Attributes(attrs) -> attrs \)>
	getMethods = <concat> <filter(\ Methods(meths) -> meths \)>
	getInvariants = <concat> <filter(\ Invariant(invs) -> invs \)>

	getClassComponents = \ Class(_, _, c) -> c \
	getClassName = \ Class(n, _, _) -> n \
	arrangeClassAttributes = \ Class(n, e, c) -> <cart(id)>([n], <getClassComponents; getAttributes> Class(n, e, c)) \
	arrangeClassMethods = \ Class(n, e, c) -> <cart(id)>([n], <getClassComponents; getMethods> Class(n, e, c)) \

	parse: 
   		System(name, components) -> 
   				System(name, components)
	with
   		<initialize-lookup-table> name;
   		sets := <map(organise-set)> <getSets> components;
   		classes := <getClasses> components;
   		classes' := <map(organise-class)> classes;
		attributes := <map(organise-attribute)><concat><map(arrangeClassAttributes)> classes;
		methods := <map(organise-method)><concat><map(arrangeClassMethods)> classes;

		rules(
			LookupTable :+ "Name" ->  name
			LookupTable :+ "SetDef" -> sets 
			LookupTable :+ "Class" ->  classes'
			LookupTable :+ "Attribute" ->  attributes
			LookupTable :+ "Method" ->  methods
		)
	    

	initialize-lookup-table: 
		x -> x 
		with 
			rules(
				LookupTable :+ "Name" -> []
				LookupTable :+ "SetDef" -> []
				LookupTable :+ "Class" -> []
				LookupTable :+ "Attribute" -> []
				LookupTable :+ "Method" -> []
			)

				
		
	organise-set:
		SetDef(name, elements) -> (name, elements)
	
	organise-class:
		Class(name, extends, classComponents)
			-> (name, (subclasses, attributes, methods, constraints, workflows))
		where
			subclasses := <\ None() -> [] \ <+ \ Some(Extend(es)) -> <map(\Extension(c) -> c \)> es \> extends;
			attributes := <map(\ Attribute(name, _,_) -> name \)><getAttributes> classComponents;			
			methods := <map(\ Method(name, _ ) -> name \)><getMethods> classComponents;	
			constraints := <getInvariants> classComponents;
			workflows := []/*;
		log(|Error(), (name, (extends, attributes, methods, constraints, workflows))) */
	
	
 	organise-attribute:
 		(cname, Attribute(attName, decorators, type))
 			-> ((cname, attName), (decorators, type', opposite, minmult, maxmult))
 		where
 			type' := <get-minimal-type> type;
 			opposite := <get-opposite> type;
 			minmult := <get-min-mult> type;
 			maxmult := <get-max-mult> type
 	organise-attribute:
 		something -> something
 		where
 			log(|Error(), something)
 			 

 	organise-method:
 		(className, Method(methName, constraint))
 			-> ((className, methName), (constraint, guardedCommand))
 		where
 			guardedCommand := ()
			
			

			
/* getSeq/ParWorfklows

*/
			
	get-class-wfs: 
		Class(name, extends,  classComponents)
			-> ((name,seqWfs),(name,parWfs))
		with
			allWfs := <get-class-wf_sections> Class(name, extends, classComponents);
			seqWfs := <filter(isSeqWf)> allWfs;
			parWfs := <filter(isParWf)> allWfs
	
	get-class-wf_sections:
 		Class(name, extends, classComponents)
 			-> meths
 		where
 			wfSections := <filter(isWorkflowSection)> classComponents;
 			meths := <foldr([], union)> wfSections

	isWorkflowSection:
		 Workflows(wfs) -> wfs
		 
	isSeqWf:
		SeqWf(n,expr) -> SeqWf(n,expr)  
		
	isParWf:
		ParWf(n,expr) -> ParWf(n,expr)  
	



		
 /* get-max-mult:
 		Takes a TypeDecl and returns its maximum multiplicity	
 
 */
 
	get-max-mult: 
		BasicType(t) -> 1
				
	get-max-mult:
		UniDirectional(name) -> 1
	
	get-max-mult:
		BiDirectional(name1,name2) -> 1
		
	get-max-mult:
		Optional(typedecl) -> 1
		
	get-max-mult:
		Set(typedecl, mult) -> x
	with x := <get-max> mult

 /* get-min-mult:
 		Takes a TypeDecl and returns its minimum multiplicity	
  */
 
	get-min-mult: 
		BasicType(t) -> 1
		
	get-min-mult:
		UniDirectional(name) -> 1
	
	get-min-mult:
		BiDirectional(name1,name2) -> 1
		
	get-min-mult:
		Optional(typedecl) -> 0
		
	get-min-mult:
		Set(typedecl, mult) -> x
	with x := <get-min> mult

 /* get-opposite:
 		Takes a TypeDecl and returns its opposite attribute	
  */
 
	get-opposite: 
		BasicType(t) -> ()
				
	get-opposite:
		UniDirectional(name) -> ()
	
	get-opposite:
		BiDirectional(name1,name2) -> (name1, name2)
		
	get-opposite:
		Optional(typedecl) -> x
	with x := <get-opposite> typedecl
		
	get-opposite:
		Set(typedecl, mult) -> x
	with x := <get-opposite> typedecl

/*	get-max:
		Gets the maximum of this multiplicity
	
*/ 

	get-max:
		MultMinAndMax(a,b) -> <string-to-int>b
		
		
	get-max:
		MultJustMax(a) -> <string-to-int>a
		
	get-max:
		MultJustMin(a) -> "*"
		
	get-max:
		MultSingle(a) -> <string-to-int>a
		
	get-max:
		MultAny() -> "*"
		
/*	get-min:
		Gets the minimum of this multiplicity
	
*/ 

	get-min:
		MultMinAndMax(a,b) -> <string-to-int>a
		
		
	get-min:
		MultJustMax(a) -> 0
		
	get-min:
		MultJustMin(a) -> <string-to-int>a
		
	get-min:
		MultSingle(a) -> <string-to-int>a
		
	get-min:
		MultAny() -> 0
		
		
		
/* get-minimal-type:
 		Takes a TypeDecl and returns its minimal type	
 
 */
 

	get-minimal-type:
		BasicType(t) -> BasicType(t)

		
	get-minimal-type:
		UniDirectional(name) -> Reference(name)
	
	get-minimal-type:
		BiDirectional(name1,name2) -> Reference(name1)
		
	get-minimal-type:
		Optional(typedecl) -> Optional(type)
	with
		type := <get-minimal-type> typedecl
		
	get-minimal-type:
		Set(typedecl, mult) -> Set(type)
	with
		type := <get-minimal-type> typedecl
