module precond

imports
  include/Booster2
  trans/calculateWFPrecond/misc
  trans/calculateWFPrecond/workflow
  //compile/main
  
  // TODO: Currently, we don't support prioritisation of guarded actions
  
rules
	
	calculatePrecond: system -> <topdown(try(calculateParPrecond))> system
	    
	calculateParPrecond: ParWf(name,xs) -> form
	where
		not(<lookup> (name, <PrecondLookupTable> "ParWorkflows_Precond"));
		wfs* := <lookup> (name,<PrecondLookupTable> "ParWorkflows");
	 	<pre> wfs*;
	 	form := <wf_lut>;
	 	par_wfs := <PrecondLookupTable> "ParWorkflows_Precond";
	 	newwfs := <conc>(par_wfs,[(name, form)]);
	 	rules(
	 		PrecondLookupTable :+ "ParWorkflows_Precond" -> newwfs
	 	)
	
	
	/* **************************************
	   main precondition function
	   ************************************** */
	
	// if the concurrent workflow "[wfs*]" is already defined in 
	// the lookup-table we finish
	pre: [wfs*] -> [wfs*]
	where <wf_lut> [wfs*]//; log(|Error(),"case1" ,[wfs*])
	
	// if all sequential workflows in the list have terminated, i.e., are
	// equal to SKIP each, we finished
    pre: [wfs*] -> [wfs*]
    where <list_all(skip_d)> [wfs*]//; log(|Error(),"case2" ,[wfs*])
    with rules( wf_lut :+ [wfs*] -> True())  
	
	// the normal case
	pre: [wfs*] -> [wfs*]
	where //log(|Error(),"case3.1" ,[wfs*]);
		   formset := <preIter> ([wfs*],0, <subti>(<length> wfs* , 1));
		   //log(|Error(),"case3.2" ,[wfs*]);
		   form := <AndFold> formset//;
		   //log(|Error(),"case3.3" ,[wfs*])
	with rules( wf_lut :+ [wfs*] -> form )
	
	
	/* **************************************
	   the iteration function -- actual program 
	   logic implemented here
	   ************************************** */
	   	
	// if i is greater then the list length, we are done
	preIter: ([wfs*],i,t) -> []
	where <gt> (i,t)
	
	// Skip at position i
	preIter: ([wfs*],i,t) -> formset
	where wi := <getPos> ([wfs*],i) ;
	       <skip_d> wi;
	       formset := <preIter>([wfs*],<addi>(i,1),t)
	
	// Wait at position i
	preIter: ([wfs*],i,t) -> formset
	where
		wi := <getPos> ([wfs*],i);
		<wait_d> wi;
		wi_from := <string-to-int>(<sel_from> wi);
		wi_to := <string-to-int>(<sel_to> wi);
		wi_sub := <sel_w1> wi;
		
		//log(|Error(),"check2" ,([wfs*],wi_to,i,t));
		wj := <getPos> ([wfs*],wi_to) ;
		
		//log(|Error(),"before if" ,wj);
		
		if <wait_d> wj;
		   //log(|Error(),"after wait_d check1" ,[wfs*]);
		   wj_from := <string-to-int>(<sel_from> wj);
		   wj_to := <string-to-int>(<sel_to> wj);
		   wj_sub := <sel_w1> wj;
		   <equal>(i,wi_from); 
		   <equal>(wi_from,wj_from);
		   <equal>(wi_to,wj_to)
		then par1 := <listUpdate>((<listUpdate>([wfs*],i,wi_sub)),wi_to,wj_sub);
			//log(|Error(),"par1" ,par1); 
		     <pre> par1;
		     p := <wf_lut> par1;
		     formset := [p] 
		else formset := <preIter> ([wfs*],<addi>(i,1),t) 
		end
	       
	// prefix at position i
	preIter: ([wfs*],i,t) -> formset
	where wi := <getPos> ([wfs*],i) ;
	       <prefix_d> wi;
	       gi1 := <sel_g1>(wi);
		   ai1 := <sel_a1>(wi);
		   wi1 := <sel_w1>(wi);
		   
		   par1 := <listUpdate> ([wfs*], i, wi1);
		   <pre> par1;
		   
		   loc_cond := And(<get> gi1,<wp> (ai1 , <wf_lut> par1));
		   formset_rest := <preIter> ([wfs*],<addi>(i,1),t);
		   formset := <conc> ([loc_cond], formset_rest)
		   
	// normal case
	preIter: ([wfs*],i,t) -> formset
	where  wi := <getPos>([wfs*],i);
	       gi1 := <sel_g1>(wi);
		   ai1 := <sel_a1>(wi);
		   wi1 := <sel_w1>(wi);
		   gi2 := <sel_g2>(wi);
		   ai2 := <sel_a2>(wi);
		   wi2 := <sel_w2>(wi);
		
		   par1 := <listUpdate> ([wfs*], i, wi1); 
		   par2 := <listUpdate> ([wfs*], i, wi2); 

           if not(<guard_false> gi1) then <pre> par1 end;
           if not(<guard_false> gi2) then <pre> par2 end;
           
           if <guard_false> gi1 ; <guard_false> gi2 then loc_cond := False() else 
           if <guard_false> gi1 then loc_cond := And ((<get> gi2) ,(<wp> (ai2 , <wf_lut> par2))) else 
           if <guard_false> gi2 then loc_cond := And ((<get> gi1) ,(<wp> (ai1 , <wf_lut> par1))) else
           	    loc_cond :=
           	    And (And(
           	      Implies(<get> gi1 , <wp> (ai1, <wf_lut> par1))
           	      ,	
           	      Implies(<get> gi2 , <wp> (ai2, <wf_lut> par2))
           	    )
           	    , Or( <get> gi1, <get> gi2)	 	
           	    )   
           end end end;
           
           formset_rest := <preIter> ([wfs*],<addi>(i,1),t);
           formset := <conc> ([loc_cond], formset_rest)
           
           
           
           
/*           
           run-program:
			((classname, methname), constraint)
				-> ((classname, methname), Guard(constraint7, program2))
			with
				program := <program> (classname, methname, constraint);
				[paths*] := <get-modified-paths>(program);
				constraint2a :=  <get-type-constraint> ([paths*], classname, methname, <new-environment>[]);
				constraint2b :=  <get-multiplicity-constraint> ([paths*], classname, methname, <new-environment>[]);
				constraint3 := <make-post-state> And(constraint2a, constraint2b) ;
				
				[atts*] := <get-modified-attributes>(program, classname, methname, <new-environment>[]);
				invs := <lookup-invariants>([atts*]);
				constraint4 := <make-post-state><conjoin-constraints>(invs);
				
				constraint5 := And(constraint4, constraint3);
				
				(constraint6, program2) := <calculate-wp>(program, constraint5, classname, methname);
				constraint7 := <make-old> constraint6
*/
           
           
           program_tmp : t -> t
           calculate-wp_tmp : t -> t
           
		   wp : (m,post) -> cond
		   where
		   	    programs := <LookupTable> "Programs";
		   	    log(|Error(),"Programs lut" ,programs); 
		   		classname := "C1"; // for testing
		   		methname := "add1"; // for testing
		   		program := <lookup> ((classname,methname),programs);
		   		log(|Error(),"program from lut" ,program);
		   		//cond := <calculate-wp> (program,post,classname,methname);
		   		//log(|Error(),"calculated condition",cond)
				cond := ("wp(", m , post ,")")
		
		// never used!! Just declared to prevent undefinedness error
		cheat : t -> t
		with rules (LookupTable :+ "" -> ""
		             calculate-wp :+ "" -> "")
	