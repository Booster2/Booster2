module compile

imports
  include/Booster2
  
  library/constraint

  library/abstractBoosterModel
  library/environment
  library/expression
  library/valueExpression
  library/basicTypes

rules

	compile:
		system -> system
	where
		<program-main> system
		
/* 	program:
		Applies run-program to the constraints in a model
*/

	program-main:
		system -> system
		with
			programs := <map(run-program)>(<LookupTable> "Constraints");
			rules(
				LookupTable :+ "Programs" -> programs
			)
			
		

/* 	run-program:
		Applies program to each constraint, with the abstract booster machine for reference
*/
			
	run-program:
			((classname, methname), constraint)
				-> ((classname, methname), Guard(constraint7, program2))
			with
				program := <program> (classname, methname, constraint);
				[paths*] := <get-modified-paths>(program);
				constraint2a :=  <get-type-constraint> ([paths*], classname, methname, <new-environment>[]);
				constraint2b :=  <get-multiplicity-constraint> ([paths*], classname, methname, <new-environment>[]);
				constraint3 := <make-post-state> And(constraint2a, constraint2b) ;
				
				[atts*] := <get-modified-attributes>(program, classname, methname, <new-environment>[]);
				invs := <lookup-invariants>([atts*]);
				constraint4 := <make-post-state><conjoin-constraints>(invs);
				
				constraint5 := And(constraint4, constraint3);
				
				(constraint6, program2) := <calculate-wp>(program, constraint5, classname, methname);
				constraint7 := <make-old> constraint6 
				
			
/*
*/
	calculate-wp:
		(Skip(), constraint, classname, methodname)
			-> (constraint, Skip())

	calculate-wp:
		(Assign(path, expression), constraint1, classname, methname)
			-> (And( constraint2, And(constraint3, constraint4)), Assign(path, expression))
		where 
			path1 := <make-post-state> path;
			constraint2 := <aliasing-substitute> (classname, methname, constraint1, path1, expression, <new-environment>[]);
			constraint3 := <is-defined> (classname, methname, expression, <new-environment>[]);
			constraint4 := <is-defined> (classname, methname, path, <new-environment>[])
			

	calculate-wp:
		(New(o, cl), constraint1, classname, methname)
			-> (And(constraint4, And(constraint3, constraint2)), New(o, cl))
		where 
			
			constraint2 := <aliasing-substitute> (classname, methname, constraint1, PathStart(cl, None()), BinOp(PathStart(cl, None()),Union(), Output(o)), <new-environment>[]);
			constraint3 := <is-defined> (classname, methname, BinOp(PathStart(cl, None()),Union(),Output(o)), <new-environment>[]);
			constraint4 := <is-defined> (classname, methname, PathStart(cl, None()), <new-environment>[])


	// Thomas: Why is the guard "constraint1" never used subsequently?			
	calculate-wp:
		(Guard(constraint1, program1), constraint2, classname, methname)
			-> (And(constraint4, constraint3), Guard(constraint1, program2))
		where
			log(|Error(),"wp prog w.r.t. prost condition:",(program1,"!!!",constraint2));
			(constraint3, program2) := <calculate-wp> (program1, constraint2, classname, methname);
			log(|Error(),"c3,p2",(constraint3,"!!!",program2));
			constraint4 := <is-defined>(classname, methname, constraint3, <new-environment>[]);
			log(|Error(),"c4",constraint4)
			
			
			
	calculate-wp:
		(Sequence(program1, program2), constraint1, classname, methname)
			-> (constraint3, Sequence(program4, program3))
		where
			(constraint2, program3) := <calculate-wp> (program2, constraint1, classname, methname);
			(constraint3, program4) := <calculate-wp> (program1, constraint2, classname, methname)

	calculate-wp:
		(Choice(program1, program2), constraint1, classname, methname)
			-> (Or(constraint2, constraint3), 
				Choice(Guard(constraint2, program3), 
					   Guard(constraint3, program4)))
				where
			(constraint2, program3) := <calculate-wp> (program1, constraint1, classname, methname);
			(constraint3, program4) := <calculate-wp> (program2, constraint1, classname, methname)

	calculate-wp:
		(Parallel(program1, program2), constraint1, classname, methname)
			-> (constraint3, Parallel(program3, program4))
		where
			(constraint2, program3) := <calculate-wp> (program2, constraint1, classname, methname);
			//<debug> ("constraint2", constraint2);
			(constraint3, program4) := <calculate-wp> (program1, constraint2, classname, methname)
			//<debug> ("constraint3", constraint3)
			


rules
/* get-modified-paths:
	Takes a program and returns all the paths that may be modified by it
*/
	get-modified-paths:
		Skip()
			-> []
			
	get-modified-paths:
		Assign(path, expression)
			-> [path]	

	get-modified-paths:
		New(name, class)
			-> []	


	get-modified-paths:
		Guard(constraint, program)
			-> <get-modified-paths> (program)
			
	get-modified-paths:
		Parallel(program1, program2)
			-> [paths1*, paths2*]
		where
			[paths1*] := <get-modified-paths> (program1);
			[paths2*] := <get-modified-paths> (program2)

	get-modified-paths:
		Choice(program1, program2)
			-> [paths1*, paths2*]
		where
			[paths1*] := <get-modified-paths> (program1);
			[paths2*] := <get-modified-paths> (program2)

	get-modified-paths:
		Sequence(program1, program2)
			-> [paths1*, paths2*]
		where
			[paths1*] := <get-modified-paths> (program1);
			[paths2*] := <get-modified-paths> (program2)

/* 	program:
		takes a constraint, in the context of a class, and a method name,
		and a model, and returns a candidate program to achieve 
		the constraint as a goal			
*/



	program:
		(classname, methodname, True())
			-> Skip()

	program:
		(classname, methodname, False())
			-> Guard(False(), Skip())

	program:
		(classname, methodname, And(constraint1, constraint2))
			-> Parallel(program1, program2)
		with
			program1 := <program> (classname, methodname, constraint1);
			program2 := <program> (classname, methodname, constraint2)

	program:
		(classname, methodname, Or(constraint1, constraint2))
			-> Choice(program1, program2)
		with
			program1 := <program> (classname, methodname, constraint1);
			program2 := <program> (classname, methodname, constraint2)

	program:
		(classname, methodname, Then(constraint1, constraint2))
			-> Sequence(program1, program2)
		with
			program1 := <program> (classname, methodname, constraint1);
			program2 := <program> (classname, methodname, constraint2)

	program:
		(classname, methodname, Implies(constraint1, constraint2))
			-> Choice(Guard(constraint1,program1), Guard(Not(constraint1),Skip()))
		with
			program1 := <program> (classname, methodname, constraint1)

	program:
		(classname, methodname, Not(constraint1))
			-> Guard(Not(constraint1),Skip())



/*	TODO:
		These are incomplete
*/
	program:
		(classname, methodname, Exists(name, expr, constraint))
			-> Any(name, expr, program)
		with
			program := <program> (classname, methodname, constraint)
		
	program:
		(classname, methodname, Forall(name, expr, constraint))
			-> All(name, expr, program)
		with
			program := <program> (classname, methodname, constraint)
		
	program:
		(classname1, methodname1, MethodReference(path, substs*))
			-> program
		with
			(classname2, methodname2, constraint) := 
				<get-method-ref-constraint> (classname1, methodname1, MethodReference(path, [substs*]));
			program := <program> (classname2, methodname2, constraint)
			
/* 	get-method-ref-constraint:
		takes a class name, a method name, a method reference, and an abm,
		and returns the constraint corresponding to that reference.			
*/

/* 	TODO:
		This method is incomplete
*/
	

	get-method-ref-constraint:
		(classname, methodname, MethodReference(path, [substs*]))
			-> True()


/* 	program:
		takes a relation, in the context of a class, and a method name,
		and a model, and returns a candidate program to achieve 
		the constraint as a goal			
*/


	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Assign(path1, expression)
		where
			path1 := <make-old> Path(a,b);
			False() := <is-old> Path(a,b) ;
			BasicType(t) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []) 

	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Assign(path1, expression)
		where
			path1 := <make-old> Path(a,b);
			False() := <is-old> Path(a,b) ;
			Optional(BasicType(t)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []) 

	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Assign(path1, expression)
		where
			path1 := <make-old> Path(a,b);
			False() := <is-old> Path(a,b) ;
			Set(BasicType(t)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []) 


	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Assign(path1, expression)
		where
			path1 := <make-old> Path(a,b);
			False() := <is-old> Path(a,b) ;
			Reference(name) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name2 := <lookup-set-name> name;
			<equal>(name, name2) 

	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Assign(path1, expression)
		where
			path1 := <make-old> Path(a,b);
			False() := <is-old> Path(a,b) ;
			Optional(Reference(name)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name2 := <lookup-set-name> name;
			<equal>(name, name2) 
			
			
	program:
		(classname, methodname, BinRel(Output(o), In(), PathStart(cl,Some(Primed()))))
			-> New(Output(o), cl) 
		where
			/*log(|Warning(), "Matching new"); */
			path1 := <make-old> PathStart(cl,Some(Primed()));
			False() := <is-old> PathStart(cl,Some(Primed())) ;
			Set(Reference(cl)) := <resolve-path-type> (classname, PathStart(cl,Some(Primed())), (classname, methodname), <new-environment> [])  


			

 
 /* Optional-to-Mandatory */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), Null()))
			-> Parallel(Assign(path3, Null()),
						Guard(BinRel(path3, NotEqual(), Null()),
							  Assign(name2,
							  		 BinOp(name2, Minus(),
							  		 	   SetExtent([path3])))))
		where
			Optional(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name> (name2);
			<equal>(name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Reference(name5) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))

 /* Optional-to-Optional */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), Null()))
			-> Parallel(Assign(path3, Null()),
						Guard(BinRel(path3, NotEqual(), Null()),
							  Assign(Path(path3, PathComponent(name6, None())),
							  		 Null())))
		where
			Optional(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name> (name2);
			<equal>(name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Optional(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))
	
 /* Optional-to-Set-valued */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), Null()))
			-> Parallel(Assign(path3, Null()),
						Guard(BinRel(path3, NotEqual(), Null()),
							  Assign(Path(Path(path3, 
							  		 			PathComponent(name6, None()))),
							  		 BinOp(Path(path3, 
							  		 			PathComponent(name6, None())), Minus(),  
							  		 	   SetExtent([path1])))))
		where
			Optional(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name> (name2);
			<equal>(name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Set(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))		

 /* Set-valued-to-Mandatory */
	program:			
		(classname, methodname, BinRel(expression, NotIn(), Path(a,b)))
			-> Parallel(Assign(path3, BinOp(path3, Minus(), SetExtent([expression]))),
					    Assign(PathStart(name2, None()),
					    	   BinOp(PathStart(name2, None()), Minus(), 
					    	   		 SetExtent([path3]))))
		where
			Set(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name> (name2);
			<equal>(name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Reference(name5) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))
			
 /* Set-valued-to-Optional */
	program:			
		(classname, methodname, BinRel(expression, NotIn(), Path(a,b)))
			-> Parallel(Assign(path3,
							   BinOp(path3, Minus(), SetExtent([expression]))),
						Assign(Path(expression, PathComponent(name6, None())),
							   Null()))
		where
			Set(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name> (name2);
			<equal> (name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Optional(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))
			

 /* Set-valued-to-Set-valued */
	program:			
		(classname, methodname, BinRel(expression, NotIn(), Path(a,b)))
			-> Parallel(Assign(path3,
							   BinOp(path3, Minus(), SetExtent([expression]))),
						Assign(Path(expression, PathComponent(name6, None())),
							   BinOp(Path(expression, PathComponent(name6, None())), Minus(),  
							   		 SetExtent([path1]))))
		where
			Set(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name> (name2);
			<equal> (name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Set(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))

/* Mandatory-to-Mandatory */
	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Guard(BinRel(expression, NotIn(), name2), 
				Parallel(Assign(path3, expression), 
						 Assign(Path(expression,PathComponent(name6, None())),path1)))
		where
			Reference(name2) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal> (name, name2);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type>(classname, path1, (classname, methodname), <new-environment> [] );
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Reference(name5) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b)) ;
			False() := <is-old> (Path(a,b))
			
/* Mandatory-to-Optional */
	program:
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Parallel(Parallel(Assign(path3, expression),
								 Assign(Path(expression, name6), path1)),
						Assign(Path(path3, PathComponent(name6, None())), Null()) )
		where
			Reference(name2) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal> (name, name2);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type>(classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Optional(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal> (name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))
			
/* Mandatory-to-Set-valued */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Parallel(Parallel(Assign(path3, expression),
								 Assign(Path(Path(path1, PathComponent(name3, None())), 
								 			 PathComponent(name6, None())),
								 		BinOp(Path(Path(path1, PathComponent(name3, None())),  
								 	    	  	PathComponent(name6, None())), Minus(), 
								 	    	  SetExtent([path1])))),
						Assign(Path(expression, PathComponent(name6, None())), 
							   BinOp(Path(expression, PathComponent(name6, None())), Union(),
							   		 SetExtent([path1]))))
								 
		where
			Reference(name2) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal> (name, name2);
			name3 := <get-path-attribute-name>(Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Set(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))

/* Optional-to-mandatory */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Guard(BinRel(path3, NotEqual(), name2),
					 Parallel(Parallel(Assign(path3, expression),
					 		  		   Choice(Guard(And(BinRel(path3, NotEqual(), Null()),
					 		  			                BinRel(path3, NotEqual(), expression)),
					 		  				        Assign(name2, BinOp(name2, Minus(), 
					 		  							  		        SetExtent([Path(path1, 
					 		  											                PathComponent(name3, None()))])))),
					 		  			      Guard(Or(BinRel(path3, Equal(), Null()),
					 		  			      		   BinRel(path3, Equal(), expression)),
					 		  			      		Skip()))),
					 		  Assign(Path(expression, PathComponent(name6, None())),
					 		  	     path1)))
		where
			Optional(Reference(name2)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal>(name, name2);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path>(Path(a,b));	
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Reference(name5) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old>(Path(a,b));
			False() := <is-old> (Path(a,b))
			
/* Optional-to-optional */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> Parallel(Parallel(Assign(path3, expression),
								 Choice(Guard(And(BinRel(path3, NotEqual(), Null()),
								 				  BinRel(path3, NotEqual(), expression)),
								 			  Assign(Path(Path(path1, PathComponent(name3, None())),
								 			  			  PathComponent(name6, None())),
								 			  		 Null())),
								 		Guard(Or(BinRel(path3, Equal(), Null()),
								 				 BinRel(path3, Equal(), expression)),
								 			  Skip()))),
						Parallel(Choice(Guard(And(BinRel(Path(expression, PathComponent(name6, None())),
														   NotEqual(), Null()),
												  BinRel(Path(expression, PathComponent(name6, None())),
														   NotEqual(), path1)),
											  Assign(Path(Path(expression, PathComponent(name6, None())),
											  			  PathComponent(name3, None())),
											  		 Null())),
										Guard(Or(BinRel(Path(expression, PathComponent(name6, None())),
													   Equal(), Null()),
												 BinRel(Path(expression, PathComponent(name6, None())),
													   Equal(), path1)),
											  Skip())),
								 Assign(Path(expression, PathComponent(name6, None())),
								 		path1)))
		where
			Optional(Reference(name2)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal>(name, name2);
			name3 := <get-path-attribute-name>(Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite>((name4, name3));
			Optional(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b)) 	
	
/* Optional-to-Set-valued */
	program:			
		(classname, methodname, BinRel(Path(a,b), Equal(), expression))
			-> 	Parallel(
			  		Parallel(
			  			Assign(path3, expression),
						Choice(
							Guard(
								And(
									BinRel(path3, NotEqual(), Null()),
								 	BinRel(path3, NotEqual(), expression)),
								Assign(
									Path(
										Path(path1, PathComponent(name3,None())), 
								 		PathComponent(name6, None())),
								 	BinOp(
								 		Path(
								 			Path(path1, PathComponent(name3,None())), 
								 			PathComponent(name6, None())), Minus(), 
								 	SetExtent([path1])))),
							Guard(
								Or(
									BinRel(path3, Equal(), Null()),
								 	BinRel(path3, Equal(), expression)),
					  		    Skip()))),
					Assign(
						Path(expression, PathComponent(name6, None())),
						BinOp(
							Path(expression, PathComponent(name6, None())), Union(), 
							SetExtent([path1]))))
			
		where
			Optional(Reference(name2)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal>(name, name2);
			name3 := <get-path-attribute-name>(Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Set(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))

		
/* Set-valued-to-Mandatory */
	program:			
		(classname, methodname, BinRel(expression, In(), Path(a,b)))
			-> (Guard(
					BinRel(expression, NotIn(), path3), 
					Parallel(
							Parallel(
									Assign(
										path3,
							  			BinOp(path3, Union(), SetExtent([expression]))), 
									Assign(
										Path(expression, PathComponent(name6, None())),
							   			path1)),
							Assign(Path(Path(expression, PathComponent(name6, None())),
								 	   			   PathComponent(name3, None())),
								 	   		  BinOp(Path(Path(expression, PathComponent(name6, None())),
								 	   			   	     PathComponent(name3, None())), Minus(), 
								 	   			   	SetExtent([expression]))))))
		where
			Set(Reference(name2)) := <resolve-path-type> (classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal>(name, name2);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Reference(name5) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))

/* Set-valued-to-Optional */
	program:			
		(classname, methodname, BinRel(expression, In(), Path(a,b)))
			-> Parallel(Parallel(Assign(path3,
										BinOp(path3, Union(), SetExtent([expression]))),
								 Guard(BinRel(Path(expression, 
								 					 PathComponent(name6, None())),
								 				NotEqual(), Null()),
								 	   Assign(Path(Path(expression, PathComponent(name6, None())),
								 	   			   PathComponent(name3, None())),
								 	   		  BinOp(Path(Path(expression, PathComponent(name6, None())),
								 	   			   	     PathComponent(name3, None())),
								 	   			   	Minus(), 
								 	   			   	SetExtent([Path(expression, PathComponent(name6, None()))]))))),
						Assign(Path(expression, PathComponent(name6, None())),
							   path1))
		where
			Set(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal>(name, name2);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Optional(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))
		
/* Set-valued-to-Set-valued */
	program:			
		(classname, methodname, BinRel(expression, In(), Path(a,b)))
			-> Parallel(Assign(path3,
							   BinOp(path3, Union(), 
							   		 SetExtent([expression]))),
						Assign(Path(expression, PathComponent(name6, None())),
							   BinOp(Path(expression, PathComponent(name6, None())), Union(), 
							   		 SetExtent([path1]))))
		where
			Set(Reference(name2)) := <resolve-path-type>(classname, Path(a,b), (classname, methodname), <new-environment> []);
			name := <lookup-class-name>(name2);
			<equal>(name2, name);
			name3 := <get-path-attribute-name> (Path(a,b));
			path1 := <get-path-initial-path> (Path(a,b));
			Reference(name4) := <resolve-path-type> (classname, path1, (classname, methodname), <new-environment> []);
			(name2, name6) := <lookup-opposite> ((name4, name3));
			Set(Reference(name5)) := <lookup-attribute-type> ((name2, name6));
			<equal>(name4, name5);
			path3 := <make-old> (Path(a,b));
			False() := <is-old> (Path(a,b))

					
/* Default */

	program:
		(classname, methodname, relation1)
			-> Guard(relation2, Skip())
		where
			relation2 := <make-old> (relation1);
			log(|Warning(), "cannot determine program", relation1)

			
			


/* 	make-old:
		takes a relation, and returns its representation in the 
		pre-state of a method 			
*/

	make-old:
		BinRel(expr1, binrel, expr2)
			-> BinRel(expr3, binrel, expr4)
		where
			expr3 := <make-old> expr1;
			expr4 := <make-old> expr2



	