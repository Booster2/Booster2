module compile/constraint

imports
  include/Booster2
  
   compile/relation
   compile/expression
   compile/valueExpression
 
 rules
 	
 	
		
/* 	program:
		takes a constraint, in the context of a class, and a method name,
		and a model, and returns a candidate program to achieve 
		the constraint as a goal			
*/



	program:
		(classname, methodname, True())
			-> Skip()

	program:
		(classname, methodname, False())
			-> Guard(False(), Skip())

	program:
		(classname, methodname, And(constraint1, constraint2))
			-> Parallel(program1, program2)
		with
			program1 := <program> (classname, methodname, constraint1);
			program2 := <program> (classname, methodname, constraint2)

	program:
		(classname, methodname, Or(constraint1, constraint2))
			-> Choice(program1, program2)
		with
			program1 := <program> (classname, methodname, constraint1);
			program2 := <program> (classname, methodname, constraint2)

	program:
		(classname, methodname, Then(constraint1, constraint2))
			-> Sequence(program1, program2)
		with
			program1 := <program> (classname, methodname, constraint1);
			program2 := <program> (classname, methodname, constraint2)

	program:
		(classname, methodname, Implies(constraint1, constraint2))
			-> Choice(Guard(constraint1,program1), Guard(Not(constraint1),Skip()))
		with
			program1 := <program> (classname, methodname, constraint1)

	program:
		(classname, methodname, Not(constraint1))
			-> Guard(Not(constraint1),Skip())



/*	TODO:
		These are incomplete
*/
	program:
		(classname, methodname, Exists(name, expr, constraint))
			-> Any(name, expr, program)
		with
			program := <program> (classname, methodname, constraint)
		
	program:
		(classname, methodname, Forall(name, expr, constraint))
			-> All(name, expr, program)
		with
			program := <program> (classname, methodname, constraint)
		
	program:
		(classname1, methodname1, MethodReference(path, substs*))
			-> program
		with
			(classname2, methodname2, constraint) := 
				<get-method-ref-constraint> (classname1, methodname1, MethodReference(path, [substs*]));
			program := <program> (classname2, methodname2, constraint)
			
/* 	get-method-ref-constraint:
		takes a class name, a method name, a method reference, and an abm,
		and returns the constraint corresponding to that reference.			
*/

/* 	TODO:
		This method is incomplete
*/
	

	get-method-ref-constraint:
		(classname, methodname, MethodReference(path, [substs*]))
			-> True()

	