module wp

imports
  include/Booster2
  
  elaborate
  library/strategy
  
  library/lookupTable
  
  library/constraint
  // Get rid of these if we can...

  library/basicTypes
  library/environment
  library/expression
  library/valueExpression
  
  // these are here for pretty-printing debug output.
  // remove for production version!
  translate/booster/booster
  translate/helpers

rules

/* get-modified-paths:
	Takes a program and returns all the paths that may be modified by it
*/
	get-modified-paths = collect(\ Assign(path, expression) -> path \)
	
/* get-modified-attributes:
	Takes a program and returns all the attributes that may be modified by it
*/
	get-modified-attributes = collect(\ Assign(path, expression) -> <get-path-attribute> path \)

/* conjoin-constraints:
	Takes a list of constraints and returns their conjunction.
	foldr1 isn't documented - it's like a foldr1 from Haskell
	First argument is a function to deal with the singleton list
	Second argument joins two elements
	foldr1 fails on the empty list - provide an exception case.
*/
	conjoin-constraints = foldr1((\ [x] -> x\),(\ (x,y) -> And(x,y) \)) <+ !True()	 	


	get-mentioned-paths = collect( 	?Path(p, pc) <+ 
									?This() <+ 
									?ThisPrimed() <+
									?Input(i) <+
									?Output(o))


wp:
	system -> system
where
	<map(\ ((cname, mname), (constraint, gc, exts, done, inputs, outputs)) -> <wp-each> (cname, mname, constraint, gc) \) >(<LookupTable> "Method")
						
		

/* 	compile-each:
		Generates a program for each constraint, calculates the invariants and performs the WP. 
*/
			
	wp-each:
			(classname, methname, constraint, program)
				-> (classname, methname, constraint, Guard(constraint7, program2)) 
				
			with
				paths := <get-modified-paths> program;
				//log(|Error(), "modified paths", <foldout(expression)> (paths, ","));
				typeConstraint :=  <make-post-state><conjoin-constraints><map(get-type-constraint)> paths;
				//log(|Error(), "type constraint", <constraint> typeConstraint);
				multiplicityConstraint :=  <make-post-state><conjoin-constraints><filter(get-multiplicity-constraint)> paths;
				//log(|Error(), "multiplicity constraint", <constraint> multiplicityConstraint);
				
				classInvariant := <make-post-state><conjoin-constraints> <filter( id )> <get-class-invariants> classname;
				//log(|Error(), "classInvariant", classInvariant);
				invariant := <conjoin-constraints>[classInvariant, typeConstraint, multiplicityConstraint];
				(constraint6, program2) := <calculate-wp>(program, And(invariant, constraint), classname, methname);
				//log(|Error(), "weakest precondition", <constraint> constraint6);
				//log(|Error(), "program 2", <guardedCommand> program2);
				
				constraint7 := <make-pre-state> constraint6; 
				//log(|Error(), "weakest precondition", <constraint> constraint6);
				<updateMethodProgram> (classname, methname, Guard(constraint7, program2))
			


	calculate-wp:
		(Skip(), constraint, classname, methodname)
			-> (constraint, Skip())

	calculate-wp:
		(Assign(path, expression), constraint1, classname, methname)
			-> (And( constraint2, And(constraint3, constraint4)), Assign(path, expression))
		where 
			// log(|Error(), "wp constraint", <constraint> constraint1);
			path1 := <make-post-state> path;
			constraint2 := <aliasing-substitute> (classname, methname, constraint1, path1, expression, <new-environment>[]);
			// log(|Error(), "wp aliasing substitute result", constraint2);
			constraint3 := <is-defined> (classname, methname, expression, <new-environment>[]);
			constraint4 := <is-defined> (classname, methname, path, <new-environment>[])
			

	calculate-wp:
		(New(o, cl), constraint1, classname, methname)
			-> (And(constraint4, And(constraint3, constraint2)), New(o, cl))
		where 
			
			constraint2 := <aliasing-substitute> (classname, methname, constraint1, PathStart(cl, None()), BinOp(PathStart(cl, None()),Union(), Output(o)), <new-environment>[]);
			constraint3 := <is-defined> (classname, methname, BinOp(PathStart(cl, None()),Union(),Output(o)), <new-environment>[]);
			constraint4 := <is-defined> (classname, methname, PathStart(cl, None()), <new-environment>[])


	// Thomas: Why is the guard "constraint1" never used subsequently?
	// James: Good question!
		
	calculate-wp:
		(Guard(constraint1, program1), constraint2, classname, methname)
			-> (And(constraint4, constraint3), Guard(constraint1, program2))
		where
			// log(|Error(),"wp prog w.r.t. prost condition:",(program1,"!!!",constraint2));
			(constraint3, program2) := <calculate-wp> (program1, constraint2, classname, methname);
			//log(|Error(),"c3,p2",(constraint3,"!!!",program2));
			constraint4 := <is-defined>(classname, methname, constraint3, <new-environment>[]) /*;
			log(|Error(),"c4",constraint4) */
			
			
			
	calculate-wp:
		(Sequence(program1, program2), constraint1, classname, methname)
			-> (constraint3, Sequence(program4, program3))
		where
			(constraint2, program3) := <calculate-wp> (program2, constraint1, classname, methname);
			(constraint3, program4) := <calculate-wp> (program1, constraint2, classname, methname)

	calculate-wp:
		(Choice(program1, program2), constraint1, classname, methname)
			-> (Or(constraint2, constraint3), 
				Choice(Guard(constraint2, program3), 
					   Guard(constraint3, program4)))
				where
			(constraint2, program3) := <calculate-wp> (program1, constraint1, classname, methname);
			(constraint3, program4) := <calculate-wp> (program2, constraint1, classname, methname)

	calculate-wp:
		(Parallel(program1, program2), constraint1, classname, methname)
			-> (constraint3, Parallel(program3, program4))
		where
			(constraint2, program3) := <calculate-wp> (program2, constraint1, classname, methname);
			//<debug> ("constraint2", constraint2);
			(constraint3, program4) := <calculate-wp> (program1, constraint2, classname, methname)
			//<debug> ("constraint3", constraint3)
			

			
			


/* 	make-pre-state:
		takes a constraint, and returns its representation in the 
		pre-state of a method 			
*/

	make-pre-state:
		constraint ->
			<bottomup(try( (\ PathComponent(name, Some(Primed())) -> PathComponent(name, None()) \) <+
						   (\ PathStart(name, Some(Primed())) {t} -> PathStart(name, None()) {t} \) <+
						   (\ ThisPrimed() {t} -> This() {t} \)  
						   		))> constraint 	

/* 	make-post-state:
		takes a constraint, and returns its representation in the 
		post-state of a method 			
*/

	make-post-state:
		constraint ->
			<bottomup(try( (\ PathComponent(name, None()) {type} -> PathComponent(name, Some(Primed())) {type}  \) <+
						   (\ PathComponent(name, None()) -> PathComponent(name, Some(Primed())) \) <+
						   (\ PathStart(name, None()) {type}  -> PathStart(name, Some(Primed())) {type}  \) <+
						   (\ This() {type}  -> ThisPrimed() {type}  \)  
						   		))> constraint 	

/*	is-pre-state
		takes a constraint, and returns if can be entirely evaluated in the pre-state.  Ie. there are no primes 
*/
	is-pre-state:
		constraint ->
			<equal>([], <collect(?PathComponent(name, Some(Primed())) <+ 
								?PathStart(name, Some(Primed())) <+
								?ThisPrimed() <+
								?Output(s))> constraint)
			 

			

	get-multiplicity-constraint:
		path 
			-> constraint
		where
			att := <get-path-attribute> path;
			Set(s) := <lookup-attribute-type> att;
			constraint := <get-mult-constraint>(path, att)


	get-mult-constraint:
		(path, att)
			-> BinRel(UnOp(Cardinality(),path), GreaterThanEquals(), BasicValue(Integer(min)))
		where
			"*" := <lookup-max-mult> att ;
			min := <lookup-min-mult> att

	get-mult-constraint:
		(path, att)
			-> And(BinRel(UnOp(Cardinality(),path), LessThanEquals(), BasicValue(Integer(max))), BinRel(UnOp(Cardinality(),path), GreaterThanEquals(), BasicValue(Integer(min))))
		where
			max := <lookup-max-mult> att;
			min := <lookup-min-mult> att

/* 	substitute:
		takes a constraint, and replaces all instances of the path with the given expression
*/			
	aliasing-substitute:
		 (classname, methodname, True(), path, expression, env)
		 	-> True()		

	aliasing-substitute:
		 (classname, methodname, False(), path, expression, env)
		 	-> False()
		 	
	aliasing-substitute:
		 (classname, methodname, Not(constraint), path, expression, env)
		 	-> Not(constraint2)
		 where
		 	constraint2 := <aliasing-substitute>	(classname, methodname, constraint, path, expression, env)
		 	
	aliasing-substitute:
		 (classname, methodname, And(constraint1, constraint2), path, expression, env)
		 	-> And(constraint3, constraint4)
		 where
		 	/*log(|Error(), <substitute>	(constraint1, path, expression), <substitute>	(constraint2, path, expression));*/
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)
	
	aliasing-substitute:
		 (classname, methodname, Or(constraint1, constraint2), path, expression, env)
		 	-> Or(constraint3, constraint4)
		 where
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)
	
	aliasing-substitute:
		 (classname, methodname, Implies(constraint1, constraint2), path, expression, env)
		 	-> Implies(constraint3, constraint4)
		 where
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)
	
	aliasing-substitute:
		 (classname, methodname, Then(constraint1, constraint2), path, expression, env)
		 	-> Then(constraint3, constraint4)
		 where
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)

	aliasing-substitute:
		 (classname, methodname, Exists(name, expr1 { Set(type1) }, constraint1), Path(ps { type1 }, pc), expression, env)
		 	-> And(
		 		Exists(name, expr1, 
		 			Implies(
			 				BinRel(
			 					PathStart(name, None()),
			 					Equal(),
			 					ps),
			 					constraint3)),
	 			Exists(name, expr1, 
	 				Implies(
	 					BinRel(
		 					PathStart(name, None()),
		 					NotEqual(),
		 					ps),
		 					constraint1)))
		 where
		 	//log(|Error(), "Aliasing Substitute", (Forall(name, expr1, constraint1), Path(ps, pc), expression));
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(constraint1, [PathStart(name, Some(Primed())), ps]);
			//log(|Error(), "Constraint3", (constraint2, [Path(ps, pc)], expression));
			constraint3 := <aliasing-substitute>	(classname, methodname, constraint2, Path(ps, pc), expression, env')
		 	

	aliasing-substitute:
		 (classname, methodname, Exists(name, expr1, constraint1), path, expression, env)
		 	-> Exists(name, expr2, constraint2)
		 where
		 	expr2 := <literal-substitute>	(expr1, [path, expression]);
		 	env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env')

	aliasing-substitute:
		 (classname, methodname, Forall(name, expr1 {Set(type1)}, constraint1), Path(ps { type1 }, pc), expression, env)
		 	-> And(
		 		Forall(name, expr1, 
		 			Implies(
			 				BinRel(
			 					PathStart(name, None()),
			 					Equal(),
			 					ps),
			 					constraint3)),
	 			Forall(name, expr1, 
	 				Implies(
	 					BinRel(
		 					PathStart(name, None()),
		 					NotEqual(),
		 					ps),
		 					constraint1)))
		 where
		 	//log(|Error(), "Aliasing Substitute", (Forall(name, expr1, constraint1), Path(ps, pc), expression));
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(constraint1, [PathStart(name, Some(Primed())), ps]);
			//log(|Error(), "Constraint3", (constraint2, [Path(ps, pc)], expression));
			constraint3 := <aliasing-substitute>	(classname, methodname, constraint2, Path(ps, pc), expression, env')
		 	

	aliasing-substitute:
		 (classname, methodname, Forall(name, expr1, constraint1), path, expression, env)
		 	-> Forall(name, expr2, constraint2)
		 where
		 	expr2 := <literal-substitute>	(expr1, [path, expression]);
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env')
				
	aliasing-substitute:
		 (classname, methodname, BinRel(expression1, binrel, expression2), path, expression, env)
		 	-> constraint
		 where
		 	//log(|Error(), "Aliasing Subst - classname, methodname:", (classname, methodname));
		 	//log(|Error(), "Aliasing Subst - binrel", (BinRel(expression1, binrel, expression2)));
		 	//log(|Error(), "Aliasing Subst - path", path);
		 	//log(|Error(), "Aliasing Subst - expression", expression);
		 	paths1 := <get-mentioned-paths> expression1;
		 	//log(|Error(), "Aliasing Subst - paths1", paths1);
		 	paths2 := <get-mentioned-paths> expression2;
		 	//log(|Error(), "Aliasing Subst - paths2", paths2);
		 	paths := <union>(paths1, paths2);
		 	//log(|Error(), "Aliasing Subst - paths", paths);
		 	pathstart {type}:= <(\Path(ps, pc) -> ps\) <+ (\ PathStart(ps, maybeprimed) {type} -> PathStart(ps, maybeprimed) {type} \)> path;
		 	//log(|Error(), "Aliasing Subst - type", type);
		 	filtered-paths := <filter((\p -> (type, p) \) ; is-correct-type)> paths;
		 	//log(|Error(), "Aliasing Subst - filtered paths", filtered-paths);
		 	subsets := <subsets> filtered-paths;
		 	//log(|Error(), "Aliasing Subst - subset",subsets);
		 	constraint := <conjoin-constraints><currymap(generate-aliasing-constraint)> ((classname, methodname, BinRel(expression1, binrel, expression2), path, expression, env, filtered-paths), subsets)/*; 
			log(|Error(), "Aliasing Subst - constraint", constraint) */
	
/*	aliasing-substitute:
		something -> True()
			where log(|Error(), "aliasing substitute fail", something)
*/	
	generate-aliasing-constraint:
		((classname, methodname, BinRel(expression1, binrel, expression2), path, expression, env,all-paths), paths)
			-> Implies(And(ant1,ant2), con2)
		where
			pathstart {type}:= <(\Path(ps, pc) -> ps\) <+ (\ PathStart(ps, maybeprimed) {type} -> PathStart(ps, maybeprimed) {type} \)> path;
			ant1 := <conjoin-constraints><currymap(\ (p1, p2) -> BinRel(p1, Equal(), p2)\)>(pathstart {type}, paths);
			paths2 := <diff>(all-paths, paths); 
			ant2 := <conjoin-constraints><currymap(\ (p1, p2) -> BinRel(p1, NotEqual(), p2)\)>(pathstart {type}, paths2);
			//log(|Error(), "Something", (paths, ps));
			substs := <map(\p -> (p, pathstart {type})\)> paths;
	
			con := <literal-substitute> (BinRel(expression1, binrel, expression2), substs);
			/* log(|Error(), "con", <constraint> con); */
			con2 := <literal-substitute> (con, [(path, expression)]) /*;
			log(|Error(), "con2", con2)  */



	is-correct-type:
		(type, Path(pstart {type}, pc))
			-> pstart

	is-correct-type:
		(type, Path(pstart {Optional(type)}, pc))
			-> pstart

	is-correct-type:
		(Optional(type), Path(pstart {type}, pc))
			-> pstart 

	