module check

imports
  include/Booster2
  library/strategy


rules
  // Analysis: does a topdown traversal of the tree,
  // and tries to apply the record-entity rule.
  analyze:
    t -> t
    with
      <build-lookup-table> t
      /*;
      <topdown(try(record-class))> t;
      <topdown(try(record-setdef))> t;
      <topdown(try(record-setvalue))> t */

  build-lookup-table:
  	(System(name, [cs*]),filename, dir) -> (System(name, [cs*]),filename, dir)
  		with
  			<map(build-lookup-table)> [cs*]
  
  build-lookup-table:
  	SetDef(name, [vs*]) -> SetDef(name, [vs*])
  		with
  		rules(
  			SetDefs :+ name -> name
  		);
  		<currymap(build-lookup-table-setvalue)> (name, [vs*])    

  build-lookup-table:
  	Class(name, extends, [cs*]) -> Class(name, extends, [cs*])
  		with
  		rules(
  			Classes :+ name -> name
  		);
  		<currymap(build-lookup-table-class-component)> (name, [cs*])    

  build-lookup-table:
  	Class(name, extends, [cs*]) -> Class(name, extends, [cs*])
  		with
  		rules(
  			Classes :+ name -> name
  		);
  		<currymap(build-lookup-table-class-component)> (name, [cs*])    
  	
  /*build-lookup-table:
  	x -> x
  		with
  		log(|Error(), "build-lookup-table", x ) */

	build-lookup-table-setvalue:
		(name, value) -> (name, value)
		with
			rules(
				SetDefValues :+ (name, value) -> (name, value)
			);
			rules(
				SetValues :+ value -> value
			)
			
	build-lookup-table-class-component:
		(name, Attributes([as*])) -> 
			<currymap(build-lookup-table-class-component)> (name, [as*])

	build-lookup-table-class-component:
		(name, Methods([ms*])) -> 
			<currymap(build-lookup-table-class-component)> (name, [ms*])

	build-lookup-table-class-component:
		(name, Invariant([is*])) -> 
			<currymap(build-lookup-table-class-component)> (name, [is*])

    // Workflow Stuff Begin
    build-lookup-table-class-component:
    	(name, Workflows([ws*])) -> 
    	    <currymap(build-lookup-table-class-component)> (name,[ws*])
    	    
    build-lookup-table-class-component:
    	(cname, SeqWf(name,exp)) -> (cname, SeqWf(name,exp))
    	with
    		rules(
    			SeqWfs :+ (cname,name) -> (cname,name)
    		)
    build-lookup-table-class-component:
    	(cname, ParWf(name,exp)) -> (cname, ParWf(name,exp))
    	with
    		rules(
    			ParWfs :+ (cname,name) -> (cname,name)
    		)		
    // Workflow Stuff End

	build-lookup-table-class-component:
		(cname, Attribute(aname, decorations, type)) -> (cname, Attribute(aname, decorations, type)) 
		with
			rules(
				Attributes :+ (cname, aname) -> (cname, aname)
			)

	build-lookup-table-class-component:
		(cname, Method(mname, const)) -> (cname, Method(mname, const)) 
		with
			rules(
				Methods :+ (cname, mname) -> (cname, mname)
			)

	build-lookup-table-class-component:
		(cname, constraint) -> (cname, constraint) 


      
/*  // Records the definition of an entity in a dynamic rule GetEntity.
  record-entity: 
    Entity(x, body) -> Entity(x, body)
    with
      // For a name 'x', GetEntity will return the original 'x' tree node
      rules(
        GetEntity :+ x -> x
      )

  // Records the definition of an entity in a dynamic rule GetEntity.
  record-class: 
    Class(x, body) -> Class(x, body)
    with
      // For a name 'x', GetEntity will return the original 'x' tree node
      rules(
        GetClass :+ x -> x
      )

  record-setdef: 
    SetDef(x, body) -> SetDef(x, body)
    with
      // For a name 'x', GetEntity will return the original 'x' tree node
      rules(
        GetSetDef :+ x -> x
      )

  record-setvalue: 
    SetDef(name, []) -> SetDef(name, [])
    
  record-setvalue: 
    SetDef(name, [v, vs*]) -> <record-setvalue> SetDef(name, [vs*])
    with
      // For a name 'x', GetEntity will return the original 'x' tree node
      rules(
        GetSetValue :+ v -> v
      )
      
  
*/
rules

	constraint-error:
		SetDef(name, [vs*]) -> (name, $[Duplicate set name: [name]])
	where
		not(<bagof-SetDefs> name => [_])
		
		
	constraint-error:
		SetDef(name, [vs*]) -> [es*]
	where
		[es*] := <currymap(constraint-error-setvalue)> (name, [vs*])

	constraint-error:
		Class(name, extends, [cs*]) -> [es*]
	where
		[es*] := <currymap(constraint-error-components)> (name, [cs*])

	constraint-error-components:
		(name, Attributes([as*])) -> [es*]
	where
		[es*] := <currymap(constraint-error-attribute)> (name, [as*])

	constraint-error-components:
		(name, Methods([ms*])) -> [es*]
	where
		[es*] := <currymap(constraint-error-method)> (name, [ms*])

	constraint-error-components:
		(name, Invariant([is*])) -> []

    /* *****************************************************************
   ********** Workflow Stuff - BEGIN *******************************
   *****************************************************************  */	    

  constraint-error-components:
		(name, Workflows([wfs*])) -> [nwfs*]
	where
		[nwfs*] := <currymap(constraint-error-workflow)> (name, [wfs*])
		
  constraint-error-workflow:
  	    (cname,SeqWf(name,definition)) -> (name, $[Duplicate (sequential) workflow: [name]])
  	where
  		not(<bagof-SeqWfs> (cname,name) => [_])

  constraint-error-workflow:
		(cname, ParWf(name, definition)) -> (name, $[Duplicate (parallel) workflow name: [name]])
	where
		not(<bagof-ParWfs>(cname,name) => [_])
	
  constraint-error-workflow:
  	    (cname,ParWf(pname,definition)) -> <constraint-error-parwf> (cname,definition)	

  // I don't know why this is necessary.
  constraint-error-workflow: t -> []
    
                              
  constraint-error-parwf:
  	    (cname,Single(name)) -> (name, $[sequential workflow [name] not defined]) 
  	where                          
         not(<SeqWfs> (cname,name))
         
  constraint-error-parwf:
  	    (cname,Multiple(name,definition)) -> (name, $[sequential workflow [name] not defined]) 
  	where                          
         not(<SeqWfs> (cname,name))
         
  constraint-error-parwf:
  	    (cname,Multiple(name,definition)) -> <constraint-error-parwf> (cname,definition)
  	 
  // I don't know why this is necessary.	    
  constraint-error-parwf: t -> []
                                                    
/* *****************************************************************
   ********** Workflow Stuff - END *********************************
   *****************************************************************  */

	constraint-error-attribute:
		(cname, Attribute(aname, decorations, type)) -> (aname, $[Duplicate attribute name "[aname]" in class [cname]])
	where
		not(<bagof-Attributes> (cname, aname) => [_])

	constraint-error-attribute:
		(cname, aname) -> []


	
	constraint-error-method:
		(cname, Method(mname, constraint)) -> (mname, $[Duplicate method name "[mname]" in class [cname]])
	where
		not(<bagof-Methods> (cname, mname) => [_])

	constraint-error-method:
		(cname, mname) -> []


	constraint-error-setvalue:
		(name, value) -> (value, $[Duplicate set element: [value]])
	where
		not(<bagof-SetValues> value => [_])

	constraint-error-setvalue:
		(name, value) -> []
		
/*  

  
  constraint-error:	
  	MultMinAndMax(min, max) -> (MultMinAndMax(min,max), $[invalid mutiplicity [min]..[max].  Did you mean [max]..[min]?])
  		where
  			(max, min) := <ltS>(max,min)
  			
  			
    
  // Reports an error if a property type is undefined.
  // This error is reported on the type name 'type'.
  constraint-error:
    UniDirectional(type) -> (type, $[Type [type] is not defined])
    where
      not(<GetClass> type);
      not(<GetSetDef> type)
  

  constraint-error:
    Class(x, _) -> (x, $[Duplicate class name: [x]])
    where
      not(<bagof-GetClass> x => [_])

  constraint-error:
    Class(x, _) -> (x, $[Class and set have duplicate names: [x]])
    where
      not(<bagof-GetSetDef> x => [_])

	constraint-error:
		SetDef(name, [vs*]) -> (name, $[Class and set have duplicate names: [name]])
	where
		not(<bagof-SetDefs> name => [_])
  
  constraint-error:
    SetDef(name, [_,v,vs*]) -> (v, $[Duplicate set element name])
    where
      not(<bagof-GetSetValue> v => [_]) 
  		
  constraint-error:
    SetDef(name, [vs*]) -> <constraint-error-setValue> [vs*] 


  constraint-error-setValue:
	 [] -> []
	 
  constraint-error-setValue:
	 [v,vs*] -> [(v, $[Duplicate set element [v]]),es*]
    where
      not(<bagof-GetSetValue> v => [_]);
      [es*] := <constraint-error-setValue> [vs*] 
  
  constraint-error-setValue:
	 [v,vs*] -> [es*]
    where
      [es*] := <constraint-error-setValue> [vs*] 
*/
  
  
   constraint-note:
    Class("Test", extends, _) -> ("Test", $[This is just an example program in the "entities" language
                                      (this note is defined in trans/check.str) ])
                                      
   constraint-warning:
  	Class(name, extends, []) -> (name, $[Empty class [name]])
 	
                                         
  constraint-error:
  	x -> (x, $[True is equal to False])
  		where
  		<equal>(True(), False()) 

