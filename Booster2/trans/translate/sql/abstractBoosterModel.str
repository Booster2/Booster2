module translate/sql/abstractBoosterModel 

imports
  include/Booster2
  library/valueExpression
  
  library/lookupTable

  library/basicTypes
  library/environment
  
  translate/booster/booster
  elaborate
  simplify
	
  translate/helpers

 rules
 		booster-to-relational:	
		x -> Schema(<LookupTable> "Name", [ metatables*, settables*, tables*, tables'* ], [procedures*, procedures'*], StatementList([metaStatements*, statements*]))
		 where
			[metatables*] := <booster-to-metatables> x; 
			[tables*] := <map(booster-to-relational-class)> <qsort(swap)><LookupTable> "Class" ;
			[tables'*] := <filter(get-assoc-table)> <LookupTable> "Attribute" ;
			[settables*] := <map(get-set-table)> <LookupTable> "SetDef" ;
			[procedures*] := <map(booster-to-relational-procedure)> <LookupTable> "Method" ;
			[procedures'*] := <concat><map(availability-procedure)> <LookupTable> "Method" ;
			[metaStatements*] := <booster-to-metadata> x;
			[statements*] := <concat><map(booster-to-data-inserts)> <LookupTable> "SetDef" 
			 
	booster-to-metatables:
		x ->
			[Table("_Meta_Classes", [idColumn, nameColumn, tableColumn, htmlColumn]),
			 Table("_Meta_Sets", [idColumn, setColumn, tableColumn, columnColumn]),
			 Table("_Meta_Attributes", [idColumn, classColumn, attNameColumn, primTypeColumn, typeMultiplicityColumn, classNameColumn, setNameColumn, directionColumn, tableNameColumn, oppAttColumn, isIdColumn]),
			 Table("_Meta_Methods", [idColumn, classColumn, methodNameColumn, isObjectMethodColumn]),
			 Table("_Meta_Method_Params", [idColumn, classColumn, methodNameColumn, paramNameColumn, paramTypeColumn, paramMultiplicityColumn, paramInOutColumn, paramClassNameColumn, paramSetNameColumn])]

		where
			idColumn := Column("id" , "", False(), Int(), AutoIncrement(), Primary(), None());
			nameColumn := Column("className" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			setColumn := Column("setName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			tableColumn := Column("tableName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			columnColumn := Column("columnName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			htmlColumn := Column("html" , "", False(), Text(), NoExtra(), NoKey(), None());

			classColumn := Column("class" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			attNameColumn := Column("attName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			primTypeColumn := Column("primType" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			typeMultiplicityColumn := Column("typeMultiplicity" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			classNameColumn := Column("className" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			setNameColumn := Column("setName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			directionColumn := Column("direction" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			tableNameColumn := Column("tableName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			oppAttColumn := Column("oppAttName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			isIdColumn := Column("isId" , "", False(), Bit(), NoExtra(), NoKey(), None());
			methodNameColumn := Column("methodName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			isObjectMethodColumn := Column("isObjectMethod" , "", False(), Bit(), NoExtra(), NoKey(), None());
			paramNameColumn := Column("paramName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramTypeColumn := Column("paramType" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramMultiplicityColumn := Column("paramMultiplicity" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramInOutColumn := Column("paramInOut" , "", False(), Varchar(10), NoExtra(), NoKey(), None());
			paramClassNameColumn := Column("paramClassName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramSetNameColumn := Column("paramSetName" , "", False(), Varchar(500), NoExtra(), NoKey(), None())


	booster-to-metadata:
		x ->
			[setnames*, classnames*]
		where
			[setnames*] := <flatten-list><map(booster-to-metadata-sets)> <qsort(swap)><LookupTable> "SetDef";
			[classnames*] := <flatten-list><map(booster-to-metadata-classes)> <qsort(swap)><LookupTable> "Class"

	booster-to-metadata-sets:
		(setname, values) ->
			[ Insert(None(), None(), Into(), "_Meta_Sets", ["setName","tablename","columnName"], [String(setname),String(setname),String(setname)], None())] 

	booster-to-metadata-classes:
		(classname, cdef) ->
			[ Insert(None(), None(), Into(), "_Meta_Classes", ["className","tablename","html"], [String(classname),String(classname), String(<class><innermost(simplify)>(classname, <lookup>(classname, <LookupTable> "Class")))], None()),
				attStmts*, methStmts*, paramStmts*] 
		where
			classAtts := <lookup-class-attributes> classname;
			[attStmts*] := <map(booster-to-metadata-attributes)> classAtts;
			classMeths := <lookup-class-methods> classname;
			[methStmts*] := <map(booster-to-metadata-method)> classMeths;
			[paramStmts*] := <map(booster-to-metadata-method-params)> classMeths
			

	booster-to-metadata-attributes:
		((classname, attname), (ds, t, opp, min, max, tname)) ->
			Insert(None(), None(), Into(), "_Meta_Attributes", 
						["class","attName","primType","typeMultiplicity","oppAttName","className","setName","direction","tableName","isId"], 
						[String(classname),String(attname),String(primType),String(typeMultiplicity),oppAttName,String(className),String(setName),String(direction),String(tableName),Int(isId)], None())
		where
			(primType, typeMultiplicity,className,setName) := <attribute-type-metadata> t;
			(direction, oppAttName) := <get-direction> (classname, attname);
			tableName := <lookup-attribute-table-name>(classname, attname);
			isId := <((<elem> (Identity(), ds) ; !1 ) <+ !0)> ds

	booster-to-metadata-method:
		((classname, methodname), (c, gc, es, d, is, os))  ->
			Insert(None(), None(), Into(), "_Meta_Methods", 
						["class","methodName","isObjectMethod"], 
						[String(classname),String(methodname),isObjectMethod], None())
		where
			isObjectMethod := <((<elem> (("this", Reference(classname)), is) ; !True() ) <+ !False())> is


	booster-to-metadata-method-params:
		((classname, methodname), (c, gc, es, d, is, os)) ->
			[istmts*,ostmts*]
		where
			[istmts*] := <map((\ i -> ((classname, methodname), "input", i) \) ; booster-to-metadata-param)> is ;
			[ostmts*] := <map((\ o -> ((classname, methodname), "output", o) \) ; booster-to-metadata-param)> os 
			/*log(|Error(),i*) */			

	booster-to-metadata-param:
		((classname, methodname), inout, (name, type)) ->
			Insert(None(), None(), Into(), "_Meta_Method_Params", 
						["class", "methodName", "paramName","paramType","paramMultiplicity","paramInOut","paramClassName", "paramSetName"], 
						[String(classname), String(methodname), String(name),String(paramPrimType), String(paramTypeMultiplicity),String(inout), String(paramClassName), String(paramSetName)], None())

		where
			(paramPrimType, paramTypeMultiplicity,paramClassName,paramSetName) := <attribute-type-metadata> type
						


	get-direction:
		(classname, attname)
			-> ("Bi", String(attname2))
		where
			(classname2, attname2) := <lookup-opposite>(classname, attname)

	get-direction:
		(classname, attname)
			-> ("Uni", Null())

	attribute-type-metadata:
		BasicType(t) -> 
			(desc,"Mandatory","","")
		where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Reference(name) -> ("ClassRef","Mandatory",name,"")
		where 
			<is-class-name> name
			
	attribute-type-metadata:
		Reference(name) -> ("SetValue","Mandatory","",name)
		where 
			<is-set-name> name

	attribute-type-metadata:
		Optional(BasicType(t)) -> 
			(desc,"Optional","","")
				where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Optional(Reference(name)) -> ("ClassRef","Optional",name,"")
		where 
			<is-class-name> name
			
	attribute-type-metadata:
		Optional(Reference(name)) -> ("SetValue","Optional","",name)
		where 
			<is-set-name> name
	
	attribute-type-metadata:
		Set(BasicType(t)) -> 
			(desc,"Set","","")
				where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Set(Reference(name)) -> ("ClassRef","Set",name,"")
		where 
			<is-class-name> name 
			
	attribute-type-metadata:
		Set(Reference(name)) -> ("SetValue","Set","",name)
		where 
			<is-set-name> name

	booster-to-relational-class:
		(cname, (dscs, ascs, as, ms, cs, wfs)) 
			-> Table(cname, [Column(identity , "", False(), Int(), AutoIncrement(), Primary(), None()), columns*])
		where 
			[columns*] := <filter(get-attribute-column)><filter(\((cname',aname), adef) -> ((cname',aname), adef) where <equal>(cname', cname) \)> <LookupTable> "Attribute";
			//log(|Error(), "columns", [columns*]);
			/* log(|Error(), "columns", <filter(\((cname,aname), adef) -> ((cname,aname), adef) \)> <LookupTable> "Attribute"); */ 
			identity := <concat-strings> [cname, "Id"]

			
		
	booster-to-relational-procedure:
		((cname, mname), (c,gc,exts,d,is,os))
			-> Procedure(name, params, DeclareList([]), StatementList(statements))
		where
			name := <concat-strings> [cname, "_", mname];
			params := <nub><union> (<map(convert-input)>is, <map(convert-output)> os);
			statements := <booster-to-relational-guarded-command> (cname, mname, gc)

	booster-to-data-inserts:
		(name,values) 
			-> <union>([Insert(None(), None(), Into(), name, [name], [String("unassigned")], None())], stmts)
		where
			stmts := <map(\ value -> Insert(None(), None(), Into(), name, [name], [String(value)], None()) \)> values
			
	
			
	get-attribute-column:
		((cname, attname), (ds, BasicType(t), opp, 1, 1, tablename))
			-> Column(attname, "", False(), t', NoExtra(), NoKey(), None())
		where
			<updateAttributeTableName> (cname, attname, cname);
			t' := <get-type-booster-to-sql> t


	get-attribute-column:
		((cname, attname), (ds, Reference(tname), opp, 1, 1, tablename))
			-> Column(attname, "", False(), Varchar(500), NoExtra(), NoKey(),Some(Reference(tname, [tname])))
		where
			<is-set-name> tname;
			<updateAttributeTableName> (cname, attname,cname)

	get-attribute-column:
		((cname, attname), (ds, Reference(tname), opp, 1, 1, tablename))
			-> Column(attname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>([cname, "Id"])])))
		where
			<is-class-name> tname;
			not(<lookup-opposite>(cname, attname));
			<updateAttributeTableName> (cname, attname,cname)
	
	get-attribute-column:
		((cname, attname), (ds, Optional(BasicType(t)), opp, 0, 1, tablename))
			-> Column(attname, "null", True(), t', NoExtra(), NoKey(), None())
		where
			<updateAttributeTableName> (cname, attname, cname);
			t' := <get-type-booster-to-sql> t


	get-attribute-column:
		((cname, attname), (ds, Optional(Reference(tname)), opp, 0, 1, tablename))
			-> Column(attname, "null", True(), Varchar(500), NoExtra(), NoKey(),Some(Reference(cname, [cname])))
		where
			<is-set-name> tname;
			<updateAttributeTableName> (cname, attname,cname)

	get-attribute-column:
		((cname, attname), (ds, Optional(Reference(tname)), opp, 0, 1, tablename))
			-> Column(attname, "null", True(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>([cname, "Id"])])))
		where
			<is-class-name> tname;
			not(<lookup-opposite>(cname, attname));
			<updateAttributeTableName> (cname, attname, cname)

				
			
	get-assoc-table:
		((cname, attname), (ds, t, (oname, oaname), min, max, tn))
			-> Table(tablename, [Column(tableid, "", False(), Int(), AutoIncrement(), Primary(), None()), 
								 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
								 Column(secondcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(oname, [<concat-strings>[oname, "Id"]])))])
		where
			//log(|Error(), "get-assoc-table", (cname, attname));
			<(?Reference(oname) <+ ?Optional(Reference(oname)) <+ ?Set(Reference(oname)))> t;
			//log(|Error(), "get-assoc-table 1", (cname, attname));
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "_", attname];			
			secondcolname := <concat-strings> [oname, "_", oaname];
			tableid := <concat-strings> [tablename, "Id"];
			<updateAttributeTableName> (cname, attname, tablename)

	get-assoc-table:
		((cname, attname), (ds, Set(BasicType(t)), opp, min, max, tn))
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), t', NoExtra(), NoKey(),None())])
		where
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			t' := <get-type-booster-to-sql> t;
			<updateAttributeTableName> (cname, attname, tablename)
			

	get-assoc-table:
		((cname, attname), (ds, Set(Reference(tname)), opp, min, max, tn))
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), Varchar(500), NoExtra(), NoKey(),Some(Reference(tname, [tname])))])
		where
			<is-set-name> tname;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			<updateAttributeTableName> (cname, attname, tablename)
			
	get-assoc-table:
		((cname, attname), (ds, Set(Reference(tname)), opp, min, max, tn))
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(tname, [<concat-strings>([tname, "Id"])])))])
		where
			<is-class-name> tname;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			<updateAttributeTableName> (cname, attname, tablename)

/*    get-assoc-table:
    	something -> Table("",[]) 
    		where 
    		log(|Error(), "cannot find assoc table", something)
*/
			
	get-set-table:
		(name, [values*])
			-> Table(name, [Column(name, "unassigned", False(), Varchar(100), NoExtra(), Primary(),None())])

			
	convert-input:
		(name, BasicType(t))
			-> Input(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-input:
		(name, Optional(BasicType(t)))
			-> Input(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-input:
		(name, Reference(tname))
			-> Input(name, Varchar(100))
		where
			<is-set-name> tname

	convert-input:
		(name, Reference(cname))
			-> Input(name, Int())

	convert-input:
		(name, Optional(Reference(cname)))
			-> Input(name, Int())

	convert-output:
		(name, BasicType(t))
			-> Output(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-output:
		(name, Reference(tname))
			-> Output(name, Varchar(100))
		where
			<is-set-name> tname

	convert-output:
		(name, Reference(cname))
			-> Output(name, Int())



			 	
	booster-to-relational-guarded-command:
		(classname, progname, Skip())
			-> [ VariableAssign("dummySkip", Int(1)) ]
			
			

	booster-to-relational-guarded-command:
		(classname, progname, Assign(Path(ps {Optional(Reference(tablename))}, pc){t}, expr))
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				pn' := <path-to-variable-name> Path(ps {Optional(Reference(tablename))}, pc){t};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-path-to-where-clause> (classname, progname, Path(ps {Optional(Reference(tablename))}, pc){t})

	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, BinOp(Path(ps { Reference(classname')}, pc), Union(), SetExtent([expr]))))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), IfThen(	Equal( Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
													  	Equal(ColumnName(column2), LocalVariable(pn2)))), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()), 
								  Int(0)), 
						StatementList([Insert(None(), None(), Into(), tablename, [column1, column2], [LocalVariable(pn1), LocalVariable(pn2)], None())]),
						[],
						None()
					)]				
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> (classname, progname, ps);
				expr2 := <booster-to-relational-expression> (classname, progname, expr) 

	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, BinOp(Path(ps { Optional(Reference(classname'))}, pc), Union(), SetExtent([expr]))))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), IfThen(	Equal( Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
													  	Equal(ColumnName(column2), LocalVariable(pn2)))), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()), 
								  Int(0)), 
						StatementList([Insert(None(), None(), Into(), tablename, [column1, column2], [LocalVariable(pn1), LocalVariable(pn2)], None())]),
						[],
						None()
					)]				
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> (classname, progname, ps);
				expr2 := <booster-to-relational-expression> (classname, progname, expr) 

	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, BinOp(Path(ps { Reference(classname')}, pc), Minus(), SetExtent([expr]))))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), Delete(	None(), None(), None(), 
						tablename, 
						Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
									Equal(ColumnName(column2), LocalVariable(pn2)))), 
						None(), None())]
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> (classname, progname, ps);
				expr2 := <booster-to-relational-expression> (classname, progname, expr) 

	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, BinOp(Path(ps { Optional(Reference(classname'))}, pc), Minus(), SetExtent([expr]))))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), Delete(	None(), None(), None(), 
						tablename, 
						Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
									Equal(ColumnName(column2), LocalVariable(pn2)))), 
						None(), None())]
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> (classname, progname, ps);
				expr2 := <booster-to-relational-expression> (classname, progname, expr) 

	booster-to-relational-guarded-command:
		(classname, progname, Assign(Path(ps { Reference(tablename) }, pc){BasicType(t)}, expr))
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				pn' := <path-to-variable-name> Path(ps { Reference(tablename) }, pc){BasicType(t)};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-path-to-where-clause> (classname, progname, Path(ps { Reference(tablename) }, pc){BasicType(t)})

	booster-to-relational-guarded-command:
		(classname, progname, Assign(Path(ps { Reference(tablename) }, pc){Optional(BasicType(t))}, expr))
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				pn' := <path-to-variable-name> Path(ps { Reference(tablename) }, pc){Optional(BasicType(t))};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-path-to-where-clause> (classname, progname, Path(ps { Reference(tablename) }, pc){BasicType(t)})

	booster-to-relational-guarded-command:
		(classname, progname, Assign(Path(ps { Reference(tablename) }, pc){Reference(t)}, expr))
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				<is-set-name> t;
				pn' := <path-to-variable-name> Path(ps { Reference(tablename) }, pc){Reference(t)};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-path-to-where-clause> (classname, progname, Path(ps { Reference(tablename) }, pc){Reference(t)})
				
	booster-to-relational-guarded-command:
		(classname, progname, Assign(Path(ps { Reference(classname') }, PathComponent(attname, None())){Reference(t)}, expr))
			-> [VariableAssign(png, Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(Equal(ColumnName(column1), expr'')), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None())), 
				VariableAssign(pn', expr'), 
				IfThen(NotEqual( LocalVariable(png), Int(0)), 
						StatementList([	Update([], TableName(tablename),[(oppattname, LocalVariable(pn'))],Where(expr'''),None(),None())]),
						[],
						StatementList([Insert(None(), None(), Into(), tablename, [column1, oppattname], [expr'', LocalVariable(pn')], None())])
						)]
				
				
			where 
				<is-class-name> t;
				pn' := <path-to-variable-name> Path(ps { Reference(classname') }, PathComponent(attname, None())){Optional(Reference(t))};
				png := <concat-strings>[pn', "_guard"];
				tablename := <concat-strings>[classname', "_", attname];
				column1 := <concat-strings>[classname', "_", attname];
				//log(|Error(), "guarded-command to relational", tablename);
				(cname', aname') := <lookup-opposite> (classname', attname);
				oppattname := <concat-strings>[cname', "_", aname'];
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-to-relational-expression> (classname, progname, ps { Reference(classname') });
				expr''' := <booster-path-to-where-clause> (classname, progname, Path(ps { Reference(classname') }, PathComponent(attname, None())){Reference(t)})

	booster-to-relational-guarded-command:
		(classname, progname, Assign(Path(ps { Reference(classname') }, PathComponent(attname, None())){Optional(Reference(t))}, expr))
			-> [VariableAssign(png, Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(Equal(ColumnName(column1), expr'')), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None())),
				VariableAssign(pn', expr'), 
				IfThen(NotEqual( LocalVariable(png), Int(0)), 
						StatementList([	Update([], TableName(tablename),[(oppattname, LocalVariable(pn'))],Where(expr'''),None(),None())]),
						[],
						StatementList([Insert(None(), None(), Into(), tablename, [column1, oppattname], [expr'', LocalVariable(pn')], None())])
						)]
				
				
			where 
				<is-class-name> t;
				pn' := <path-to-variable-name> Path(ps { Reference(classname') }, PathComponent(attname, None())){Optional(Reference(t))};
				png := <concat-strings>[pn', "_guard"];
				tablename := <concat-strings>[classname', "_", attname];
				column1 := <concat-strings>[classname', "_", attname];
				//log(|Error(), "guarded-command to relational", tablename);
				(cname', aname') := <lookup-opposite> (classname', attname);
				oppattname := <concat-strings>[cname', "_", aname'];
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-to-relational-expression> (classname, progname, ps { Reference(classname') });
				expr''' := <booster-path-to-where-clause> (classname, progname, Path(ps { Reference(classname') }, PathComponent(attname, None())){Reference(t)})
				
	booster-to-relational-guarded-command:
		(classname, progname, New(Output(obj), PathStart(cls, None())))
			-> [Insert(None(), None(), Into(), cls, [], [], None()),
				Select([],[FunctionCall("LAST_INSERT_ID", [])], None(), None(), None(), None(), None(), None(), None(), Some(Into([Output(obj)])), None())]
	

/*	booster-to-relational-guarded-command:
		(classname, progname, Guard(const, gc))
			-> []
		where
			[] := <booster-to-relational-guarded-command> (classname, progname, gc);
			expr' := <booster-to-relational-constraint> (classname, progname, const)
*/

	booster-to-relational-guarded-command:
		(classname, progname, Guard(const, gc))
			-> [IfThen(expr', StatementList([stmts*]),[],None())]
		where
			[stmts*] := <booster-to-relational-guarded-command> (classname, progname, gc);
			expr' := <booster-to-relational-constraint> (classname, progname, const)

	booster-to-relational-guarded-command:
		(classname, progname, Parallels(xs))
			-> <booster-to-relational-guarded-command> (classname, progname, Parallels(ys))
		where
			(creates, non-creates) := <partition(?New(_, _))> xs;
			ys := <concat>[creates, non-creates];
			<not(equal)>(xs, ys)



	booster-to-relational-guarded-command:
		(classname, progname, Parallels([x]))
			-> <booster-to-relational-guarded-command> (classname, progname, x)

	booster-to-relational-guarded-command:
		(classname, progname, Parallels([x, xs*]))
			-> [BeginEnd(DeclareList([]), StatementList([decs*, stmts*]))]
		where
			[stmts1*] := <booster-to-relational-guarded-command> (classname, progname, x);
			[stmts2*] := <booster-to-relational-guarded-command> (classname, progname, Parallels([xs*]));
			([decs*], [stmts*]) := <partition(?VariableAssign(_, _))> [stmts1*, stmts2*] 
			
/*	booster-to-relational-guarded-command:
		(classname, progname, Parallel(gc1,gc2))
			-> [BeginEnd(DeclareList([]), StatementList([decs*, stmts*]))]
		where
			[stmts1*] := <booster-to-relational-guarded-command> (classname, progname, gc1);
			[stmts2*] := <booster-to-relational-guarded-command> (classname, progname, gc2);
			([decs*], [stmts*]) := <partition(?VariableAssign(_, _))> [stmts1*, stmts2*] 		
*/
	booster-to-relational-guarded-command:
		(classname, progname, Sequence(gc1,gc2))
			-> [BeginEnd(DeclareList([]), StatementList(stmts1)),BeginEnd(DeclareList([]), StatementList(stmts2))]
		where
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1);
			stmts2 := <booster-to-relational-guarded-command> (classname, progname, gc2) 		

	booster-to-relational-guarded-command:
		(classname, progname, Choice(Guard(constraint1, gc1),Guard(constraint2, Skip())))
			-> [IfThen(expr1, StatementList(stmts1),[],None())]
		where
			expr1 := <booster-to-relational-constraint> (classname, progname, constraint1);
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1) 		


	booster-to-relational-guarded-command:
		(classname, progname, Choice(Guard(constraint1, gc1),Guard(constraint2, gc2)))
			-> [IfThen(expr1, StatementList(stmts1),[ElseIf(expr2,StatementList(stmts2) )],None())]
		where
			expr1 := <booster-to-relational-constraint> (classname, progname, constraint1);
			expr2 := <booster-to-relational-constraint> (classname, progname, constraint2);
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1);
			stmts2 := <booster-to-relational-guarded-command> (classname, progname, gc2) 		

	booster-to-relational-guarded-command:
		(classname, progname, Choice(gc1,gc2))
			-> [IfThen(True(), StatementList(stmts1),[],StatementList(stmts2))]
		where
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1);
			stmts2 := <booster-to-relational-guarded-command> (classname, progname, gc2) 		



	booster-to-relational-guarded-command:
		(classname, progname, gc)
			-> []
		where
			log(|Error(), "cannot convert guarded command", gc);
			log(|Error(), "guarded command: ", <guardedCommand> gc)


	booster-to-relational-constraint:
		(classname, progname, True())
			-> True()

	booster-to-relational-constraint:
		(classname, progname, False())
			-> False()

	booster-to-relational-constraint:
		(classname, progname, Not(const))
			-> Not(const')
		where
			const' := <booster-to-relational-constraint> (classname, progname, const)

	booster-to-relational-constraint:
		(classname, progname, Conjuncts([const]))
			-> <booster-to-relational-constraint> (classname, progname, const)

	booster-to-relational-constraint:
		(classname, progname, Conjuncts([const, consts*]))
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const);
			const2' := <booster-to-relational-constraint> (classname, progname, Conjuncts([consts*]))

	booster-to-relational-constraint:
		(classname, progname, Conjuncts([]))
			-> True()

	booster-to-relational-constraint:
		(classname, progname, And(const1, const2))
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, Or(const1, const2))
			-> Or(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, Implies(const1, const2))
			-> Or(const2', Not(const1'))
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, Then(const1, const2))
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)


	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, Equal(), Null()))
			-> IsNull(expr1',None())
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, Equal(), expr2))
			-> Equal(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, NotEqual(), Null()))
			-> IsNull(expr1', Not())
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, NotEqual(), expr2))
			-> NotEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, In(), TypeExtent(t)))
			-> True()

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, In(), Path(ps {Reference(cname)}, PathComponent(attname, maybeprimed)){Set(Reference(t))}))
			-> NotEqual( Select([],
										[FunctionCall("count", [Star()])], 
										Some(FromPart([TableName(tablename)])), 
										Where(And(Equal(ColumnName(column1), expr''),
												  Equal(ColumnName(column2), expr'))), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None()), 
							  Int(0))
				
				
			where
				<is-class-name> t;
				tablename := <concat-strings>[cname, "_", attname];
				column1 := <concat-strings>[cname, "_", attname];
				expr' := <booster-to-relational-expression> (classname, progname, expr1);
				(cname', aname') := <lookup-opposite> (cname, attname);
				column2 := <concat-strings>[cname', "_", aname'];
				expr'' := <booster-to-relational-expression> (classname, progname, ps { Reference(cname) })

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, NotIn(), Path(ps {Reference(cname)}, PathComponent(attname, maybeprimed)){Set(Reference(t))}))
			-> Equal( Select([],
										[FunctionCall("count", [Star()])], 
										Some(FromPart([TableName(tablename)])), 
										Where(And(Equal(ColumnName(column1), expr''),
												  Equal(ColumnName(column2), expr'))), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None()), 
							  Int(0))
				
				
			where
				<is-class-name> t;
				tablename := <concat-strings>[cname, "_", attname];
				column1 := <concat-strings>[cname, "_", attname];
				expr' := <booster-to-relational-expression> (classname, progname, expr1);
				(cname', aname') := <lookup-opposite> (cname, attname);
				column2 := <concat-strings>[cname', "_", aname'];
				expr'' := <booster-to-relational-expression> (classname, progname, ps { Reference(cname) })


	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, In(), expr2))
			-> InSet(expr1', None(), expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, NotIn(), expr2))
			-> InSet(expr1', Not(), expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, LessThan(), expr2))
			-> LessThan(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, GreaterThan(), expr2))
			-> GreaterThan(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, LessThanEquals(), expr2))
			-> LessThanEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, GreaterThanEquals(), expr2))
			-> GreaterThanEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, Forall(var, Path(ps {Reference(cname)}, PathComponent(attname, None())){Set(t)}, constraint))
			-> Equal( Select([],
							[FunctionCall("count", [Star()])], 
							Some(FromPart([TableName(tablename)])), 
							Where(Not(And(Equal(ColumnName(column1), expr''),
									const'''))), 
							None(), 
							None(), 
							None(), 
							None(), 
							None(), 
							None(), 
							None()), 
					Int(0))
			where
				tablename := <concat-strings>[cname, "_", attname];
				column1 := <concat-strings>[cname, "_", attname];
				expr'' := <booster-to-relational-expression> (classname, progname, ps { Reference(cname) });
				const' := <literal-substitute> (constraint, [(PathStart(var, None()), Input(var){t})]);
				sysvar := <concat-strings>[var, "_in"];
				const'' := <booster-to-relational-constraint> (classname, progname, const');
				(cname', aname') := <lookup-opposite> (cname, attname);
				oppattname := <concat-strings>[cname', "_", aname'];
				const''' := <literal-substitute> (const'', [(SystemVariable(sysvar), ColumnName(oppattname))])

	booster-to-relational-constraint:
		(classname, progname, constraint)
			-> True()
		where
			log(|Error(), "cannot convert constraint", constraint)

	booster-to-relational-expression:
		(classname, progname, BasicValue(String(str)))
			-> String(str)

	booster-to-relational-expression:
		(classname, progname, BasicValue(Integer(i)))
			-> Int(i)

	booster-to-relational-expression:
		(classname, progname, BasicValue(Decimal(d)))
			-> Decimal(d)

	booster-to-relational-expression:
		(classname, progname, PathStart(v, None()) {Reference(sn)})
			-> String(v)
		where
			<is-set-name> sn

	booster-to-relational-expression:
		(classname, progname, PathStart(v, None()) {Optional(Reference(sn))})
			-> String(v)
		where
			<is-set-name> sn


	booster-to-relational-expression:
		(classname, progname, BasicValue(CurrentDateTime()))
			-> FunctionCall("NOW", [])

	booster-to-relational-expression:
		(classname, progname, BasicValue(CurrentDate()))
			-> FunctionCall("CURDATE", [])

	booster-to-relational-expression:
		(classname, progname, BasicValue(CurrentTime()))
			-> FunctionCall("CURTIME", [])



	booster-to-relational-expression:
		(classname, progname, TypeExtent(t))
			-> Null()


	booster-to-relational-expression:
		(classname, progname, Null())
			-> Null()

	booster-to-relational-expression:
		(classname, progname, SetExtent(exprs))
			-> SetExpression(exprs)

	booster-to-relational-expression:
		(classname, progname, Input(n))
			-> SystemVariable(m)
		where 
			m := <concat-strings>[n, "_in"]

	booster-to-relational-expression:
		(classname, progname, Output(n))
			-> SystemVariable(m)
		where 
			m := <concat-strings>[n, "_out"]

	booster-to-relational-expression:
		(classname, progname, This())
			-> SystemVariable("this")

	booster-to-relational-expression:
		(classname, progname, ThisPrimed())
			-> Null()
			
	booster-to-relational-expression:
		(classname, progname, Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {t})
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			< ?BasicType(b) <+ ?Optional(BasicType(b))> t;
			expr :=  <booster-to-relational-expression> (classname, progname, p)

	booster-to-relational-expression:
		(classname, progname, Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {Reference(sn)})
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			<is-set-name> sn;
			expr :=  <booster-to-relational-expression> (classname, progname, p)

	booster-to-relational-expression:
		(classname, progname, Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {Optional(Reference(sn))})
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			<is-set-name> sn;
			expr :=  <booster-to-relational-expression> (classname, progname, p)
			
	booster-to-relational-expression:
		(classname, progname, Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {t})
		// select name from class where classId = expr
			-> Select([], [ColumnName(oppcname)], Some(FromPart([TableName(tname)])), 
						  Where(Equal(expr, ColumnName(cname))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			< ?Optional(Reference(b)) <+ ?Reference(b)> t;
			expr :=  <booster-to-relational-expression> (classname, progname, p);
			tname := <concat-strings>[c, "_",name];
			cname := tname;
			(classname', attname') := <lookup-opposite> (c, name); 
			oppcname := <concat-strings>[classname', "_", attname']
				 				
	booster-to-relational-expression:
		(classname, progname, Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {t})
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(tname)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[tname, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			expr :=  <booster-to-relational-expression> (classname, progname, p);
			tname := <concat-strings>[c, "_",name];
			< ?Set(b)> t
				 				



	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Plus(), expr2))
			-> Plus(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Minus(), expr2))
			-> Minus(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Times(), expr2))
			-> Multiply(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Divide(), expr2))
			-> Divide(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, UnOp(Cardinality(), (Path(ps{Reference(cname)}, PathComponent(aname, maybeprimed)){Set(Reference(t))})))
			-> Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(expr'), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None())
		where
			tablename := <concat-strings>[cname, "_", aname];
			expr' := <booster-path-to-where-clause> (classname, progname, (Path(ps{Reference(cname)}, PathComponent(aname, maybeprimed)){Set(Reference(t))}))
			

	booster-to-relational-expression:
		(expr, cname)
			-> Null()
		where
			log(|Error(), "cannot convert expression", expr)


	booster-path-to-where-clause:
		(classname, progname, Path(p {Reference(cname)}, PathComponent(name, None())){t})
			-> Equal(expr, ColumnName(<concat-strings>[cname, "Id"]))
		where 
			< ?BasicType(t') <+ ?Optional(BasicType(t')) <+ ?Reference(t') ; <is-set-name> t'> t;
			expr := <booster-to-relational-expression> (classname, progname, p)


	booster-path-to-where-clause:
		(classname, progname, Path(p {Reference(cname)}, PathComponent(attname, None())){t})
			-> Equal(expr, ColumnName(<concat-strings>[cname, "_",attname]))
		where 
			expr := <booster-to-relational-expression> (classname, progname, p)
	
	
	
	booster-path-to-where-clause:
		(classname, progname, Output(n))
			-> True()

	booster-path-to-where-clause:
		(classname, progname, This())
			-> True()

	booster-path-to-where-clause:
		(classname, progname, ThisPrimed())
			-> True()
	
	remove-inputs: 
		(c,is) ->
			<topdown(\ trm -> <remove-input <+ !trm> (trm, is) \)> c
	
	remove-input:
		(BinRel(exp1, relop, exp2), is) -> True() 
			where 
				ios := <collect-all(?Input(i) <+ ?Output(o))> BinRel(exp1, relop, exp2);
				<not(subseteq)>(ios, is)
	
	availability-procedure:
		((cname, mname), (c,gc,exts,d,is,os))
			-> [Function(name1, params1, Bit(), DeclareList([]), StatementList(statements1)),
				Function(name2, params2, Bit(), DeclareList([]), StatementList(statements2)),
				is-procs*]
		where
			// Function to test the availability without inputs
			name1 := <concat-strings> [cname, "_", mname, "_available"];
			params1 := [Input("this", Int())];
			guard-without-inputs := <(\ Guard(c, p) -> <remove-inputs> (c, []) \) <+ !True() >  gc;
			//log(|Error(), "guard-without-inputs", <constraint> guard-without-inputs);
			statements1 := [
				IfThen(<booster-to-relational-constraint> (cname, mname, guard-without-inputs), 
					StatementList([Return(Int(1))]), 
					[], 
					StatementList([Return(Int(0))]))
				];
			// Function to test the availability with inputs
			name2 := <concat-strings> [cname, "_", mname, "_available_inputs"];
			params2 := <map(convert-input)>is;
			guard := <(\ Guard(c, p) -> c\) <+ !True() >  gc;
			statements2 := [
				IfThen(<booster-to-relational-constraint> (cname, mname, guard), 
					StatementList([Return(Int(1))]), 
					[], 
					StatementList([Return(Int(0))]))
				];
			// Procedures to return the applicable object references
			class-is := <filter(is-object-ref)> is;
			[is-procs*] := <map(\ i -> <procedure-to-get-applicable-references> ((cname, mname), gc, i)\)> class-is
			

is-object-ref:
	(i, Reference(t))
		-> Input(i){Reference(t)}
	where
		<not(equal)>(i, "this");
		<is-class-name> t
		
is-object-ref:
	(i, Optional(Reference(t)))
		-> Input(i){Optional(Reference(t))}
	where
		<not(equal)>(i, "this");
		<is-class-name> t

get-reference-class-name:
	Optional(Reference(t)) -> t

get-reference-class-name:
	Reference(t) -> t
		
procedure-to-get-applicable-references:
	((cname, mname), gc, Input(i){type})
		-> Procedure(name, params, DeclareList([]), StatementList(statements))
	where
		tname := <get-reference-class-name> type;
		name := <concat-strings> [cname, "_", mname,"_",i,"_choice"];
		params := [Input("this", Int())];
		guard-without-inputs := <(\ Guard(c, p) -> <remove-inputs> (c,[Input(i){type}])\) <+ !True() >  gc;
		//log(|Error(), "available-references", <constraint> guard-without-inputs);
		tidname := <concat-strings> [tname, "Id"];
		expr' := <booster-to-relational-constraint> (cname, mname, guard-without-inputs);
		//log(|Error(), expr');
		expr'' := <literal-substitute> (expr', [(SystemVariable(<concat-strings>[i, "_in"]), ColumnName(tidname))]);
		statements := [InsertInto(
							"CLASS_DESCS", 
							["OBJECT_ID"], 
							Select([],
									[ColumnName(tidname)], 
											Some(FromPart([TableName(tname)])), 
											Where(expr''), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()))]


/*
get-declare-lists:
	(classname, progname, Skip()) -> []
	
get-declare-lists:
	(classname, progname, Assign(path, BinOp(Path(ps { Optional(Reference(classname'))}, pc), Minus(), SetExtent([expr]))))
		-> [VariableAssign(pn,e')]
	where
		e' := <booster-to-relational-expression> (classname, progname, expr);
		pn := <path-to-variable-name> path

get-declare-lists:
	(classname, progname, Assign(path, BinOp(Path(ps { Reference(classname')}, pc), Minus(), SetExtent([expr]))))
		-> [VariableAssign(pn,e')]
	where
		e' := <booster-to-relational-expression> (classname, progname, expr);
		pn := <path-to-variable-name> path

get-declare-lists:
	(classname, progname, Assign(path, BinOp(Path(ps { Reference(classname')}, pc), Union(), SetExtent([expr]))))
		-> [VariableAssign(pn,e')]
	where
		e' := <booster-to-relational-expression> (classname, progname, expr);
		pn := <path-to-variable-name> path

get-declare-lists:
	(classname, progname, Assign(path, BinOp(Path(ps { Optional(Reference(classname'))}, pc), Union(), SetExtent([expr]))))
		-> [VariableAssign(pn,e')]
	where
		e' := <booster-to-relational-expression> (classname, progname, expr);
		pn := <path-to-variable-name> path



get-declare-lists:
	(classname, progname, Assign(Path(ps {Optional(Reference(tablename))}, pc){t}, expr)) -> [VariableAssign(pn,e')]
	where
		e' := <booster-to-relational-expression> (classname, progname, expr);
		pn := <path-to-variable-name> Path(ps {Optional(Reference(tablename))}, pc){t}

get-declare-lists:
	(classname, progname, Assign(Path(ps {Reference(tablename)}, pc){t}, expr)) -> [VariableAssign(pn,e')]
	where
		e' := <booster-to-relational-expression> (classname, progname, expr);
		pn := <path-to-variable-name> Path(ps {Reference(tablename)}, pc){t}


get-declare-lists:
	(classname, progname, Guard(g,p))
		-> <get-declare-lists> (classname, progname, p)

get-declare-lists:
	(classname, progname, New(n,c))
		-> []
		

get-declare-lists:
	(classname, progname, Parallel(p,q))
		-> <union>(<get-declare-lists> (classname, progname, p), <get-declare-lists> (classname, progname, q))

get-declare-lists:
	(classname, progname, Choice(p,q))
		-> <union>(<get-declare-lists> (classname, progname, p), <get-declare-lists> (classname, progname, q))

get-declare-lists:
	(classname, progname, Sequence(p,q))
		-> <union>(<get-declare-lists> (classname, progname, p), <get-declare-lists> (classname, progname, q))
*/
	
path-to-variable-name:
	PathStart(name, maybeprimed)
		-> <concat-strings>["path_", name]

path-to-variable-name:
	Path(p, PathComponent(att, maybeprimed))
		-> <concat-strings>[<path-to-variable-name> p, "_", att]

path-to-variable-name:
	This()
		-> "path_this"

path-to-variable-name:
	Input(i)
		-> <concat-strings>["path_", i, "_in"]

path-to-variable-name:
	Output(o)
		-> <concat-strings>["path_", o, "_out"]
