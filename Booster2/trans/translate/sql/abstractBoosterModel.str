module translate/sql/abstractBoosterModel 

imports
  include/Booster2
  library/valueExpression
  
  library/lookupTable

  library/basicTypes
  library/environment
  
  translate/booster/booster
  elaborate
  simplify
	
  translate/helpers

 rules
 		booster-to-relational:	
		x -> Schema(<LookupTable> "Name", [ metatables*, settables*, tables*, tables'* ], [procedures*, procedures'*,procedures''*], StatementList([metaStatements*, statements*]))
		 where
			[metatables*] := <booster-to-metatables> x; 
			[tables*] := <map(booster-to-relational-class)> <qsort(swap)><LookupTable> "Class" ;
			[tables'*] := <filter(get-assoc-table)> <LookupTable> "Attribute" ;
			[settables*] := <map(get-set-table)> <LookupTable> "SetDef" ;
			[procedures*] := <map(booster-to-relational-procedure)> <LookupTable> "Method" ;
			[procedures'*] := <concat><map(availability-procedure)> <LookupTable> "Method" ;
			[procedures''*] := <map(\(cname, cdef) -> <function-to-get-id> cname \)> <LookupTable> "Class";
			[metaStatements*] := <booster-to-metadata> x;
			[statements*] := <concat><map(booster-to-data-inserts)> <LookupTable> "SetDef" 
			 
	booster-to-metatables:
		x ->
			[Table("_Meta_Classes", [idColumn, nameColumn, tableColumn]),
			 Table("_Meta_Sets", [idColumn, setColumn, tableColumn, columnColumn]),
			 Table("_Meta_Attributes", [idColumn, classColumn, attNameColumn, primTypeColumn, typeMultiplicityColumn, classNameColumn, setNameColumn, directionColumn, tableNameColumn, oppAttColumn, isIdColumn]),
			 Table("_Meta_Methods", [idColumn, classColumn, methodNameColumn, isObjectMethodColumn, htmlColumn]),
			 Table("_Meta_Method_Params", [idColumn, classColumn, methodNameColumn, paramNameColumn, paramTypeColumn, paramMultiplicityColumn, paramInOutColumn, paramClassNameColumn, paramSetNameColumn])]

		where
			idColumn := Column("id" , "", False(), Int(), AutoIncrement(), Primary(), None());
			nameColumn := Column("className" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			setColumn := Column("setName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			tableColumn := Column("tableName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			columnColumn := Column("columnName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			htmlColumn := Column("html" , "", False(), Text(), NoExtra(), NoKey(), None());

			classColumn := Column("class" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			attNameColumn := Column("attName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			primTypeColumn := Column("primType" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			typeMultiplicityColumn := Column("typeMultiplicity" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			classNameColumn := Column("className" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			setNameColumn := Column("setName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			directionColumn := Column("direction" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			tableNameColumn := Column("tableName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			oppAttColumn := Column("oppAttName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			isIdColumn := Column("isId" , "", False(), Bit(), NoExtra(), NoKey(), None());
			methodNameColumn := Column("methodName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			isObjectMethodColumn := Column("isObjectMethod" , "", False(), Bit(), NoExtra(), NoKey(), None());
			paramNameColumn := Column("paramName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			paramTypeColumn := Column("paramType" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			paramMultiplicityColumn := Column("paramMultiplicity" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			paramInOutColumn := Column("paramInOut" , "", False(), Varchar(10), NoExtra(), NoKey(), None());
			paramClassNameColumn := Column("paramClassName" , "", False(), Varchar(200), NoExtra(), NoKey(), None());
			paramSetNameColumn := Column("paramSetName" , "", False(), Varchar(200), NoExtra(), NoKey(), None())


	booster-to-metadata:
		x ->
			[setnames*, classnames*]
		where
			[setnames*] := <flatten-list><map(booster-to-metadata-sets)> <qsort(swap)><LookupTable> "SetDef";
			[classnames*] := <flatten-list><map(booster-to-metadata-classes)> <qsort(swap)><LookupTable> "Class"

	booster-to-metadata-sets:
		(setname, values) ->
			[ Insert(None(), None(), Into(), "_Meta_Sets", ["setName","tablename","columnName"], [String(setname),String(setname),String(setname)], None())] 

	booster-to-metadata-classes:
		(classname, cdef) ->
			[ Insert(None(), None(), Into(), "_Meta_Classes", ["className","tablename"], [String(classname),String(classname)], None()),
				attStmts*, methStmts*, paramStmts*] 
		where
			classAtts := <lookup-class-attributes> classname;
			[attStmts*] := <map(booster-to-metadata-attributes)> classAtts;
			classMeths := <lookup-class-methods> classname;
			[methStmts*] := <map(booster-to-metadata-method)> classMeths;
			[paramStmts*] := <map(booster-to-metadata-method-params)> classMeths
			

	booster-to-metadata-attributes:
		((classname, attname), (ds, t, opp, min, max, tname)) ->
			Insert(None(), None(), Into(), "_Meta_Attributes", 
						["class","attName","primType","typeMultiplicity","oppAttName","className","setName","direction","tableName","isId"], 
						[String(classname),String(attname),String(primType),String(typeMultiplicity),oppAttName,String(className),String(setName),String(direction),String(tableName),Int(isId)], None())
		where
			<calculate-table-name> (classname, attname);
			(primType, typeMultiplicity,className,setName) := <attribute-type-metadata> t;
			(direction, oppAttName) := <get-direction> (classname, attname);
			tableName := <lookup-attribute-table-name>(classname, attname);
			/* log(|Error(), "TableName", (tableName, classname, attname)); */
			isId := <((<elem> (Identity(), ds) ; !1 ) <+ !0)> ds

	booster-to-metadata-method:
		((classname, methodname), (c, gc, es, d, is, os))  ->
			Insert(None(), None(), Into(), "_Meta_Methods", 
						["class","methodName","isObjectMethod","html"], 
						[String(classname),String(methodname),isObjectMethod, String(html)], None())
		where
			isObjectMethod := <((<elem> (("this", Reference(classname)), is) ; !True() ) <+ !False())> is;
			html := <string-replace(|"'", "''")><constraint> c


	booster-to-metadata-method-params:
		((classname, methodname), (c, gc, es, d, is, os)) ->
			[istmts*,ostmts*]
		where
			[istmts*] := <map((\ i -> ((classname, methodname), "input", i) \) ; booster-to-metadata-param)> is ;
			[ostmts*] := <map((\ o -> ((classname, methodname), "output", o) \) ; booster-to-metadata-param)> os 
			/*log(|Error(),i*) */			

	booster-to-metadata-param:
		((classname, methodname), inout, (name, type)) ->
			Insert(None(), None(), Into(), "_Meta_Method_Params", 
						["class", "methodName", "paramName","paramType","paramMultiplicity","paramInOut","paramClassName", "paramSetName"], 
						[String(classname), String(methodname), String(name),String(paramPrimType), String(paramTypeMultiplicity),String(inout), String(paramClassName), String(paramSetName)], None())

		where
			(paramPrimType, paramTypeMultiplicity,paramClassName,paramSetName) := <attribute-type-metadata> type
						


	get-direction:
		(classname, attname)
			-> ("Bi", String(attname2))
		where
			(classname2, attname2) := <lookup-opposite>(classname, attname)

	get-direction:
		(classname, attname)
			-> ("Uni", Null())

	attribute-type-metadata:
		BasicType(t) -> 
			(desc,"Mandatory","","")
		where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Reference(name) -> ("ClassRef","Mandatory",name,"")
		where 
			<is-class-name> name
			
	attribute-type-metadata:
		Reference(name) -> ("SetValue","Mandatory","",name)
		where 
			<is-set-name> name

	attribute-type-metadata:
		Optional(BasicType(t)) -> 
			(desc,"Optional","","")
				where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Optional(Reference(name)) -> ("ClassRef","Optional",name,"")
		where 
			<is-class-name> name
			
	attribute-type-metadata:
		Optional(Reference(name)) -> ("SetValue","Optional","",name)
		where 
			<is-set-name> name
	
	attribute-type-metadata:
		Set(BasicType(t)) -> 
			(desc,"Set","","")
				where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Set(Reference(name)) -> ("ClassRef","Set",name,"")
		where 
			<is-class-name> name 
			
	attribute-type-metadata:
		Set(Reference(name)) -> ("SetValue","Set","",name)
		where 
			<is-set-name> name

	booster-to-relational-class:
		(cname, (dscs, ascs, as, ms, cs, wfs)) 
			-> Table(cname, [Column(identity , "", False(), Int(), AutoIncrement(), Primary(), None()), columns1*, columns2*])
		where 
			uniqueatts := <get-class-unique-atts> cname;
			[columns1*] := <filter(get-attribute-column)> uniqueatts;
			[columns2*] := <filter(get-inheritance-column)> <cart(id)> ([cname], dscs);
			//log(|Error(), "columns", [columns*]);
			/* log(|Error(), "columns", <filter(\((cname,aname), adef) -> ((cname,aname), adef) \)> <LookupTable> "Attribute"); */ 
			identity := <concat-strings> [cname, "Id"]

			
		
	booster-to-relational-procedure:
		((cname, mname), (c,gc,exts,d,is,os))
			-> Procedure(name, params, DeclareList([]), StatementList(statements))
		where
			name := <concat-strings> [cname, "_", mname];
			params := <nub><union> (<map(convert-input)>is, <map(convert-output)> os);
			statements := <booster-to-relational-guarded-command> gc

	booster-to-data-inserts:
		(name,values) 
			-> <union>([Insert(None(), None(), Into(), name, [name], [String("unassigned")], None())], stmts)
		where
			stmts := <map(\ value -> Insert(None(), None(), Into(), name, [name], [String(value)], None()) \)> values
			
	
			
	get-attribute-column:
		((cname, attname), (ds, BasicType(t), opp, 1, 1, tablename))
			-> Column(attname, "", False(), t', NoExtra(), NoKey(), None())
		where
			<updateAttributeTableName> (cname, attname, cname);
			t' := <get-type-booster-to-sql> t


	get-attribute-column:
		((cname, attname), (ds, Reference(tname), opp, 1, 1, tablename))
			-> Column(attname, "", False(), Varchar(200), NoExtra(), NoKey(),Some(Reference(tname, [tname])))
		where
			<is-set-name> tname;
			<updateAttributeTableName> (cname, attname,cname)

	get-attribute-column:
		((cname, attname), (ds, Reference(tname), opp, 1, 1, tablename))
			-> Column(attname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>([cname, "Id"])])))
		where
			<is-class-name> tname;
			not(<lookup-opposite>(cname, attname));
			<updateAttributeTableName> (cname, attname,cname)
	
	get-attribute-column:
		((cname, attname), (ds, Optional(BasicType(t)), opp, 0, 1, tablename))
			-> Column(attname, "null", True(), t', NoExtra(), NoKey(), None())
		where
			<updateAttributeTableName> (cname, attname, cname);
			t' := <get-type-booster-to-sql> t


	get-attribute-column:
		((cname, attname), (ds, Optional(Reference(tname)), opp, 0, 1, tablename))
			-> Column(attname, "null", True(), Varchar(200), NoExtra(), NoKey(),Some(Reference(cname, [cname])))
		where
			<is-set-name> tname;
			<updateAttributeTableName> (cname, attname,cname)

	get-attribute-column:
		((cname, attname), (ds, Optional(Reference(tname)), opp, 0, 1, tablename))
			-> Column(attname, "null", True(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>([cname, "Id"])])))
		where
			<is-class-name> tname;
			not(<lookup-opposite>(cname, attname));
			<updateAttributeTableName> (cname, attname, cname)

	get-inheritance-column:
		(class, subclass)
			-> Column(subclasstableid, "", True(), Int(), NoExtra(), NoKey(),Some(Reference(subclass, [subclasstableid])))
		where
			subclasstableid := <concat-strings>([subclass, "Id"]);
			classtableid := <concat-strings>([class, "Id"])					
			
	get-assoc-table:
		((cname, attname), (ds, t, (oname, oaname), min, max, tn))
			-> Table(tablename, [Column(tableid, "", False(), Int(), AutoIncrement(), Primary(), None()), 
								 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
								 Column(secondcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(oname, [<concat-strings>[oname, "Id"]])))])
		where
			//log(|Error(), "get-assoc-table", (cname, attname));
			<(?Reference(oname) <+ ?Optional(Reference(oname)) <+ ?Set(Reference(oname)))> t;
			//log(|Error(), "get-assoc-table 1", (cname, attname));
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "_", attname];			
			secondcolname := <concat-strings> [oname, "_", oaname];
			tableid := <concat-strings> [tablename, "Id"];
			<updateAttributeTableName> (cname, attname, tablename)

	get-assoc-table:
		((cname, attname), (ds, Set(BasicType(t)), opp, min, max, tn))
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), t', NoExtra(), NoKey(),None())])
		where
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			t' := <get-type-booster-to-sql> t;
			<updateAttributeTableName> (cname, attname, tablename)
			

	get-assoc-table:
		((cname, attname), (ds, Set(Reference(tname)), opp, min, max, tn))
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), Varchar(200), NoExtra(), NoKey(),Some(Reference(tname, [tname])))])
		where
			<is-set-name> tname;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			<updateAttributeTableName> (cname, attname, tablename)
			
	get-assoc-table:
		((cname, attname), (ds, Set(Reference(tname)), opp, min, max, tn))
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(tname, [<concat-strings>([tname, "Id"])])))])
		where
			<is-class-name> tname;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			<updateAttributeTableName> (cname, attname, tablename)

/*    get-assoc-table:
    	something -> Table("",[]) 
    		where 
    		log(|Error(), "cannot find assoc table", something)
*/
			
	get-set-table:
		(name, [values*])
			-> Table(name, [Column(name, "unassigned", False(), Varchar(100), NoExtra(), Primary(),None())])

			
	convert-input:
		(name, BasicType(t))
			-> Input(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-input:
		(name, Optional(BasicType(t)))
			-> Input(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-input:
		(name, Reference(tname))
			-> Input(name, Varchar(100))
		where
			<is-set-name> tname

	convert-input:
		(name, Reference(cname))
			-> Input(name, Int())

	convert-input:
		(name, Optional(Reference(cname)))
			-> Input(name, Int())

	convert-output:
		(name, BasicType(t))
			-> Output(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-output:
		(name, Reference(tname))
			-> Output(name, Varchar(100))
		where
			<is-set-name> tname

	convert-output:
		(name, Reference(cname))
			-> Output(name, Int())



			 	
	booster-to-relational-guarded-command:
		Skip()
			-> [ VariableAssign("dummySkip", Int(1)) ]
			
			

	booster-to-relational-guarded-command:
		Assign(Path(ps {Optional(Reference(tablename))}, pc){t}, expr)
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				pn' := <path-to-variable-name> Path(ps {Optional(Reference(tablename))}, pc){t};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-path-to-where-clause> Path(ps {Optional(Reference(tablename))}, pc){t}

	booster-to-relational-guarded-command:
		Assign(path, BinOp(Path(ps { Reference(classname')}, pc), Union(), SetExtent([expr])))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), IfThen(	Equal( Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
													  	Equal(ColumnName(column2), LocalVariable(pn2)))), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()), 
								  Int(0)), 
						StatementList([Insert(None(), None(), Into(), tablename, [column1, column2], [LocalVariable(pn1), LocalVariable(pn2)], None())]),
						[],
						None()
					)]				
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> ps;
				expr2 := <booster-to-relational-expression> expr 

	booster-to-relational-guarded-command:
		Assign(path, BinOp(Path(ps { Optional(Reference(classname'))}, pc), Union(), SetExtent([expr])))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), IfThen(	Equal( Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
													  	Equal(ColumnName(column2), LocalVariable(pn2)))), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()), 
								  Int(0)), 
						StatementList([Insert(None(), None(), Into(), tablename, [column1, column2], [LocalVariable(pn1), LocalVariable(pn2)], None())]),
						[],
						None()
					)]				
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> ps;
				expr2 := <booster-to-relational-expression> expr 

	booster-to-relational-guarded-command:
		Assign(path, BinOp(Path(ps { Reference(classname')}, pc), Minus(), SetExtent([expr])))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), Delete(	None(), None(), None(), 
						tablename, 
						Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
									Equal(ColumnName(column2), LocalVariable(pn2)))), 
						None(), None())]
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> ps;
				expr2 := <booster-to-relational-expression> expr 

	booster-to-relational-guarded-command:
		Assign(path, BinOp(Path(ps { Optional(Reference(classname'))}, pc), Minus(), SetExtent([expr])))
			-> [VariableAssign(pn1, expr1), VariableAssign(pn2, expr2), Delete(	None(), None(), None(), 
						tablename, 
						Where(And(	Equal(ColumnName(column1), LocalVariable(pn1)),
									Equal(ColumnName(column2), LocalVariable(pn2)))), 
						None(), None())]
			where 
				pn' := <path-to-variable-name> path;
				pn1 := <concat-strings>[pn', "_1"];
				pn2 := <concat-strings>[pn', "_2"];
				attname := <get-path-attribute-name> path;
				tablename := <lookup-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> ps;
				expr2 := <booster-to-relational-expression> expr 

	booster-to-relational-guarded-command:
		Assign(Path(ps { Reference(tablename) }, pc){t}, expr)
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, FunctionCall("SHA2", [LocalVariable(pn'),Int(512)]))],Where(expr''),None(),None())]
			where 
				<?BasicType(Password()) <+ ?Optional(BasicType(Password()))> t;
				pn' := <path-to-variable-name> Path(ps { Reference(tablename) }, pc){BasicType(t)};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-path-to-where-clause> Path(ps { Reference(tablename) }, pc){BasicType(t)}

	booster-to-relational-guarded-command:
		Assign(Path(ps { Reference(cname) }, pc){BasicType(t)}, expr)
			-> [VariableAssign(pn', expr'), Update([],
				tr,[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				pn' := <path-to-variable-name> Path(ps { Reference(cname) }, pc){BasicType(t)};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-path-to-where-clause> Path(ps { Reference(cname) }, pc){BasicType(t)};
				tr := <get-table-reference> cname

	booster-to-relational-guarded-command:
		Assign(Path(ps { Reference(tablename) }, pc){Optional(BasicType(t))}, expr)
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				pn' := <path-to-variable-name> Path(ps { Reference(tablename) }, pc){Optional(BasicType(t))};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-path-to-where-clause> Path(ps { Reference(tablename) }, pc){BasicType(t)}

	booster-to-relational-guarded-command:
		Assign(Path(ps { Reference(tablename) }, pc){Reference(t)}, expr)
			-> [VariableAssign(pn', expr'), Update([],
				TableName(tablename),[(attname, LocalVariable(pn'))],Where(expr''),None(),None())]
			where 
				<is-set-name> t;
				pn' := <path-to-variable-name> Path(ps { Reference(tablename) }, pc){Reference(t)};
				attname := <get-path-attribute-name> Path(ps, pc);
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-path-to-where-clause> Path(ps { Reference(tablename) }, pc){Reference(t)}
				
	booster-to-relational-guarded-command:
		Assign(Path(ps { Reference(classname') }, PathComponent(attname, None())){Reference(t)}, expr)
			-> [VariableAssign(png, Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(Equal(ColumnName(column1), expr'')), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None())), 
				VariableAssign(pn', expr'), 
				IfThen(NotEqual( LocalVariable(png), Int(0)), 
						StatementList([	Update([], TableName(tablename),[(oppattname, LocalVariable(pn'))],Where(expr'''),None(),None())]),
						[],
						StatementList([Insert(None(), None(), Into(), tablename, [column1, oppattname], [expr'', LocalVariable(pn')], None())])
						)]
				
				
			where 
				<is-class-name> t;
				pn' := <path-to-variable-name> Path(ps { Reference(classname') }, PathComponent(attname, None())){Optional(Reference(t))};
				png := <concat-strings>[pn', "_guard"];
				tablename := <concat-strings>[classname', "_", attname];
				column1 := <concat-strings>[classname', "_", attname];
				//log(|Error(), "guarded-command to relational", tablename);
				(cname', aname') := <lookup-opposite> (classname', attname);
				oppattname := <concat-strings>[cname', "_", aname'];
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-to-relational-expression> ps { Reference(classname') };
				expr''' := <booster-path-to-where-clause> Path(ps { Reference(classname') }, PathComponent(attname, None())){Reference(t)}

	booster-to-relational-guarded-command:
		Assign(Path(ps { Reference(classname') }, PathComponent(attname, None())){Optional(Reference(t))}, expr)
			-> [VariableAssign(png, Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(Equal(ColumnName(column1), expr'')), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None())),
				VariableAssign(pn', expr'), 
				IfThen(NotEqual( LocalVariable(png), Int(0)), 
						StatementList([	Update([], TableName(tablename),[(oppattname, LocalVariable(pn'))],Where(expr'''),None(),None())]),
						[],
						StatementList([Insert(None(), None(), Into(), tablename, [column1, oppattname], [expr'', LocalVariable(pn')], None())])
						)]
				
				
			where 
				<is-class-name> t;
				pn' := <path-to-variable-name> Path(ps { Reference(classname') }, PathComponent(attname, None())){Optional(Reference(t))};
				png := <concat-strings>[pn', "_guard"];
				tablename := <concat-strings>[classname', "_", attname];
				column1 := <concat-strings>[classname', "_", attname];
				//log(|Error(), "guarded-command to relational", tablename);
				(cname', aname') := <lookup-opposite> (classname', attname);
				oppattname := <concat-strings>[cname', "_", aname'];
				expr' := <booster-to-relational-expression> expr;
				expr'' := <booster-to-relational-expression> ps { Reference(classname') };
				expr''' := <booster-path-to-where-clause> Path(ps { Reference(classname') }, PathComponent(attname, None())){Reference(t)}
				
	booster-to-relational-guarded-command:
		New(Output(obj), PathStart(cls, None()))
			-> [Insert(None(), None(), Into(), cls, [], [], None()),
				Select([],[FunctionCall("LAST_INSERT_ID", [])], None(), None(), None(), None(), None(), None(), None(), Some(Into([Output(obj)])), None()),
				subclassesinserts*]
			where
			directSubclasses := <\ (ds,_,_,_,_,_) -> ds \> <lookup>(cls, <LookupTable> "Class");
			[subclassesinserts*] := <concat><map(\c -> <create-class>(cls, c, Output(obj))\)> directSubclasses
	

	create-class:
		(classname, subclassname, thisIdExpr)
			 -> [Insert(None(), None(), Into(), subclassname, [], [], None()),
			 	 Select([],[FunctionCall("LAST_INSERT_ID", [])], None(), None(), None(), None(), None(), None(), None(), Some(Into([LocalVariable(subclassnamepk)])), None()),
				 Update([], TableName(classname),[(subclassnameid, LocalVariable(subclassnamepk))],Where(Equal(ColumnName(classnameid), thisIdExpr)),None(),None()),
				 subclassesinserts*]
			where
			subclassnamepk := <concat-strings>[subclassname, "_PK"];
			classnameid := <concat-strings>[classname, "Id"];
			subclassnameid := <concat-strings>[subclassname, "Id"];
			directSubclasses := <\ (ds,_,_,_,_,_) -> ds \> <lookup>(subclassname, <LookupTable> "Class");
			[subclassesinserts*] := <concat><map(\c -> <create-class>(subclassname, c, LocalVariable(subclassnamepk))\)> directSubclasses
			


	booster-to-relational-guarded-command:
		Guard(const, gc)
			-> [IfThen(expr', StatementList([stmts*]),[],None())]
		where
			[stmts*] := <booster-to-relational-guarded-command> gc;
			expr' := <booster-to-relational-constraint> const

	booster-to-relational-guarded-command:
		Parallels(xs)
			-> <booster-to-relational-guarded-command> Parallels(ys)
		where
			(creates, non-creates) := <partition(?New(_, _))> xs;
			ys := <concat>[creates, non-creates];
			<not(equal)>(xs, ys)



	booster-to-relational-guarded-command:
		Parallels([x])
			-> <booster-to-relational-guarded-command> x

	booster-to-relational-guarded-command:
		Parallels([x, xs*])
			-> [BeginEnd(DeclareList([]), StatementList([decs*, stmts*]))]
		where
			[stmts1*] := <booster-to-relational-guarded-command> x;
			[stmts2*] := <booster-to-relational-guarded-command> Parallels([xs*]);
			([decs*], [stmts*]) := <partition(?VariableAssign(_, _))> [stmts1*, stmts2*] 
			

	booster-to-relational-guarded-command:
		Sequence(gc1,gc2)
			-> [BeginEnd(DeclareList([]), StatementList(stmts1)),BeginEnd(DeclareList([]), StatementList(stmts2))]
		where
			stmts1 := <booster-to-relational-guarded-command> gc1;
			stmts2 := <booster-to-relational-guarded-command> gc2 		

	booster-to-relational-guarded-command:
		Choice(Guard(constraint1, gc1),Guard(constraint2, Skip()))
			-> [IfThen(expr1, StatementList(stmts1),[],None())]
		where
			expr1 := <booster-to-relational-constraint> constraint1;
			stmts1 := <booster-to-relational-guarded-command> gc1 		


	booster-to-relational-guarded-command:
		Choice(Guard(constraint1, gc1),Guard(constraint2, gc2))
			-> [IfThen(expr1, StatementList(stmts1),[ElseIf(expr2,StatementList(stmts2) )],None())]
		where
			expr1 := <booster-to-relational-constraint> constraint1;
			expr2 := <booster-to-relational-constraint> constraint2;
			stmts1 := <booster-to-relational-guarded-command> gc1;
			stmts2 := <booster-to-relational-guarded-command> gc2 		

	booster-to-relational-guarded-command:
		Choice(gc1,gc2)
			-> [IfThen(True(), StatementList(stmts1),[],StatementList(stmts2))]
		where
			stmts1 := <booster-to-relational-guarded-command> gc1;
			stmts2 := <booster-to-relational-guarded-command> gc2 		



	booster-to-relational-guarded-command:
		gc
			-> []
		where
			log(|Error(), "cannot convert guarded command", gc);
			log(|Error(), "guarded command: ", <guardedCommand> gc)


	booster-to-relational-constraint:
		True()
			-> True()

	booster-to-relational-constraint:
		False()
			-> False()

	booster-to-relational-constraint:
		Not(const)
			-> Not(const')
		where
			const' := <booster-to-relational-constraint> const

	booster-to-relational-constraint:
		Conjuncts([const])
			-> <booster-to-relational-constraint> const

	booster-to-relational-constraint:
		Conjuncts([const, consts*])
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> const;
			const2' := <booster-to-relational-constraint> Conjuncts([consts*])

	booster-to-relational-constraint:
		Conjuncts([])
			-> True()

	booster-to-relational-constraint:
		And(const1, const2)
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> const1;
			const2' := <booster-to-relational-constraint> const2

	booster-to-relational-constraint:
		Or(const1, const2)
			-> Or(const1', const2')
		where
			const1' := <booster-to-relational-constraint> const1;
			const2' := <booster-to-relational-constraint> const2

	booster-to-relational-constraint:
		Implies(const1, const2)
			-> Or(const2', Not(const1'))
		where
			const1' := <booster-to-relational-constraint> const1;
			const2' := <booster-to-relational-constraint> const2

	booster-to-relational-constraint:
		Then(const1, const2)
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> const1;
			const2' := <booster-to-relational-constraint> const2


	booster-to-relational-constraint:
		BinRel(expr1, Equal(), Null())
			-> IsNull(expr1',None())
		where
			expr1' := <booster-to-relational-expression> expr1

	booster-to-relational-constraint:
		BinRel(expr1, Equal(), expr2)
			-> Equal(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, NotEqual(), Null())
			-> IsNull(expr1', Not())
		where
			expr1' := <booster-to-relational-expression> expr1

	booster-to-relational-constraint:
		BinRel(expr1, NotEqual(), expr2)
			-> NotEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, In(), TypeExtent(t))
			-> True()

	booster-to-relational-constraint:
		BinRel(Output(o), NotIn(), PathStart(cname, maybeprimed){Set(Reference(cname))})
			-> True()
			where
				<is-class-name> cname
				



	booster-to-relational-constraint:
		BinRel(expr1, In(), PathStart(cname, maybeprimed){Set(Reference(cname))})
			-> NotEqual( Select([],
										[FunctionCall("count", [Star()])], 
										Some(FromPart([TableName(cname)])), 
										Where(Equal(ColumnName(column1), expr')),
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None()), 
							  Int(0))
			where
				<is-class-name> cname;
				column1 := <concat-strings>[cname, "Id"];
				expr' := <booster-to-relational-expression> expr1

	booster-to-relational-constraint:
		BinRel(expr1, In(), PathStart(sname, maybeprimed){Set(Reference(sname))})
			-> NotEqual( Select([],
										[FunctionCall("count", [Star()])], 
										Some(FromPart([TableName(sname)])), 
										Where(Equal(ColumnName(sname), expr')),
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None()), 
							  Int(0))
			where
				<is-set-name> sname;
				expr' := <booster-to-relational-expression> expr1

				


	booster-to-relational-constraint:
		BinRel(expr1, In(), Path(ps {Reference(cname)}, PathComponent(attname, maybeprimed)){Set(Reference(t))})
			-> NotEqual( Select([],
										[FunctionCall("count", [Star()])], 
										Some(FromPart([TableName(tablename)])), 
										Where(And(Equal(ColumnName(column1), expr''),
												  Equal(ColumnName(column2), expr'))), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None()), 
							  Int(0))
				
				
			where
				<is-class-name> t;
				tablename := <concat-strings>[cname, "_", attname];
				column1 := <concat-strings>[cname, "_", attname];
				expr' := <booster-to-relational-expression> expr1;
				(cname', aname') := <lookup-opposite> (cname, attname);
				column2 := <concat-strings>[cname', "_", aname'];
				expr'' := <booster-to-relational-expression> ps { Reference(cname) }

	booster-to-relational-constraint:
		BinRel(expr1, NotIn(), Path(ps {Reference(cname)}, PathComponent(attname, maybeprimed)){Set(Reference(t))})
			-> Equal( Select([],
										[FunctionCall("count", [Star()])], 
										Some(FromPart([TableName(tablename)])), 
										Where(And(Equal(ColumnName(column1), expr''),
												  Equal(ColumnName(column2), expr'))), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None(), 
										None()), 
							  Int(0))
				
				
			where
				<is-class-name> t;
				tablename := <concat-strings>[cname, "_", attname];
				column1 := <concat-strings>[cname, "_", attname];
				expr' := <booster-to-relational-expression> expr1;
				(cname', aname') := <lookup-opposite> (cname, attname);
				column2 := <concat-strings>[cname', "_", aname'];
				expr'' := <booster-to-relational-expression> ps { Reference(cname) }


	booster-to-relational-constraint:
		BinRel(expr1, In(), expr2)
			-> InSet(expr1', None(), expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, NotIn(), expr2)
			-> InSet(expr1', Not(), expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, LessThan(), expr2)
			-> LessThan(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, GreaterThan(), expr2)
			-> GreaterThan(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, LessThanEquals(), expr2)
			-> LessThanEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		BinRel(expr1, GreaterThanEquals(), expr2)
			-> GreaterThanEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-constraint:
		Forall(var, Path(ps {Reference(cname)}, PathComponent(attname, None())){Set(t)}, constraint)
			-> Equal( Select([],
							[FunctionCall("count", [Star()])], 
							Some(FromPart([TableName(tablename)])), 
							Where(Not(And(Equal(ColumnName(column1), expr''),
									const'''))), 
							None(), 
							None(), 
							None(), 
							None(), 
							None(), 
							None(), 
							None()), 
					Int(0))
			where
				tablename := <concat-strings>[cname, "_", attname];
				column1 := <concat-strings>[cname, "_", attname];
				expr'' := <booster-to-relational-expression> ps { Reference(cname) };
				const' := <literal-substitute> (constraint, [(PathStart(var, None()), Input(var){t})]);
				sysvar := <concat-strings>[var, "_in"];
				const'' := <booster-to-relational-constraint> const';
				(cname', aname') := <lookup-opposite> (cname, attname);
				oppattname := <concat-strings>[cname', "_", aname'];
				const''' := <literal-substitute> (const'', [(SystemVariable(sysvar), ColumnName(oppattname))])

	booster-to-relational-constraint:
		constraint
			-> True()
		where
			log(|Error(), "cannot convert constraint", constraint)

	booster-to-relational-expression:
		BasicValue(String(str))
			-> String(str)

	booster-to-relational-expression:
		BasicValue(Integer(i))
			-> Int(i)

	booster-to-relational-expression:
		BasicValue(Decimal(d))
			-> Decimal(d)

	booster-to-relational-expression:
		BasicValue(True())
			-> Int(1)

	booster-to-relational-expression:
		BasicValue(False())
			-> Int(0)

	booster-to-relational-expression:
		PathStart(v, None()) {Reference(sn)}
			-> String(v)
		where
			<is-set-name> sn

	booster-to-relational-expression:
		PathStart(v, None()) {Optional(Reference(sn))}
			-> String(v)
		where
			<is-set-name> sn


	booster-to-relational-expression:
		BasicValue(CurrentDateTime())
			-> FunctionCall("NOW", [])

	booster-to-relational-expression:
		BasicValue(CurrentDate())
			-> FunctionCall("CURDATE", [])

	booster-to-relational-expression:
		BasicValue(CurrentTime())
			-> FunctionCall("CURTIME", [])



	booster-to-relational-expression:
		TypeExtent(t)
			-> Null()


	booster-to-relational-expression:
		Null()
			-> Null()

	booster-to-relational-expression:
		SetExtent(exprs)
			-> SetExpression(exprs)

	booster-to-relational-expression:
		Input(n)
			-> SystemVariable(m)
		where 
			m := <concat-strings>[n, "_in"]

	booster-to-relational-expression:
		Output(n)
			-> SystemVariable(m)
		where 
			m := <concat-strings>[n, "_out"]

	booster-to-relational-expression:
		This()
			-> SystemVariable("this")

	booster-to-relational-expression:
		ThisPrimed()
			-> Null()
			
	booster-to-relational-expression:
		Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {t}
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			< ?BasicType(b) <+ ?Optional(BasicType(b))> t;
			expr :=  <booster-to-relational-expression> p

	booster-to-relational-expression:
		Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {Reference(sn)}
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			<is-set-name> sn;
			expr :=  <booster-to-relational-expression> p

	booster-to-relational-expression:
		Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {Optional(Reference(sn))}
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			<is-set-name> sn;
			expr :=  <booster-to-relational-expression> p
			
	booster-to-relational-expression:
		Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {t}
		// select name from class where classId = expr
			-> Select([], [ColumnName(oppcname)], Some(FromPart([TableName(tname)])), 
						  Where(Equal(expr, ColumnName(cname))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(),
						  None())
		where
			< ?Optional(Reference(b)) <+ ?Reference(b)> t;
			expr :=  <booster-to-relational-expression> p;
			tname := <concat-strings>[c, "_",name];
			cname := tname;
			(classname', attname') := <lookup-opposite> (c, name); 
			oppcname := <concat-strings>[classname', "_", attname']
				 				
	booster-to-relational-expression:
		Path(p {Reference(c)}, PathComponent(name, maybePrimed)) {t}
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(tname)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[tname, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			expr :=  <booster-to-relational-expression> p;
			tname := <concat-strings>[c, "_",name];
			< ?Set(b)> t
				 				



	booster-to-relational-expression:
		BinOp(expr1, Plus(), expr2)
			-> Plus(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-expression:
		BinOp(expr1, Minus(), expr2)
			-> Minus(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-expression:
		BinOp(expr1, Times(), expr2)
			-> Multiply(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-expression:
		BinOp(expr1, Divide(), expr2)
			-> Divide(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> expr1;
			expr2' := <booster-to-relational-expression> expr2

	booster-to-relational-expression:
		UnOp(Cardinality(), (Path(ps{Reference(cname)}, PathComponent(aname, maybeprimed)){Set(Reference(t))}))
			-> Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(expr'), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None())
		where
			tablename := <concat-strings>[cname, "_", aname];
			expr' := <booster-path-to-where-clause> (Path(ps{Reference(cname)}, PathComponent(aname, maybeprimed)){Set(Reference(t))})
			

	booster-to-relational-expression:
		expr
			-> Null()
		where
			log(|Error(), "cannot convert expression", expr)


	booster-path-to-where-clause:
		Path(p {Reference(cname)}, PathComponent(name, None())){t}
			-> Equal(expr, ColumnName(<concat-strings>[cname, "Id"]))
		where 
			< ?BasicType(t') <+ ?Optional(BasicType(t')) <+ ?Reference(t') ; <is-set-name> t'> t;
			expr := <booster-to-relational-expression> p


	booster-path-to-where-clause:
		Path(p {Reference(cname)}, PathComponent(attname, None())){t}
			-> Equal(expr, ColumnName(<concat-strings>[cname, "_",attname]))
		where 
			expr := <booster-to-relational-expression> p
	
	
	
	booster-path-to-where-clause:
		Output(n)
			-> True()

	booster-path-to-where-clause:
		This()
			-> True()

	booster-path-to-where-clause:
		ThisPrimed()
			-> True()
	
	remove-inputs: 
		(c,is) ->
			<topdown(\ trm -> <remove-input <+ !trm> (trm, is) \)> c

	remove-outputs: 
		(c,os) ->
			<topdown(\ trm -> <remove-output <+ !trm> (trm, os) \)> c

	remove-inputs-and-outputs: 
		(c,ios) ->
			<topdown(\ trm -> <remove-output <+ !trm> (trm, ios) \)>
				<topdown(\ trm -> <remove-input <+ !trm> (trm, ios) \)> c

	
	remove-input:
		(BinRel(exp1, relop, exp2), is) -> True() 
			where 
				is' := <collect-all(?Input(i))> BinRel(exp1, relop, exp2);
				<not(subseteq)>(is', is)

	remove-output:
		(BinRel(exp1, relop, exp2), os) -> True() 
			where 
				os' := <collect-all(?Output(o))> BinRel(exp1, relop, exp2);
				<not(subseteq)>(os', os)
	
	availability-procedure:
		((cname, mname), (c,gc,exts,d,is,os))
			-> [Function(name1, params1, Bit(), DeclareList([]), StatementList(statements1)),
				Function(name2, params2, Bit(), DeclareList([]), StatementList(statements2)),
				is-procs*]
		where
			// Function to test the availability without inputs
			name1 := <concat-strings> [cname, "_", mname, "_available"];
			params1 := [Input("this", Int())];
			guard-without-inputs := <innermost(simplify)><(\ Guard(c, p) -> <remove-inputs-and-outputs> (c, []) \) <+ !True() >  gc;
			// log(|Error(), "guard-without-inputs", <constraint> guard-without-inputs);
			statements1 := [
				IfThen(<booster-to-relational-constraint> guard-without-inputs, 
					StatementList([Return(Int(1))]), 
					[], 
					StatementList([Return(Int(0))]))
				];
			// Function to test the availability with inputs
			name2 := <concat-strings> [cname, "_", mname, "_available_inputs"];
			params2 := <map(convert-input)>is;
			guard := <innermost(simplify)><(\ Guard(c, p) -> <remove-outputs> (c, [])\) <+ !True() >  gc;
			statements2 := [
				IfThen(<booster-to-relational-constraint> guard, 
					StatementList([Return(Int(1))]), 
					[], 
					StatementList([Return(Int(0))]))
				];
			// Procedures to return the applicable object references
			class-is := <filter(is-object-ref)> is;
			[is-procs*] := <map(\ i -> <procedure-to-get-applicable-references> ((cname, mname), gc, i)\)> class-is
			

is-object-ref:
	(i, Reference(t))
		-> Input(i){Reference(t)}
	where
		<not(equal)>(i, "this");
		<is-class-name> t
		
is-object-ref:
	(i, Optional(Reference(t)))
		-> Input(i){Optional(Reference(t))}
	where
		<not(equal)>(i, "this");
		<is-class-name> t

get-reference-class-name:
	Optional(Reference(t)) -> t

get-reference-class-name:
	Reference(t) -> t
		
procedure-to-get-applicable-references:
	((cname, mname), gc, Input(i){type})
		-> Procedure(name, params, DeclareList([]), StatementList(statements))
	where
		tname := <get-reference-class-name> type;
		name := <concat-strings> [cname, "_", mname,"_",i,"_choice"];
		params := [Input("this", Int())];
		guard-without-inputs := <innermost(simplify)><(\ Guard(c, p) -> <remove-inputs-and-outputs> (c,[Input(i){type}])\) <+ !True() >  gc;
		//log(|Error(), "available-references", <constraint> guard-without-inputs);
		tidname := <concat-strings> [tname, "Id"];
		dummyVariable := <concat-strings>["dummyVariable_",tidname];
		expr' := <booster-to-relational-constraint> guard-without-inputs;
		//log(|Error(), expr');
		expr'' := <literal-substitute> (expr', [(SystemVariable(<concat-strings>[i, "_in"]), TableColumnName(dummyVariable, tidname))]);
		//log(|Error(), "get-applicable-references", (cname, mname, <constraint> guard-without-inputs));
		statements := [InsertInto(
							"CLASS_DESCS", 
							["OBJECT_ID"], 
							Select([],
									[ColumnName(tidname)], 
											Some(FromPart([Aliased(tname, Alias(dummyVariable), [])])), 
											Where(expr''), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()))]

function-to-get-id:
	cname
		-> Function(functionName, [Input("this", Int())], Varchar(10000), DeclareList([]), StatementList([returnStatement]))
	where
		functionName := <concat-strings>["get_", cname,"_desc"];
		returnStatement := Return(<get-object-desc> (cname, This(){Reference(cname)}))

	
path-to-variable-name:
	PathStart(name, maybeprimed)
		-> <concat-strings>["path_", name]

path-to-variable-name:
	Path(p, PathComponent(att, maybeprimed))
		-> <concat-strings>[<path-to-variable-name> p, "_", att]

path-to-variable-name:
	This()
		-> "path_this"

path-to-variable-name:
	Input(i)
		-> <concat-strings>["path_", i, "_in"]

path-to-variable-name:
	Output(o)
		-> <concat-strings>["path_", o, "_out"]

		
get-table-reference:
	cname 
		-> TableName(cname)
	where
		([],_,_,_,_,_) := <lookup>(cname, <LookupTable> "Class")

get-table-reference:
	cname 
		-> tr
	where
		(is,_,_,_,_,_) := <lookup>(cname, <LookupTable> "Class");
		tr := <foldl(\ (cn1,t1) -> InnerJoin(<get-table-reference> cn1, t1, On(Equal(TableColumnName(cname, attname), TableColumnName(cn1, attname)))) where attname := <concat-strings>[cn1,"Id"]\)> (is, TableName(cname))
		
get-object-desc:
	(cname, objIdExpr)
		-> FunctionCall("concat_ws", <union>([String(",")], exprs))
	where
		idatts := <get-class-ids> cname;
		exprs := <map(\ ((c,a), (_,t,_,_,_,_)) -> <booster-to-relational-expression> Path(objIdExpr {Reference(c)}, PathComponent(a, None())) {t}\)> idatts
		/* ;
		log(|Error(), exprs) */

calculate-table-name:
	(cname, aname) 
		-> (cname, aname)
	where
		superclasses := <get-class-superclasses> cname;
		[tname] := <filter(\ sc -> sc where <lookup>((sc, aname), <LookupTable>"Attribute"); 
											[] := <filter(\ sc' -> sc' where <lookup>((sc', aname), <LookupTable>"Attribute")\)> <get-class-superclasses> sc  \)>
											<conc> ([cname], superclasses); 
		<updateAttributeTableName>(cname, aname, tname)
	
		
	