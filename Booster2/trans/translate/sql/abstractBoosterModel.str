module translate/sql/abstractBoosterModel 

imports
  include/Booster2
  library/valueExpression
  
  library/lookupTable
  library/abstractBoosterModel
  library/strategy

  library/basicTypes
  library/environment
  

 rules
 		booster-to-relational:	
		x -> Schema(<LookupTable> "Name", [ metatables*, settables*, tables*, tables'* ], [procedures*], StatementList([metaStatements*, statements*]))
		 where
			[metatables*] := <booster-to-metatables> x; 
			[tables*] := <map(booster-to-relational-class)> <LookupTable> "Class" ;
			[tables'*] := <filter(get-assoc-table)> <LookupTable> "Attribute" ;
			[settables*] := <map(get-set-table)> <LookupTable> "SetDef" ;
			[procedures*] := <map(booster-to-relational-procedure)> <LookupTable> "Method" ;
			[metaStatements*] := <booster-to-metadata> x;
			[statements*] := <concat><map(booster-to-data-inserts)> <LookupTable> "SetDef" 
			 
	booster-to-metatables:
		x ->
			[Table("_Meta_Classes", [idColumn, nameColumn, tableColumn]),
			 Table("_Meta_Sets", [idColumn, setColumn, tableColumn, columnColumn]),
			 Table("_Meta_Attributes", [idColumn, classColumn, attNameColumn, primTypeColumn, typeMultiplicityColumn, classNameColumn, setNameColumn, directionColumn, tableNameColumn, oppAttColumn, isIdColumn]),
			 Table("_Meta_Methods", [idColumn, classColumn, methodNameColumn, isObjectMethodColumn]),
			 Table("_Meta_Method_Params", [idColumn, classColumn, methodNameColumn, paramNameColumn, paramTypeColumn, paramMultiplicityColumn, paramInOutColumn, paramClassNameColumn, paramSetNameColumn])]

		where
			idColumn := Column("id" , "", False(), Int(), AutoIncrement(), Primary(), None());
			nameColumn := Column("className" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			setColumn := Column("setName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			tableColumn := Column("tableName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			columnColumn := Column("columnName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());

			classColumn := Column("class" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			attNameColumn := Column("attName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			primTypeColumn := Column("primType" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			typeMultiplicityColumn := Column("typeMultiplicity" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			classNameColumn := Column("className" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			setNameColumn := Column("setName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			directionColumn := Column("direction" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			tableNameColumn := Column("tableName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			oppAttColumn := Column("oppAttName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			isIdColumn := Column("isId" , "", False(), Bit(), NoExtra(), NoKey(), None());
			methodNameColumn := Column("methodName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			isObjectMethodColumn := Column("isObjectMethod" , "", False(), Bit(), NoExtra(), NoKey(), None());
			paramNameColumn := Column("paramName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramTypeColumn := Column("paramType" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramMultiplicityColumn := Column("paramMultiplicity" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramInOutColumn := Column("paramInOut" , "", False(), Varchar(10), NoExtra(), NoKey(), None());
			paramClassNameColumn := Column("paramClassName" , "", False(), Varchar(500), NoExtra(), NoKey(), None());
			paramSetNameColumn := Column("paramSetName" , "", False(), Varchar(500), NoExtra(), NoKey(), None())


	booster-to-metadata:
		x ->
			[setnames*, classnames*]
		where
			[setnames*] := <flatten-list><map(booster-to-metadata-sets)> <LookupTable> "SetDef";
			[classnames*] := <flatten-list><map(booster-to-metadata-classes)> <LookupTable> "Class"

	booster-to-metadata-sets:
		(setname, values) ->
			[ Insert(None(), None(), Into(), "_Meta_Sets", ["setName","tablename","columnName"], [String(setname),String(setname),String(setname)], None())] 

	booster-to-metadata-classes:
		(classname, cdef) ->
			[ Insert(None(), None(), Into(), "_Meta_Classes", ["className","tablename"], [String(classname),String(classname)], None()),
				attStmts*, methStmts*, paramStmts*] 
		where
			classAtts := <lookup-class-attributes> classname;
			[attStmts*] := <map(booster-to-metadata-attributes)> classAtts;
			classMeths := <lookup-class-methods> classname;
			[methStmts*] := <map(booster-to-metadata-method)> classMeths;
			[paramStmts*] := <map(booster-to-metadata-method-params)> classMeths
			

	booster-to-metadata-attributes:
		((classname, attname), (ds, t, opp, min, max)) ->
			Insert(None(), None(), Into(), "_Meta_Attributes", 
						["class","attName","primType","typeMultiplicity","oppAttName","className","setName","direction","tableName","isId"], 
						[String(classname),String(attname),String(primType),String(typeMultiplicity),oppAttName,String(className),String(setName),String(direction),String(tableName),Int(isId)], None())
		where
			(primType, typeMultiplicity,className,setName) := <attribute-type-metadata> t;
			(direction, oppAttName) := <get-direction> (classname, attname);
			tableName := <get-attribute-table-name>(classname, attname);
			isId := <((<elem> (Identity(), ds) ; !1 ) <+ !0)> ds

	booster-to-metadata-method:
		((classname, methodname), (c, gc, es, d, is, os))  ->
			Insert(None(), None(), Into(), "_Meta_Methods", 
						["class","methodName","isObjectMethod"], 
						[String(classname),String(methodname),isObjectMethod], None())
		where
			isObjectMethod := <((<elem> (("this", Reference(classname)), is) ; !True() ) <+ !False())> is


	booster-to-metadata-method-params:
		((classname, methodname), (c, gc, es, d, is, os)) ->
			[istmts*,ostmts*]
		where
			[istmts*] := <map((\ i -> ((classname, methodname), "input", i) \) ; booster-to-metadata-param)> is ;
			[ostmts*] := <map((\ o -> ((classname, methodname), "output", o) \) ; booster-to-metadata-param)> os 
			/*log(|Error(),i*) */			

	booster-to-metadata-param:
		((classname, methodname), inout, (name, type)) ->
			Insert(None(), None(), Into(), "_Meta_Method_Params", 
						["class", "methodName", "paramName","paramType","paramMultiplicity","paramInOut","paramClassName", "paramSetName"], 
						[String(classname), String(methodname), String(name),String(paramPrimType), String(paramTypeMultiplicity),String(inout), String(paramClassName), String(paramSetName)], None())

		where
			(paramPrimType, paramTypeMultiplicity,paramClassName,paramSetName) := <attribute-type-metadata> type
						


	get-direction:
		(classname, attname)
			-> ("Bi", String(attname2))
		where
			(classname2, attname2) := <lookup-opposite>(classname, attname)

	get-direction:
		(classname, attname)
			-> ("Uni", Null())

	attribute-type-metadata:
		BasicType(t) -> 
			(desc,"Mandatory","","")
		where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Reference(name) -> ("ClassRef","Mandatory",name,"")
		where 
			<is-class-name> name
			
	attribute-type-metadata:
		Reference(name) -> ("SetValue","Mandatory","",name)
		where 
			<is-set-name> name

	attribute-type-metadata:
		Optional(BasicType(t)) -> 
			(desc,"Optional","","")
				where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Optional(Reference(name)) -> ("ClassRef","Optional",name,"")
		where 
			<is-class-name> name
			
	attribute-type-metadata:
		Optional(Reference(name)) -> ("SetValue","Optional","",name)
		where 
			<is-set-name> name
	
	attribute-type-metadata:
		Set(BasicType(t)) -> 
			(desc,"Set","","")
				where 
			desc := <get-type-name-for-metadata> t 

	attribute-type-metadata:
		Set(Reference(name)) -> ("ClassRef","Set",name,"")
		where 
			<is-class-name> name 
			
	attribute-type-metadata:
		Set(Reference(name)) -> ("SetValue","Set","",name)
		where 
			<is-set-name> name




	booster-to-relational-class:
		(cname, (dscs, ascs, as, ms, cs, wfs)) 
			-> Table(cname, [Column(identity , "", False(), Int(), AutoIncrement(), Primary(), None()), columns*])
		where 
			[columns*] := <filter(get-attribute-column)><filter(\((cname,aname), adef) -> ((cname,aname), adef) \)> <LookupTable> "Attribute";
			log(|Error(), "columns", <filter(\((cname,aname), adef) -> ((cname,aname), adef) \)> <LookupTable> "Attribute"); 
			identity := <concat-strings> [cname, "Id"]

			
		
	booster-to-relational-procedure:
		((cname, mname), (c,gc,exts,d,is,os))
			-> Procedure(name, params, DeclareList([]), StatementList(statements))
		where
			name := <concat-strings> [cname, "_", mname];
			params := <union> (<map(convert-input)>is, <map(convert-output)> os);
			statements := <booster-to-relational-guarded-command> (cname, mname, gc)

	booster-to-data-inserts:
		(name,values) 
			-> <union>([Insert(None(), None(), Into(), name, [name], [String("unassigned")], None())], stmts)
		where
			stmts := <map(\ value -> Insert(None(), None(), Into(), name, [name], [String(value)], None()) \)> values
			
	
			
	get-attribute-column:
		((cname, attname), (ds, BasicType(t), opp, 1, 1))
			-> Column(attname, "", False(), t', NoExtra(), NoKey(), None())
		where
			[] := <set-attribute-table-name> (cname, attname, cname);
			t' := <get-type-booster-to-sql> t


	get-attribute-column:
		((cname, attname), (ds, Reference(tname), opp, 1, 1))
			-> Column(attname, "", False(), Varchar(500), NoExtra(), NoKey(),Some(Reference(cname, [cname])))
		where
			<is-set-name> tname;
			[] := <set-attribute-table-name> (cname, attname,cname)

	get-attribute-column:
		((cname, attname), (ds, Reference(tname), opp, 1, 1))
			-> Column(attname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>([cname, "Id"])])))
		where
			<is-class-name> tname;
			not(<lookup-opposite>(cname, attname));
			[] := <set-attribute-table-name> (cname, attname,cname)
	
	get-attribute-column:
		((cname, attname), (ds, Optional(BasicType(t)), opp, 0, 1))
			-> Column(attname, "null", True(), t', NoExtra(), NoKey(), None())
		where
			[] := <set-attribute-table-name> (cname, attname, cname);
			t' := <get-type-booster-to-sql> t


	get-attribute-column:
		((cname, attname), (ds, Optional(Reference(tname)), opp, 0, 1))
			-> Column(attname, "null", True(), Varchar(500), NoExtra(), NoKey(),Some(Reference(cname, [cname])))
		where
			<is-set-name> tname;
			[] := <set-attribute-table-name> (cname, attname,cname)

	get-attribute-column:
		((cname, attname), (ds, Optional(Reference(tname)), opp, 0, 1))
			-> Column(attname, "null", True(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>([cname, "Id"])])))
		where
			<is-class-name> tname;
			not(<lookup-opposite>(cname, attname));
			[] := <set-attribute-table-name> (cname, attname, cname)

				
			
	get-assoc-table:
		((cname, attname), ds, t, (oname, oaname), min, max)
			-> Table(tablename, [Column(tableid, "", False(), Int(), AutoIncrement(), Primary(), None()), 
								 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
								 Column(secondcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(oname, [<concat-strings>[oname, "Id"]])))])
		where
			<? Reference(oname)> t <+ <? Optional(Reference(oname))> t <+ <? Set(Reference(oname))> t;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "_", attname];			
			secondcolname := <concat-strings> [oname, "_", oaname];
			tableid := <concat-strings> [tablename, "Id"];
			[] := <set-attribute-table-name> (cname, attname, tablename)

	get-assoc-table:
		((cname, attname), ds, Set(BasicType(t)), opp, min, max)
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), t', NoExtra(), NoKey(),None())])
		where
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			[] := <set-attribute-table-name> (cname, attname, tablename);
			t' := <get-type-booster-to-sql> t
			

	get-assoc-table:
		((cname, attname), ds, Set(Reference(tname)), opp, min, max)
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), Varchar(500), NoExtra(), NoKey(),Some(Reference(tname, [tname])))])
		where
			<is-set-name> tname;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			[] := <set-attribute-table-name> (cname, attname, tablename)
			
	get-assoc-table:
		((cname, attname), ds, Set(Reference(tname)), opp, min, max)
			-> Table(tablename, 
				[Column(tableid, "", False(), Int(), AutoIncrement(), Primary(),None()),
				 Column(firstcolname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(cname, [<concat-strings>[cname, "Id"]]))), 
				 Column(attname, "", False(), Int(), NoExtra(), NoKey(),Some(Reference(tname, [<concat-strings>([tname, "Id"])])))])
		where
			<is-class-name> tname;
			tablename := <concat-strings> [cname, "_", attname];
			firstcolname := <concat-strings> [cname, "Id"];			
			tableid := <concat-strings> [tablename, "Id"];
			[] := <set-attribute-table-name> (cname, attname, tablename)


			
	get-set-table:
		(name, [values*])
			-> Table(name, [Column(name, "unassigned", False(), Varchar(100), NoExtra(), Primary(),None())])

			
	convert-input:
		(name, BasicType(t))
			-> Input(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-input:
		(name, Reference(tname))
			-> Input(name, Varchar(100))
		where
			<is-set-name> tname

	convert-input:
		(name, Reference(cname))
			-> Input(name, Int())

	convert-output:
		(name, BasicType(t))
			-> Output(name, t')
		where
			t' := <get-type-booster-to-sql> t

	convert-output:
		(name, Reference(tname))
			-> Output(name, Varchar(100))
		where
			<is-set-name> tname

	convert-output:
		(name, Reference(cname))
			-> Output(name, Int())



			 	
	booster-to-relational-guarded-command:
		(classname, progname, Skip())
			-> []
			
			
	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, expr))
			-> [Update([],
				TableName(tablename),[(attname, expr')],Where(expr''),None(),None())]
			where 
				attname := <get-path-attribute-name> path;
				path' := <get-path-initial-path> path;
				Reference(tablename) := <resolve-path-type>(classname, path', (classname, progname), <new-environment> []);
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-path-to-where-clause> (classname, progname, path)

	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, expr))
			-> [Update([],
				TableName(tablename),[(attname, expr')],Where(expr''),None(),None())]
			where 
				attname := <get-path-attribute-name>(path);
				path' := <get-path-initial-path>(path);
				Optional(Reference(tablename)) := <resolve-path-type>(classname, path', (classname, progname), <new-environment> []);
				expr' := <booster-to-relational-expression> (classname, progname, expr);
				expr'' := <booster-path-to-where-clause> (classname, progname, path)

	booster-to-relational-guarded-command:
		(classname, progname, Assign(path, BinOp(path, Union(), SetExtent([expr]))))
			-> [IfThen(	Equal( Select(	[],
											[FunctionCall("count", [Star()])], 
											Some(FromPart([TableName(tablename)])), 
											Where(And(	Equal(ColumnName(column1), expr1), 
													  	Equal(ColumnName(column2), expr2))), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None(), 
											None()), 
								  Int(0)), 
						StatementList([Insert(None(), None(), Into(), tablename, [column1, column2], [expr1, expr2], None())]),
						[],
						None()
					)]
				
				
			where 
				attname := <get-path-attribute-name> path;
				path' := <get-path-initial-path> path;
				Reference(classname') := <resolve-path-type>(classname, path', (classname, progname), <new-environment> []);
				tablename := <get-attribute-table-name>(classname', attname);
				column1 := <concat-strings>[classname', "_", attname];
				(classname'', attname'') := <lookup-opposite> (classname', attname);
				column2 := <concat-strings>[classname'', "_", attname''];
				expr1 := <booster-to-relational-expression> (classname, progname, path');
				expr2 := <booster-to-relational-expression> (classname, progname, expr) 


	booster-to-relational-guarded-command:
		(classname, progname, New(Output(obj), cls))
			-> [Insert(None(), None(), Into(), cls, [], [], None()),
				Select([],[FunctionCall("LAST_INSERT_ID", [])], None(), None(), None(), None(), None(), None(), None(), Some(Into([Output(obj)])), None())]
		


/*	booster-to-relational-guarded-command:
		(classname, progname, Guard(const, gc))
			-> []
		where
			[] := <booster-to-relational-guarded-command> (classname, progname, gc);
			expr' := <booster-to-relational-constraint> (classname, progname, const)
*/

	booster-to-relational-guarded-command:
		(classname, progname, Guard(const, gc))
			-> [IfThen(expr', StatementList([stmts*]),[],None())]
		where
			[stmts*] := <booster-to-relational-guarded-command> (classname, progname, gc);
			expr' := <booster-to-relational-constraint> (classname, progname, const)

	booster-to-relational-guarded-command:
		(classname, progname, Parallel(gc1,gc2))
			-> [BeginEnd(DeclareList([]), StatementList(stmts1)),BeginEnd(DeclareList([]), StatementList(stmts2))]
		where
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1);
			stmts2 := <booster-to-relational-guarded-command> (classname, progname, gc2) 		

	booster-to-relational-guarded-command:
		(classname, progname, Sequence(gc1,gc2))
			-> [BeginEnd(DeclareList([]), StatementList(stmts1)),BeginEnd(DeclareList([]), StatementList(stmts2))]
		where
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1);
			stmts2 := <booster-to-relational-guarded-command> (classname, progname, gc2) 		

	booster-to-relational-guarded-command:
		(classname, progname, Choice(Guard(constraint1, gc1),Guard(constraint2, gc2)))
			-> [IfThen(expr1, StatementList([stmts1]),[ElseIf(expr2,StatementList([stmts2]) )],None())]
		where
			expr1 := <booster-to-relational-constraint> (classname, progname, constraint1);
			expr2 := <booster-to-relational-constraint> (classname, progname, constraint2);
			stmts1 := <booster-to-relational-guarded-command> (classname, progname, gc1);
			stmts2 := <booster-to-relational-guarded-command> (classname, progname, gc2) 		

/*	booster-to-relational-guarded-command:
		(classname, progname, gc)
			-> []
		where
			log(|Error(), "cannot convert guarded command", gc)
*/

	booster-to-relational-constraint:
		(classname, progname, True())
			-> True()

	booster-to-relational-constraint:
		(classname, progname, False())
			-> False()

	booster-to-relational-constraint:
		(classname, progname, Not(const))
			-> Not(const')
		where
			const' := <booster-to-relational-constraint> (classname, progname, const)

	booster-to-relational-constraint:
		(classname, progname, And(const1, const2))
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, Or(const1, const2))
			-> Or(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, Implies(const1, const2))
			-> Or(const2', Not(const1'))
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, Then(const1, const2))
			-> And(const1', const2')
		where
			const1' := <booster-to-relational-constraint> (classname, progname, const1);
			const2' := <booster-to-relational-constraint> (classname, progname, const2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, Equal(), expr2))
			-> Equal(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, NotEqual(), expr2))
			-> NotEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, In(), TypeExtent(t)))
			-> True()




	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, In(), expr2))
			-> InSet(expr1', None(), expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, NotIn(), expr2))
			-> InSet(expr1', Not(), expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, LessThan(), expr2))
			-> LessThan(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, GreaterThan(), expr2))
			-> GreaterThan(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, LessThanEquals(), expr2))
			-> LessThanEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-constraint:
		(classname, progname, BinRel(expr1, GreaterThanEquals(), expr2))
			-> GreaterThanEqual(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)




	booster-to-relational-constraint:
		(classname, progname, constraint)
			-> True()
		where
			log(|Error(), "cannot convert constraint", constraint)

	booster-to-relational-expression:
		(classname, progname, BasicValue(String(str)))
			-> String(str)

	booster-to-relational-expression:
		(classname, progname, BasicValue(Integer(i)))
			-> Int(i)

	booster-to-relational-expression:
		(classname, progname, TypeExtent(t))
			-> Null()


	booster-to-relational-expression:
		(classname, progname, Null())
			-> Null()

	booster-to-relational-expression:
		(classname, progname, SetExtent(exprs))
			-> SetExpression(exprs)

	booster-to-relational-expression:
		(classname, progname, Input(n))
			-> SystemVariable(m)
		where 
			m := <concat-strings>[n, "_in"]

	booster-to-relational-expression:
		(classname, progname, Output(n))
			-> SystemVariable(m)
		where 
			m := <concat-strings>[n, "_out"]

	booster-to-relational-expression:
		(classname, progname, This())
			-> SystemVariable("this")

	booster-to-relational-expression:
		(classname, progname, ThisPrimed())
			-> Null()
			
	booster-to-relational-expression:
		(classname, progname, Path(p, PathComponent(name, maybePrimed)))
		// select name from class where classId = expr
			-> Select([], [ColumnName(name)], Some(FromPart([TableName(c)])), 
						  Where(Equal(expr, ColumnName(<concat-strings>[c, "Id"]))), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None(), 
						  None())
		where
			Reference(c) := <resolve-path-type> (classname, p, None(), <new-environment> []);
			expr :=  <booster-to-relational-expression> (classname, progname, p)
				 				




	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Plus(), expr2))
			-> Plus(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Minus(), expr2))
			-> Minus(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Times(), expr2))
			-> Multiply(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)

	booster-to-relational-expression:
		(classname, progname, BinOp(expr1, Divide(), expr2))
			-> Divide(expr1', expr2')
		where
			expr1' := <booster-to-relational-expression> (classname, progname, expr1);
			expr2' := <booster-to-relational-expression> (classname, progname, expr2)


	booster-to-relational-expression:
		(expr, cname)
			-> Null()
		where
			log(|Error(), "cannot convert expression", expr)


	booster-path-to-where-clause:
		(classname, progname, Path(p, PathComponent(name, None())))
			-> Equal(expr, ColumnName(<concat-strings>[classname, "Id"]))
		where 
			expr := <booster-to-relational-expression> (classname, progname, p)
	
	
	
	booster-path-to-where-clause:
		(classname, progname, Output(n))
			-> True()

	booster-path-to-where-clause:
		(classname, progname, This())
			-> True()

	booster-path-to-where-clause:
		(classname, progname, ThisPrimed())
			-> True()
	
	
