module elaborate

imports

include/Booster2  
  
library/lookupTable
library/binRel
library/binOp
library/unOp
library/basicTypes

rules
	
	
	elaborate:
		system -> system
		where
			<unrollSubclasses> system;
			<filter(mark-method-as-done)><LookupTable>"Method";
			<repeat( (inheritance-attributes <+ inheritance-methods <+ inheritance-invariants <+ type-inference))> system
			
			
	unrollSubclasses = <map((\ (c, cdef) -> c \) ; unrollSubclass)><LookupTable> "Class"		
	updateDone = replaceMethod(\ ((cn, mn), (c, gc', exts', done, ins, outs)) -> ((cn, mn), (c, gc', exts', True(), ins, outs)) \)
	
			
	unrollSubclass: 
	cname -> allSubClasses 
		where 
			allSubClasses := <nub><concat><\ set -> <union>([set], <map(unrollSubclass)> set) \><\ (is,as,a,m,c,w) -> is \><lookup>(cname, <LookupTable> "Class");
			<replaceClass(\ (cname, (is,as,a,m,c,w)) -> (cname, (is,allSubClasses,a,m,c,w)) \)> cname 		

	inheritance-attributes:
		system -> system
			where
		atts := <filter(attributes-can-be-percolated)> <LookupTable> "Attribute";
		<not(equal)>(atts, []);
		<map(percolate-attribute)> atts


	attributes-can-be-percolated:
		((cname, aname), adef) 
			-> ((cname, aname), (cnames, adef))
		where
			cnames := <concat><filter(\ (n, (is,as,a,m,c,w)) -> [n] where <elem>(cname, as); <not(elem)>(aname, a)\)> <LookupTable> "Class";
			<not(equal)> (cnames, [])

	
	percolate-attribute:
		((cname, aname), (cnames, adef))
			-> []
		where
			<map(\cname' -> <addClassAttribute> (cname', aname, adef) \)> cnames
		

	inheritance-methods:
		system -> system
			where
		newMethods := <map(try(\((cname, mname),(c,gc,e,False(), ins, outs)) -> ((cname, mname),(c,gc,e,True(), ins, outs)) 
							where [] := <filter(\ cname' -> <lookup>((cname', mname), <LookupTable>"Method") \)>
										<\(is,as,a,m,c,w) -> as\><lookup>(cname, <LookupTable>"Class") \))><LookupTable> "Method";
		rules(
			LookupTable :+ "Method" -> newMethods
		);
		
		meths := <filter(methods-can-be-percolated)> <LookupTable> "Method";
		<not(equal)>(meths, []);
		<map(percolate-method)> meths;
		<filter(mark-method-as-done)> <LookupTable> "Method"

		

	mark-method-as-done:
		((cname, mname),(constraint, gc, exts, False(), inputs, outputs))
			-> ((cname, mname), (constraint, gc, exts, False(), inputs, outputs))
		where
			[] := <filter(\ cname' -> cname' where <lookup>((cname', mname), <LookupTable> "Method")\)><\ (is, as, atts, meths, cons, wfs) -> as \><lookup> (cname, <LookupTable> "Class");
			<updateDone> (cname, mname)

	mark-method-as-done:
		((cname, mname), (constraint, gc, exts, False(), inputs, outputs))
			-> ((cname, mname), (constraint, gc, exts, False(), inputs, outputs))
		where
			submethod-classes := <filter(\ cname' -> cname' where <lookup>((cname', mname), <LookupTable> "Method")\)><\ (is, as, atts, meths, cons, wfs) -> as \><lookup> (cname, <LookupTable> "Class");
			<set-eq>(exts, submethod-classes);
			<updateDone> (cname, mname)


	methods-can-be-percolated:
		((cname, mname), (constraint, gc, exts, True(), inputs, outputs)) 
			-> ((cname, mname), (cnames, constraint, gc, exts, True(), inputs, outputs))
		where
			cnames := <concat>
				<filter(\ 
					(n, (is,as,a,m,c,w)) -> [n] 
						where <elem>(cname, is); 
							  (<not(elem)>(mname, m) <+ 
							   <not(elem)>(cname, <\ (constraint, gc, exts, False(), inputs, outputs) -> exts \><lookup>((n, mname), <LookupTable>"Method")))\)> 
							   	<LookupTable> "Class";
			<not(equal)> (cnames, [])

	
	percolate-method:
		((cname, mname), (cnames, c,gc,e, done, inputs, outputs))
			-> []
		where
			<map(\ cname' -> cname' where
				submethods := <filter(\ (cname'', mname'') -> (cname'', mname'') where (c',gc',exts',False(), inputs, outputs) := <lookup>((cname'', mname''),<LookupTable> "Method")  \)><\ (is,as,a,m,c,w) -> <cart(id)>(as,[mname])\> <lookup>(cname', <LookupTable> "Class"); 
				<equal>([],submethods);
					(<addClassMethod> (cname', mname, (c, gc, <union>(e, [cname]), done, inputs, outputs)) 
					<+ <updateClassMethod> (cname', mname, c, cname, e, inputs, outputs))
			 \)> cnames

		

	inheritance-invariants:
		system -> system
			where
		invs := <filter(invariants-can-be-percolated)><concat><map(\ (cname, (is,as,a,m,c,w)) -> <cart(id)>([cname], c)\)> <LookupTable> "Class";
		<not(equal)>(invs, []);
		<map(percolate-invariant)> invs 
			
			
	invariants-can-be-percolated:
		(cname, inv) 
			-> (cname, cnames, inv)
		where
			cnames := <concat><filter(\ (n, (is,as,a,m,c,w)) -> [n] where <elem>(cname, as); <not(elem)>(inv, c)\)> <LookupTable> "Class";
			<not(equal)> (cnames, [])
			
			
	percolate-invariant:
		(cname, cnames, inv)
			-> []
		where
			<map(\cname' -> <addClassInvariant> (cname', inv) \)> cnames		


	type-inference:
		system -> system
			where
		oldMethods := <LookupTable> "Method";
		methodConstraints := <map(\((cname, mname),(constraint,gc,e,True(), is,os)) -> (cname, mname, constraint) \)> oldMethods;
		<map(do-type-inference)> methodConstraints;
		newMethods := <LookupTable> "Method";
		<not(equal)> (oldMethods, newMethods)
			
			
	do-type-inference:
		(cname, mname,c) -> (cname, mname, c')
			where
				c' := <topdown(try(
								try(\ term -> ((cname, mname), term) \); 
										( infer-types 
										<+ induce-types
										<+ record-parameter) ))> c  ;
				(<equal>(c, c') <+ <updateMethodConstraint> (cname, mname, c'))
										
			
	infer-types:
		(context, BasicValue(Integer(i))) -> BasicValue(Integer(i)) { Optional(BasicType(Int())) }

	infer-types:
		(context, BasicValue(String(s))) -> BasicValue(String(s)) { Optional(BasicType(String())) }

	infer-types:
		(context, TypeExtent(Boolean())) -> TypeExtent(Boolean()) { Set(BasicType(Boolean())) }

	infer-types:
		(context, TypeExtent(String())) -> TypeExtent(String()) { Set(BasicType(String())) }

	infer-types:
		(context, TypeExtent(Int())) -> TypeExtent(Int()) { Set(BasicType(Int())) }

	infer-types:
		(context, TypeExtent(DateTime())) -> TypeExtent(DateTime()) { Set(BasicType(DateTime())) }

	infer-types:
		((cname, mname), Input(s) {})
			-> Input(s) {type}
		where
			type := <getInputType>(cname, mname, s)

	infer-types:
		((cname, mname), Output(s) {})
			-> Output(s) {type}
		where
		type := <getOutputType>(cname, mname, s)

	infer-types:
		((cname, mname), This())
			-> This() {Reference(cname)}

	infer-types:
		((cname, mname), ThisPrimed())
			-> ThisPrimed() {Reference(cname)}

	infer-types:
		((cname, mname), PathStart(att, maybePrimed))
			-> PathStart(att, maybePrimed) {type}
		where
			type := <\ (ds,t,o,min,max) -> t\><lookup>((cname, att), <LookupTable>"Attribute")

	infer-types:
		(context, Path(pathstart {Reference(c)}, PathComponent(attname, maybeprimed)) {})
			-> Path(pathstart {Reference(c)}, PathComponent(attname, maybeprimed)) { type}
		where
			type := <\ (ds,t,o,min,max) -> t\><lookup>((c, attname), <LookupTable>"Attribute")




	// Binary relations: pushing types left to right
	induce-types:
		(context, BinRel(lexpr {type}, op,  rexpr {}))
			-> BinRel(lexpr {type}, op,  rexpr {type'})
		where
			type' := <binrel-ltor-type> (op, type)
		
	// Binary relations: pushing types right to left
	induce-types:
		(context, BinRel(lexpr {}, op,  rexpr {type}))
			-> BinRel(lexpr {type'}, op,  rexpr {type})
		where
			type' := <binrel-rtol-type> (op, type)
		


	// Binary operations: pushing types left to right
	induce-types:
		(context, BinOp(lexpr {type}, op,  rexpr {}) {})
			-> BinOp(lexpr {type}, op,  rexpr {type'}) {type''}
		where
			type' := <binop-ltor-type> (op, type);
			type'' := <binop-btot-type> (op, type, type')
			
	// Binary operations: pushing types right to left
	induce-types:
		(context, BinOp(lexpr {}, op,  rexpr {type}) {})
			-> BinOp(lexpr {type'}, op,  rexpr {type}) {type''}
		where
			type' := <binop-rtol-type> (op, type);
			type'' := <binop-btot-type> (op, type, type')

	// Binary operations: pushing types top to bottom
	induce-types:
		(context, BinOp(lexpr {}, op,  rexpr {}) {type})
			-> BinOp(lexpr {type'}, op,  rexpr {type''}) {type}
		where
			(type', type'') := <binop-ttob-type> (op, type)

	// Unary operations: pushing types bottom to top
	induce-types:
		(context, UnOp(op, expr {type}) {})
			-> UnOp(op, expr {type}) {type}

	// Unary operations: pushing types top to bottom
	induce-types:
		(context, UnOp(op, expr {}) {type})
			-> UnOp(op, expr {type}) {type}
		
	


			
	record-parameter:
		((cname, mname), Input(s) {type})
			-> Input(s) {type}
		where
			<is-more-general-than> (type, <getInputType>(cname, mname, s));
			<addInput> (cname, mname, s, type)

	record-parameter:
		((cname, mname), Input(s) {type})
			-> Input(s) {type}
		where
			<not(getInputType)>(cname, mname, s);
			<addInput> (cname, mname, s, type)

	record-parameter:
		((cname, mname), Output(s) {type})
			-> Input(s) {type}
		where
			<is-more-general-than> (type, <getOutputType>(cname, mname, s));
			<addOutput> (cname, mname, s, type)

	record-parameter:
		((cname, mname), Output(s) {type})
			-> Output(s) {type}
		where
			<not(getOutputType)>(cname, mname, s);
			<addOutput> (cname, mname, s, type)
			
		
			
  
  // Workflow Begin
 
/*    expandSeqWorfklows: (expanded,n_expanded) -> (expanded, n_expanded)
    where
    	[] := <filter(fullyExpanded)> n_expanded
    	
 
    expandSeqWorfklows: (expanded,n_expanded) -> (expanded', n_expanded')
    where
    	already_expanded := <filter(fullyExpanded)> n_expanded;
    	expanded' := <union> (expanded,already_expanded);
    	n_expanded1 := <diff> (n_expanded,already_expanded);
    	n_expanded' := map<replaceReference(already_expanded)> n_expanded1;
    	
  */
	// make a usual list from a concurrent workflow 
	makeParList: Single(name) -> [name]
	makeParList: Multiple(name,rest) -> <conc>([name],<makeParList> rest)
	
		

	// checks whether a sequential workflow is fully expended, i.e., it does not use workflow references anymore
	fullyExpanded: Skip() -> Skip()
	fullyExpanded: Choice(ga1,wf1,ga2,wf2) -> Choice(ga1,wf1,ga2,wf2)
	where <fullyExpanded> wf1;
	      <fullyExpanded> wf2
	fullyExpanded: Wait(i,j,wf) -> Wait(i,j,wf)
	where <fullyExpanded> wf
	fullyExpanded: Prefix(ga,wf) -> Prefix(ga,wf)
	where <fullyExpanded> wf
		

    expandSeqWorkflows: (cname, seqwfs) -> (cname, seqwfs')
    	where
    		rules(
    			PrecondLookupTable :+ "SeqWorkflows" -> []
    		);
    		seqwfs' := <outermost(expandSeqWf)> (<innermost(expandSeqWf)> seqwfs)
    		
    		
//	system -> <topdown(expand)> system
	
//	


	expandSeqWf:
		WorkflowReference(wfr) -> wf
		where
			wf := <lookup> (wfr,(<PrecondLookupTable> "SeqWorkflows"))
				
	expandSeqWf: SeqWf(name,definition) -> (name,definition)
	where not(<lookup> (name,(<PrecondLookupTable> "SeqWorkflows")));
	      <fullyExpanded> definition;
	      wfs := <PrecondLookupTable> "SeqWorkflows";
	      newwfs := <conc>(wfs,[(name, definition)]);
          rules( 
	      	PrecondLookupTable :+ "SeqWorkflows" -> newwfs
	      )
		      
/*		      
	expandParWorkflows: (cname,parwfs) -> (cname,parwfs')
		where
		parwfs' := <currymap(expandParWf)> (cname, parwfs)
*/		
	expandParWf: (cname, ParWf(name,xs)) -> (name,wfs*)
	where
		wfs_ref* := <makeParList> xs;
		classExpandedSeqWorkflows := <lookup>(cname, <LookupTable> "ExpandedSeqWorkflows");
		wfs* := <map(\wfr -> <lookup> (wfr,classExpandedSeqWorkflows)\)> wfs_ref*
  
  // Workflow End
  
