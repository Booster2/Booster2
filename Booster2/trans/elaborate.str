module elaborate

imports
  include/Booster2  
  
  library/lookupTable
  library/binRel
 

rules
	
	
	elaborate:
		system -> system
		where
			<unrollSubclasses> system;
			<filter(mark-method-as-done)><LookupTable>"Method";
			<repeat( (inheritance-attributes <+ inheritance-methods <+ inheritance-invariants <+ type-inference))> system
			
			
	unrollSubclasses = <map((\ (c, cdef) -> c \) ; unrollSubclass)><LookupTable> "Class"		
	updateDone = replaceMethod(\ ((cn, mn), (c, gc', exts', done, ins, outs)) -> ((cn, mn), (c, gc', exts', True(), ins, outs)) \)
	
			
	unrollSubclass: 
	cname -> allSubClasses 
		where 
			allSubClasses := <nub><concat><\ set -> <union>([set], <map(unrollSubclass)> set) \><\ (is,as,a,m,c,w) -> is \><lookup>(cname, <LookupTable> "Class");
			<replaceClass(\ (cname, (is,as,a,m,c,w)) -> (cname, (is,allSubClasses,a,m,c,w)) \)> cname 		

	inheritance-attributes:
		system -> system
			where
		atts := <filter(attributes-can-be-percolated)> <LookupTable> "Attribute";
		<not(equal)>(atts, []);
		<map(percolate-attribute)> atts


	attributes-can-be-percolated:
		((cname, aname), adef) 
			-> ((cname, aname), (cnames, adef))
		where
			cnames := <concat><filter(\ (n, (is,as,a,m,c,w)) -> [n] where <elem>(cname, as); <not(elem)>(aname, a)\)> <LookupTable> "Class";
			<not(equal)> (cnames, [])

	
	percolate-attribute:
		((cname, aname), (cnames, adef))
			-> []
		where
			<map(\cname' -> <addClassAttribute> (cname', aname, adef) \)> cnames
		

	inheritance-methods:
		system -> system
			where
		newMethods := <map(try(\((cname, mname),(c,gc,e,False(), ins, outs)) -> ((cname, mname),(c,gc,e,True(), ins, outs)) 
							where [] := <filter(\ cname' -> <lookup>((cname', mname), <LookupTable>"Method") \)>
										<\(is,as,a,m,c,w) -> as\><lookup>(cname, <LookupTable>"Class") \))><LookupTable> "Method";
		rules(
			LookupTable :+ "Method" -> newMethods
		);
		
		meths := <filter(methods-can-be-percolated)> <LookupTable> "Method";
		<not(equal)>(meths, []);
		<map(percolate-method)> meths;
		<filter(mark-method-as-done)> <LookupTable> "Method"

		

	mark-method-as-done:
		((cname, mname),(constraint, gc, exts, False(), inputs, outputs))
			-> ((cname, mname), (constraint, gc, exts, False(), inputs, outputs))
		where
			[] := <filter(\ cname' -> cname' where <lookup>((cname', mname), <LookupTable> "Method")\)><\ (is, as, atts, meths, cons, wfs) -> as \><lookup> (cname, <LookupTable> "Class");
			<updateDone> (cname, mname)

	mark-method-as-done:
		((cname, mname), (constraint, gc, exts, False(), inputs, outputs))
			-> ((cname, mname), (constraint, gc, exts, False(), inputs, outputs))
		where
			submethod-classes := <filter(\ cname' -> cname' where <lookup>((cname', mname), <LookupTable> "Method")\)><\ (is, as, atts, meths, cons, wfs) -> as \><lookup> (cname, <LookupTable> "Class");
			<set-eq>(exts, submethod-classes);
			<updateDone> (cname, mname)


	methods-can-be-percolated:
		((cname, mname), (constraint, gc, exts, True(), inputs, outputs)) 
			-> ((cname, mname), (cnames, constraint, gc, exts, True(), inputs, outputs))
		where
			cnames := <concat>
				<filter(\ 
					(n, (is,as,a,m,c,w)) -> [n] 
						where <elem>(cname, is); 
							  (<not(elem)>(mname, m) <+ 
							   <not(elem)>(cname, <\ (constraint, gc, exts, False(), inputs, outputs) -> exts \><lookup>((n, mname), <LookupTable>"Method")))\)> 
							   	<LookupTable> "Class";
			<not(equal)> (cnames, [])

	
	percolate-method:
		((cname, mname), (cnames, c,gc,e, done, inputs, outputs))
			-> []
		where
			<map(\ cname' -> cname' where
				submethods := <filter(\ (cname'', mname'') -> (cname'', mname'') where (c',gc',exts',False(), inputs, outputs) := <lookup>((cname'', mname''),<LookupTable> "Method")  \)><\ (is,as,a,m,c,w) -> <cart(id)>(as,[mname])\> <lookup>(cname', <LookupTable> "Class"); 
				<equal>([],submethods);
					(<addClassMethod> (cname', mname, (c, gc, <union>(e, [cname]), done, inputs, outputs)) 
					<+ <updateClassMethod> (cname', mname, c, cname, e, inputs, outputs))
			 \)> cnames

		

	inheritance-invariants:
		system -> system
			where
		invs := <filter(invariants-can-be-percolated)><concat><map(\ (cname, (is,as,a,m,c,w)) -> <cart(id)>([cname], c)\)> <LookupTable> "Class";
		<not(equal)>(invs, []);
		<map(percolate-invariant)> invs 
			
			
	invariants-can-be-percolated:
		(cname, inv) 
			-> (cname, cnames, inv)
		where
			cnames := <concat><filter(\ (n, (is,as,a,m,c,w)) -> [n] where <elem>(cname, as); <not(elem)>(inv, c)\)> <LookupTable> "Class";
			<not(equal)> (cnames, [])
			
			
	percolate-invariant:
		(cname, cnames, inv)
			-> []
		where
			<map(\cname' -> <addClassInvariant> (cname', inv) \)> cnames		


	type-inference:
		system -> system
			where
		oldMethods := <LookupTable> "Method";
		methodConstraints := <map(\((cname, mname),(constraint,gc,e,True(), is,os)) -> (cname, mname, constraint) \)> oldMethods;
		<map(do-type-inference)> methodConstraints;
		newMethods := <LookupTable> "Method";
		<not(equal)> (oldMethods, newMethods)
			
			
	do-type-inference:
		(cname, mname,c) -> (cname, mname, c')
			where
				c' := <topdown(try(
								try((\ Input(n) {annot} -> ((cname, mname), Input(n) {annot}) \) <+ 
								(\ Output(n) {annot} -> ((cname, mname), Output(n) {annot}) \)  <+
								(\ Input(n) -> ((cname, mname), Input(n) ) \) <+ 
								(\ Output(n) -> ((cname, mname), Output(n)) \)); 
										( infer-types 
										<+ induce-types
										<+ record-parameter) ))> c  ;
				(<equal>(c, c')  <+ <updateMethodConstraint> (cname, mname, c'))
										
			
	infer-types:
		BasicValue(Integer(i)) -> BasicValue(Integer(i)) { [Int(), Optional(Int())] }

	infer-types:
		BasicValue(String(s)) -> BasicValue(String(s)) { [String(), Optional(String())] }

	infer-types:
		TypeExtent(Boolean()) -> TypeExtent(Boolean()) { [Set(Boolean())] }

	infer-types:
		TypeExtent(String()) -> TypeExtent(String()) { [Set(String())] }

	infer-types:
		TypeExtent(Int()) -> TypeExtent(Int()) { [Set(Int())] }

	infer-types:
		TypeExtent(DateTime()) -> TypeExtent(DateTime()) { [Set(DateTime())] }
		
			
	induce-types:
		BinRel(expr1 {types}, op, expr2)
			-> BinRel(expr1 {types}, op, expr2 {types'})
		where
			types' := <binrel-ltor-type> (op, types)

	induce-types:
		BinRel(expr1, op, expr2 {types})
			-> BinRel(expr1 {types'}, op, expr2 {types})
		where
			types' := <binrel-rtol-type> (op, types)

	induce-types:
		BinRel(expr1 {types1}, op, expr2 {types2})
			-> BinRel(expr1 {types3}, op, expr2 {types4})
		where
			types3 := <isect>(types1, <binrel-ltor-type> (op, types2));
			types4 := <isect>(types2, <binrel-ltor-type> (op, types1))


			
	induce-types:
		BinOp(expr { types }, op, expr2)
			-> BinOp(expr { types }, op, expr2 { types })

	induce-types:
		BinOp(expr { types1 }, op, expr2 {types2})
			-> BinOp(expr { types }, op, expr2 { types })
		where
			types := <isect>(types1, types2)


	infer-types:
		((cname, mname), Input(s))
			-> Input(s) {types}
		where
			types := <getInputType>(cname, mname, s);
			<not(equal)>(types, [])

	infer-types:
		((cname, mname), Output(s))
			-> Output(s) {types}
		where
		types := <getOutputType>(cname, mname, s);
		<not(equal)>(types, [])

			
	record-parameter:
		((cname, mname), Input(s) {types})
			-> Input(s) {types}
		where
			<not(equal)> (types, <getInputType>(cname, mname, s));
			<addInput> (cname, mname, s, types)


	record-parameter:
		((cname, mname), Output(s) {types})
			-> Output(s) {types}
		where
			<not(equal)> (types, <getOutputType>(cname, mname, s));
			<addOutput> (cname, mname, s, types)
			
		
			
/*			
	expandInheritance:
		system 
			-> system
		where
			attributes := <LookupTable> "Attribute";
			attributes' := <filter(canBeExpanded)> attributes;
			<not(equal)> (attributes', [])
			
	canBeExpanded:
		((cname, aname), (d,t,o,min, max))
			-> ((cname, aname), (d,t,o,min, max))
		where
			
			
			
			
			<elem>((superclassname, aname), <LookupTable> "Attribute") 
			<lookup>(subclassname, <LookupTable> "Class")
*/

/*
	elaborate:
		system -> system
	where */
				/*<combine-invariants> 
   				<calculate-class-invariants> 
   				<create-constraint-for-each-attribute> 
   				*/
   				/*< generate-inputs-and-outputs > 
   				<insert-this-main>
  				system ;
  				invariants := <LookupTable> "Invariants";
  				qualified-invariants := <map(qualify-invariant)> invariants;
  				rules(			
					LookupTable :+ "QualifiedInvariants" -> qualified-invariants
				);
 				invs-atts := <map(get-mentioned-attributes-in-invariant)> qualified-invariants;
 				att-invs := <currymap(getattributes)> (invs-atts, <LookupTable> "Type");
  				rules(			
					LookupTable :+ "ClassBasedInvariants" -> att-invs
				) ;
				
				seqwfs' := <map(expandSeqWorkflows)>(<LookupTable> "SeqWorkflows");
  				rules(			
					LookupTable :+ "ExpandedSeqWorkflows" -> seqwfs'
				);
				parwfs' := <map(expandParWorkflows)>(<LookupTable> "ParWorkflows");
  				rules(			
					LookupTable :+ "ExpandedParWorkflows" -> parwfs'
				)
 */ 		
  
  
  // Workflow Begin
 
/*    expandSeqWorfklows: (expanded,n_expanded) -> (expanded, n_expanded)
    where
    	[] := <filter(fullyExpanded)> n_expanded
    	
 
    expandSeqWorfklows: (expanded,n_expanded) -> (expanded', n_expanded')
    where
    	already_expanded := <filter(fullyExpanded)> n_expanded;
    	expanded' := <union> (expanded,already_expanded);
    	n_expanded1 := <diff> (n_expanded,already_expanded);
    	n_expanded' := map<replaceReference(already_expanded)> n_expanded1;
    	
  */
	// make a usual list from a concurrent workflow 
	makeParList: Single(name) -> [name]
	makeParList: Multiple(name,rest) -> <conc>([name],<makeParList> rest)
	
		

	// checks whether a sequential workflow is fully expended, i.e., it does not use workflow references anymore
	fullyExpanded: Skip() -> Skip()
	fullyExpanded: Choice(ga1,wf1,ga2,wf2) -> Choice(ga1,wf1,ga2,wf2)
	where <fullyExpanded> wf1;
	      <fullyExpanded> wf2
	fullyExpanded: Wait(i,j,wf) -> Wait(i,j,wf)
	where <fullyExpanded> wf
	fullyExpanded: Prefix(ga,wf) -> Prefix(ga,wf)
	where <fullyExpanded> wf
		

    expandSeqWorkflows: (cname, seqwfs) -> (cname, seqwfs')
    	where
    		rules(
    			PrecondLookupTable :+ "SeqWorkflows" -> []
    		);
    		seqwfs' := <outermost(expandSeqWf)> (<innermost(expandSeqWf)> seqwfs)
    		
    		
//	system -> <topdown(expand)> system
	
//	


	expandSeqWf:
		WorkflowReference(wfr) -> wf
		where
			wf := <lookup> (wfr,(<PrecondLookupTable> "SeqWorkflows"))
				
	expandSeqWf: SeqWf(name,definition) -> (name,definition)
	where not(<lookup> (name,(<PrecondLookupTable> "SeqWorkflows")));
	      <fullyExpanded> definition;
	      wfs := <PrecondLookupTable> "SeqWorkflows";
	      newwfs := <conc>(wfs,[(name, definition)]);
          rules( 
	      	PrecondLookupTable :+ "SeqWorkflows" -> newwfs
	      )
		      
/*		      
	expandParWorkflows: (cname,parwfs) -> (cname,parwfs')
		where
		parwfs' := <currymap(expandParWf)> (cname, parwfs)
*/		
	expandParWf: (cname, ParWf(name,xs)) -> (name,wfs*)
	where
		wfs_ref* := <makeParList> xs;
		classExpandedSeqWorkflows := <lookup>(cname, <LookupTable> "ExpandedSeqWorkflows");
		wfs* := <map(\wfr -> <lookup> (wfr,classExpandedSeqWorkflows)\)> wfs_ref*
  
  // Workflow End
  
