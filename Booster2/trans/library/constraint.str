module library/constraint

imports
  include/Booster2
  
  library/relation
  library/expression
  library/valueExpression
  library/environment
 
 
 rules
 	
 	

			
/*	is-defined:
*/ 	

	is-defined:
		(classname, method, True(), env)
			-> True()

	is-defined:
		(classname, method, False(), env)
			-> True()
	
	is-defined:
		(classname, method, Not(constraint1), env)
			-> Not(constraint2)
		where
			constraint2 := <is-defined>(classname, method, constraint1, env)
			
	is-defined:
		(classname, method, And(constraint1, constraint2), env)
			-> And(constraint3, constraint4)
		where
			constraint3 := <is-defined>(classname, method, constraint1, env);
			constraint4 := <is-defined>(classname, method, constraint2, env)
			
	is-defined:
		(classname, method, Or(constraint1, constraint2), env)
			-> Or(And(constraint1, constraint3), And(constraint2, constraint4))
		where
			constraint3 := <is-defined>(classname, method, constraint1, env);
			constraint4 := <is-defined>(classname, method, constraint2, env)
	
	is-defined:
		(classname, method, Implies(constraint1, constraint2), env)
			-> Implies(And(constraint1, constraint3), And(constraint2, constraint4))
		where
			constraint3 := <is-defined>(classname, method, constraint1, env);
			constraint4 := <is-defined>(classname, method, constraint2, env)
		
	is-defined:
		(classname, method, Then(constraint1, constraint2), env)
			-> Then(constraint3, constraint4)
		where
			constraint3 := <is-defined>(classname, method, constraint1, env);
			constraint4 := <is-defined>(classname, method, constraint2, env)
			
			
	
	 

			
/* 	substitute:
		takes a constraint, and replaces all instances of the path with the given expression
*/			
	aliasing-substitute:
		 (classname, methodname, True(), path, expression, env)
		 	-> True()		

	aliasing-substitute:
		 (classname, methodname, False(), path, expression, env)
		 	-> False()
		 	
	aliasing-substitute:
		 (classname, methodname, Not(constraint), path, expression, env)
		 	-> Not(constraint2)
		 where
		 	constraint2 := <aliasing-substitute>	(classname, methodname, constraint, path, expression, env)
		 	
	aliasing-substitute:
		 (classname, methodname, And(constraint1, constraint2), path, expression, env)
		 	-> And(constraint3, constraint4)
		 where
		 	/*log(|Error(), <substitute>	(constraint1, path, expression), <substitute>	(constraint2, path, expression));*/
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)
	
	aliasing-substitute:
		 (classname, methodname, Or(constraint1, constraint2), path, expression, env)
		 	-> Or(constraint3, constraint4)
		 where
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)
	
	aliasing-substitute:
		 (classname, methodname, Implies(constraint1, constraint2), path, expression, env)
		 	-> Implies(constraint3, constraint4)
		 where
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)
	
	aliasing-substitute:
		 (classname, methodname, Then(constraint1, constraint2), path, expression, env)
		 	-> Then(constraint3, constraint4)
		 where
		 	constraint3 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env);
		 	constraint4 := <aliasing-substitute>	(classname, methodname, constraint2, path, expression, env)

	aliasing-substitute:
		 (classname, methodname, Exists(name, expr1, constraint1), Path(ps, pc), expression, env)
		 	-> And(
		 		Exists(name, expr1, 
		 			Implies(
			 				BinRel(
			 					PathStart(name, None()),
			 					Equal(),
			 					ps),
			 					constraint3)),
	 			Exists(name, expr1, 
	 				Implies(
	 					BinRel(
		 					PathStart(name, None()),
		 					NotEqual(),
		 					ps),
		 					constraint1)))
		 where
		 	//log(|Error(), "Aliasing Substitute", (Forall(name, expr1, constraint1), Path(ps, pc), expression));
		 	Set(type1) := <get-expression-type>(expr1, classname, methodname, env);
		 	type2 := <get-expression-type>(ps, classname, methodname, env);
		 	<equal>(type1, type2);
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint1, [PathStart(name, Some(Primed()))], ps, env');
			//log(|Error(), "Constraint3", (constraint2, [Path(ps, pc)], expression));
			constraint3 := <aliasing-substitute>	(classname, methodname, constraint2, Path(ps, pc), expression, env')
		 	

	aliasing-substitute:
		 (classname, methodname, Exists(name, expr1, constraint1), path, expression, env)
		 	-> Exists(name, expr2, constraint2)
		 where
		 	expr2 := <literal-substitute>	(classname, methodname, expr1, [path], expression, env);
		 	env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env')

	aliasing-substitute:
		 (classname, methodname, Forall(name, expr1, constraint1), Path(ps, pc), expression, env)
		 	-> And(
		 		Forall(name, expr1, 
		 			Implies(
			 				BinRel(
			 					PathStart(name, None()),
			 					Equal(),
			 					ps),
			 					constraint3)),
	 			Forall(name, expr1, 
	 				Implies(
	 					BinRel(
		 					PathStart(name, None()),
		 					NotEqual(),
		 					ps),
		 					constraint1)))
		 where
		 	//log(|Error(), "Aliasing Substitute", (Forall(name, expr1, constraint1), Path(ps, pc), expression));
		 	Set(type1) := <get-expression-type>(expr1, classname, methodname, env);
		 	type2 := <get-expression-type>(ps, classname, methodname, env);
		 	<equal>(type1, type2);
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint1, [PathStart(name, Some(Primed()))], ps, env');
			//log(|Error(), "Constraint3", (constraint2, [Path(ps, pc)], expression));
			constraint3 := <aliasing-substitute>	(classname, methodname, constraint2, Path(ps, pc), expression, env')
		 	

	aliasing-substitute:
		 (classname, methodname, Forall(name, expr1, constraint1), path, expression, env)
		 	-> Forall(name, expr2, constraint2)
		 where
		 	expr2 := <literal-substitute>	(classname, methodname, expr1, [path], expression, env);
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <aliasing-substitute>	(classname, methodname, constraint1, path, expression, env')
			
	literal-substitute:
		 (classname, methodname, True(), paths, expression, env)
		 	-> True()		

	literal-substitute:
		 (classname, methodname, False(), paths, expression, env)
		 	-> False()
		 	
	literal-substitute:
		 (classname, methodname, Not(constraint), paths, expression, env)
		 	-> Not(constraint2)
		 where
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint, paths, expression, env)
		 	
	literal-substitute:
		 (classname, methodname, And(constraint1, constraint2), paths, expression, env)
		 	-> And(constraint3, constraint4)
		 where
		 	/*log(|Error(), <substitute>	(constraint1, path, expression), <substitute>	(constraint2, path, expression));*/
		 	constraint3 := <literal-substitute>	(classname, methodname, constraint1, paths, expression, env);
		 	constraint4 := <literal-substitute>	(classname, methodname, constraint2, paths, expression, env)
	
	literal-substitute:
		 (classname, methodname, Or(constraint1, constraint2), paths, expression, env)
		 	-> Or(constraint3, constraint4)
		 where
		 	constraint3 := <literal-substitute>	(classname, methodname, constraint1, paths, expression, env);
		 	constraint4 := <literal-substitute>	(classname, methodname, constraint2, paths, expression, env)
	
	literal-substitute:
		 (classname, methodname, Implies(constraint1, constraint2), paths, expression, env)
		 	-> Implies(constraint3, constraint4)
		 where
		 	constraint3 := <literal-substitute>	(classname, methodname, constraint1, paths, expression, env);
		 	constraint4 := <literal-substitute>	(classname, methodname, constraint2, paths, expression, env)
	
	literal-substitute:
		 (classname, methodname, Then(constraint1, constraint2), paths, expression, env)
		 	-> Then(constraint3, constraint4)
		 where
		 	constraint3 := <literal-substitute>	(classname, methodname, constraint1, paths, expression, env);
		 	constraint4 := <literal-substitute>	(classname, methodname, constraint2, paths, expression, env)

	literal-substitute:
		 (classname, methodname, Exists(name, expr1, constraint1), [Path(ps, pc)], expression, env)
		 	-> And(
		 		Exists(name, expr1, 
		 			Implies(
			 				BinRel(
			 					PathStart(name, None()),
			 					Equal(),
			 					ps),
			 					constraint2)),
	 			Exists(name, expr1, 
	 				Implies(
	 					BinRel(
		 					PathStart(name, None()),
		 					NotEqual(),
		 					ps),
		 					constraint1)))
		 where
		 	Set(type1) := <get-expression-type>(expr1, classname, methodname, env);
		 	type2 := <get-expression-type>(ps, classname, methodname, env);
		 	<equal>(type1, type2);
		 	/*expr2 := <substitute> (expr1, path, expression); */
		 	env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint1, [Path(PathStart(name, Some(Primed())), pc)], expression, env') 

	literal-substitute:
		 (classname, methodname, Exists(name, expr1, constraint1), paths, expression, env)
		 	-> Exists(name, expr2, constraint2)
		 where
		 	expr2 := <literal-substitute>	(classname, methodname, expr1, paths, expression, env);
		 	env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint1, paths, expression, env')

	literal-substitute:
		 (classname, methodname, Forall(name, expr1, constraint1), [Path(ps, pc)], expression, env)
		 	-> And(
		 		Forall(name, expr1, 
		 			Implies(
			 				BinRel(
			 					PathStart(name, None()),
			 					Equal(),
			 					ps),
			 					constraint2)),
	 			Forall(name, expr1, 
	 				Implies(
	 					BinRel(
		 					PathStart(name, None()),
		 					NotEqual(),
		 					ps),
		 					constraint1)))
		 where
		 	Set(type1) := <get-expression-type>(expr1, classname, methodname, env);
		 	type2 := <get-expression-type>(ps, classname, methodname, env);
		 	<equal>(type1, type2);
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint1, [Path(PathStart(name, Some(Primed())), pc)], expression, env')

	literal-substitute:
		 (classname, methodname, Forall(name, expr1, constraint1), paths, expression, env)
		 	-> Forall(name, expr2, constraint2)
		 where
		 	expr2 := <literal-substitute>	(classname, methodname, expr1, paths, expression, env);
			env' := <add-var-to-environment> (name, (classname, methodname, expr1), env);
		 	constraint2 := <literal-substitute>	(classname, methodname, constraint1, paths, expression, env')
	
	
/*	combine-invariants:
		([invs1*],[invs2*])
			-> ([invs1*],[invs2*])
*/

/*
	combine-invariants:
		([], invs)
			-> []

	combine-invariants:
		([((classname, attname), constraint1), invs1*], [invs2*])
			-> [((classname, attname), constraint2), invs3*]
		where
			constraint2 := <get-invariant> ((classname, attname), [invs2*]);
			[invs3*] := <combine-invariants> ([invs1*], [invs2*])


	get-invariant:
		((classname, attname), [[((classname, attname), constraint2), invs1*], invs2*])
			-> And(constraint2, constraint3)
		where
			constraint3 := <get-invariant>((classname, attname), [[invs1*], invs2*])

	get-invariant:
		((classname, attname), [[((classname1, attname1), constraint2), invs1*], invs2*])
			-> constraint3
		where
			constraint3 := <get-invariant>((classname, attname), [[invs1*], invs2*])

	get-invariant:
		((classname, attname), [[], invs2*])
			-> constraint3
		where
			constraint3 := <get-invariant>((classname, attname), [invs2*])

	get-invariant:
		((classname, attname), [])
			-> True()
		
*/			

