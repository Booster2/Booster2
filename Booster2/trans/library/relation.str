module library/relation

imports
  include/Booster2
   
  library/expression
  library/valueExpression
  
  library/strategy
  library/constraint
  
  compile
  elaborate
  
 rules
 	 



	
	aliasing-substitute:
		 (classname, methodname, BinRel(expression1, binrel, expression2), Path(ps, pc), expression, env)
		 	-> constraint
		 where
		 	//log(|Error(), "Aliasing Subst - classname, methodname:", (classname, methodname));
		 	//log(|Error(), "Aliasing Subst - binrel", (BinRel(expression1, binrel, expression2)));
		 	//log(|Error(), "Aliasing Subst - path", Path(ps, pc));
		 	//log(|Error(), "Aliasing Subst - expression", expression);
		 	paths1 := <get-mentioned-paths> (classname, methodname, expression1, env);
		 	//log(|Error(), "Aliasing Subst - paths1", paths1);
		 	paths2 := <get-mentioned-paths> (classname, methodname, expression2, env);
		 	//log(|Error(), "Aliasing Subst - paths2", paths2);
		 	paths := <union>(paths1, paths2);
		 	//log(|Error(), "Aliasing Subst - paths", paths);
		 	type := <resolve-path-type>(classname, ps, (classname, methodname), env);
		 	//log(|Error(), "Aliasing Subst - type", type);
		 	filtered-paths := <curryfilter(is-correct-type)> ((type, classname, methodname, env), paths);
		 	//log(|Error(), "Aliasing Subst - filtered paths", filtered-paths);
		 	subsets := <subsets> filtered-paths;
		 	//log(|Error(), "Aliasing Subst - subset",subsets);
		 	/* log(|Error(), "subsets", subsets); */
			constraint := <conjoin-constraints><currymap(generate-aliasing-constraint)> ((classname, methodname, BinRel(expression1, binrel, expression2), Path(ps, pc), expression, env, filtered-paths), subsets) //; 
			//log(|Error(), "Aliasing Subst - constraint", constraint)
		 	

	generate-aliasing-constraint:
		((classname, methodname, BinRel(expression1, binrel, expression2), Path(ps, pc), expression, env,all-paths), paths)
			-> Implies(And(ant1,ant2), con2)
		where
			ant1 := <conjoin-constraints><currymap(\ (p1, p2) -> BinRel(p1, Equal(), p2)\)>(ps, paths);
			paths2 := <diff>(all-paths, paths); 
			ant2 := <conjoin-constraints><currymap(\ (p1, p2) -> BinRel(p1, NotEqual(), p2)\)>(ps, paths2);
			//log(|Error(), "Something", (paths, ps));
			substs := <map(\p -> (p, ps)\)> paths;	
			con := <literal-substitute> (BinRel(expression1, binrel, expression2), substs);
			con2 := <literal-substitute> (con, [(Path(ps, pc), expression)])
					

	is-correct-type:
		((type, classname, methodname, env), path)
			-> path
		where 
			type' := <resolve-path-type> (classname, path, (classname, methodname), env);
			<equal>(type', type)

	is-correct-type:
		((type, classname, methodname, env), path)
			-> path
		where 
			type' := <resolve-path-type> (classname, path, (classname, methodname), env);
			<equal>(type', Optional(type))

	is-correct-type:
		((type, classname, methodname, env), path)
			-> path
		where 
			type' := <resolve-path-type> (classname, path, (classname, methodname), env);
			<equal>(Optional(type'), type)
			
	is-correct-type:
		((type, classname, methodname, env), path)
			-> None()
		
		 	
			 



/* 	is-defined:
		takes an expression in the context of a model, a classname, 
		and a methodname, and returns a constraint
*/			
			
	is-defined:
		(classname, method, BinRel(expr1, binrel, expr2), env)
			-> And(And(constraint1, constraint2), BinRel(expr1, binrel, expr2))
		where
			constraint1 := <is-defined> (classname, method, expr1, env);
			constraint2 := <is-defined> (classname, method, expr2, env)
		