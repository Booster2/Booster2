module library/abstractBoosterModel

imports
  include/Booster2
  library/constraint
  library/valueExpression
  library/strategy
  library/basicTypes
 
  library/environment
  
 rules
 	
			
			
/* 	lookup-input-type:
		Takes a class name, and a method name, and an input name,
		and a model, 
		and returns the type of that input in the model 	
*/

	lookup-input-type:
		((classname, methname), inputname)
			-> type
		where
			type := <lookup>(inputname,<lookup>((classname, methname), <LookupTable> "Inputs"))
			
	lookup-input-type:
			e -> String()
		where
			log(|Error(), "lookup-input-type fail", e)
			
			
/* 	lookup-input-type:
		Takes a class name, and a method name, and an input name,
		and a model, 
		and returns the type of that input in the model 	
*/

	lookup-output-type:
		(((classname, methname), outputname))
			-> type
		where
			type := <lookup>(outputname,<lookup>((classname, methname), <LookupTable> "Outputs"))
			
			
			
			
		
			
		
	get-type-constraint:
		path { BasicType(t) } 
			-> BinRel(path, In(), <get-type-extent> t)

	get-type-constraint:
		path { Optional(BasicType(t)) } 
			-> Or(BinRel(path, In(), <get-type-extent> t), BinRel(path, Equal(), Null()))
			

	get-type-constraint:
		path { Set(BasicType(t)) }
			-> BinRel(path, SubsetEquals(), <get-type-extent> t)


	get-type-constraint:
		path { Reference(name1) }
			-> BinRel(path, In(), PathStart(name1, None()))

	
	get-type-constraint:
		path { Optional(Reference(name1)) } 
			-> Or(BinRel(path, In(), PathStart(name1, None()){ Set(Reference(name1)) }), BinRel(path, Equal(), Null()))
			

	get-type-constraint:
		path { Set(Reference(name1)) }
			-> BinRel(path, SubsetEquals(), PathStart(name1, None()){ Set(Reference(name1)) })
							
	get-type-constraint:
		something -> True()
			where log(|Error(), "get-type-constraint problem", something)									
			
			
			


	lookup-invariant:
		(classname, attname)
			->  inv
		where
			inv := <get-attribute-constraint> (classname, attname)
			
	

		


/*	lookup-invariants:
		(l, abm)
			-> []
		where
			debug */ 
			

	lookup-system-name:
		x -> <LookupTable> "Name"

	lookup-classes:
		x -> <LookupTable> "Classes"




	add-class-id:
		(classname, attname) ->
			[]
		where
			ids := (<LookupTable> "IDs");
			ids' := <union>(ids, [(classname, attname)]);
			rules(
				LookupTable :+ "IDs" -> ids'
			)

	add-class-id:
		(classname, attname) ->
			[]
		where
			rules(
				LookupTable :+ "IDs" -> [(classname, attname)]
			)

	get-class-ids:
		x
			-> elems
		where
			elems := <LookupTable> "Ids"
			

/***** TODO *****/
/*
	get-attribute-constraint:
		(classname, attname) -> constraint
			where		
				constraint := <lookup>((classname, attname), <LookupTable> "ClassBasedInvariants")

	get-attribute-constraint:
		(classname, attname) -> True()
				
*/				
	get-attribute-constraint:
		(classname, attname) -> True()
