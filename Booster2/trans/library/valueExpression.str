module library/valueExpression

imports
  include/Booster2
  
  library/lookupTable
  library/abstractBoosterModel
  library/constraint
  library/relation
  library/expression
  library/basicTypes
  library/environment
  
 rules
 	
	

			
	
			

/* 	get-path-initial-path:
		takes a path, and returns the path of the owner object			
*/

	get-path-initial-path:
		(This()) -> This()
		
	get-path-initial-path:
		(ThisPrimed()) -> This()
		
	get-path-initial-path:
		(PathStart(name, maybePrimed)) -> This()		

	get-path-initial-path:
		(Path(ps, pc)) -> ps		

	get-path-initial-path:
		(Input(name)) -> Input(name)
		
	get-path-initial-path:
		(Output(name)) -> Output(name)
		
		 
		
		

/* 	get-path-attribute-name:
		takes a path, and returns the name of the resulting attribute			
*/

	get-path-attribute-name:
		(This()) -> Null()
		
	get-path-attribute-name:
		(ThisPrimed()) -> Null()
		
	get-path-attribute-name:
		(PathStart(name, maybePrimed)) -> name		

	get-path-attribute-name:
		(Path(ps, PathComponent(name, maybePrimed))) -> name		

	get-path-attribute-name:
		(Input(name)) -> Null()
		
	get-path-attribute-name:
		(Output(name)) -> Null()
		

/* 	get-path-attribute:
		
*/

	get-path-attribute:
		Path(a {Reference(cname2)},PathComponent(aname, maybePrimed))
			-> (cname2, aname)

	get-path-attribute:
		Path(a {Optional(Reference(cname2))},PathComponent(aname, maybePrimed))
			-> (cname2, aname)

			
/* 	get-expression-type
*/

	get-expression-type:
		(BasicValue(t), classname, methodname, env)
			-> <get-corresponding-booster-type> t


	get-expression-type:
		(TypeExtent(t), classname, methodname, env)
			-> Set(t)


	get-expression-type:
		(Null(), classname, methodname, env)
			-> Null()

	get-expression-type:
		(This(), classname, methodname, env)
			-> Reference(classname)


	get-expression-type:
		(ThisPrimed(), classname, methodname, env)
			-> Reference(classname)


	get-expression-type:
		(Input(inputname), classname, methodname, env)
			-> <lookup-input-type>((classname, methodname), inputname)

	get-expression-type:
		(Output(outputname), classname, methodname, env)
			-> <lookup-output-type>((classname, methodname), outputname)

	get-expression-type:
		(SetExtent([]), classname, methodname, env)
			-> Null()

	get-expression-type:
		(SetExtent([x, xs*]), classname, methodname, env)
			-> Set(t)
		where
			t := <get-expression-type> (x, classname, methodname, env);
			Set(t) := <get-expression-type>(SetExtent([xs*]), classname, methodname, env)

	get-expression-type:
		(SetExtent([x, xs*]), classname, methodname, env)
			-> Set(t)
		where
			t := <get-expression-type> (x, classname, methodname, env);
			Null() := <get-expression-type>(SetExtent([xs*]), classname, methodname, env)

	get-expression-type:
		(PathStart(attname, maybeprimed), classname, methodname, env)
			-> type
		where
			type := <lookup-attribute-type> ((classname, attname))

	get-expression-type:
		(PathStart(name, maybePrimed), classname, methodname, env)
			-> Set(Reference(name))
			where
				<is-class-name> name

	get-expression-type:
		(PathStart(svalue, maybePrimed), classname, methodname, env)
			-> Reference(sname)
			where
				sname := <lookup-set-value> svalue

	get-expression-type:
		(PathStart(name, maybePrimed), classname, methodname, env)
			-> Set(Reference(name))
			where
				<is-set-name> name

	get-expression-type:
		(Path(ps, PathComponent(attname, maybeprimed)), classname, methodname, env)
			-> t
		where
			Reference(otherclassname) := <get-expression-type> (ps, classname, methodname, env);
			t := <lookup-attribute-type> ((otherclassname, attname))
			
	get-expression-type:
		(Path(ps, PathComponent(attname, maybeprimed)), classname, methodname, env)
			-> t
		where
			Optional(Reference(otherclassname)) := <get-expression-type> (ps, classname, methodname, env);
			t := <lookup-attribute-type> ((otherclassname, attname))




	get-expression-type:
		something -> BasicValue(Int())
			where
				log(|Error(), "Get Expression Type", something)

			
			
/* 	resolve-path-type:
		Takes a path, the class where it is found, the model, 
		and optionally a method where it is found, and returns its type 	
*/

	resolvePathType:
		(classname, path {type}, method, env)
		 	-> type


	resolve-path-type:
		(classname, This(), method, env) 
			-> Reference(classname)

	resolve-path-type:
		(classname, ThisPrimed(), method, env) 
			-> Reference(classname)
			
	resolve-path-type:
		(classname, Input(attname), (classname, methname), env)
			-> type
		where
			type := <lookup-input-type>((classname, methname), attname)
			
	resolve-path-type:
		(classname, Output(attname), (classname, methname), env)
			-> type
		where
			type := <lookup-output-type>(((classname, methname), attname))


	
	resolve-path-type:
		(classname, PathStart(name, None()), method, env)
			-> (Reference(name))
		where
			<is-set-name> name

	resolve-path-type:
		(classname, PathStart(svalue, None()), method, env)
			-> Reference(sname)
		where
			sname := <lookup-set-value> (svalue)

	resolve-path-type:
		(classname, PathStart(attname, maybeprimed), method, env)
			-> Set(Reference(attname))
		where
			<is-class-name> attname
						
	resolve-path-type:
		(classname, PathStart(attname, maybeprimed), method, env)
			-> type
		where
			type := <lookup-attribute-type>(classname, attname)

	resolve-path-type:
		(classname, PathStart(varname, maybeprimed), method, env)
			-> type
		where
			type := <lookup-environment-type>(varname, env)


	resolve-path-type:
		(classname, Path(path, PathComponent(attname, maybeprimed)), method, env)
			->  type
		where
			Optional(Reference(classname2)) := <resolve-path-type> (classname, path, method, env);
			type := <lookup-attribute-type>((classname2, attname))

	resolve-path-type:
		(classname, Path(path, PathComponent(attname, maybeprimed)), method, env)
			-> type
		where
			Reference(classname2) := <resolve-path-type> (classname, path, method, env);
			type := <lookup-attribute-type>((classname2, attname))
		
		
	/* resolve-path-type:
			e -> String()
		where
			log(|Error(), "resolve-path-type fail", e)	*/
		
/*	resolve-path-type:
		(arg1, arg2, arg3)
			-> <resolve-path-type> (arg1, arg2, arg3, [])
*/
					

		

	is-defined:
		 (classname, method, BasicValue(t), env)
		 	-> BinRel(BasicValue(t), In(), typeExtent)
		 where
		 	t' := <get-corresponding-booster-type> t;
		 	typeExtent := <get-type-extent> t'
		 		 	
	is-defined:
		 (classname, method, TypeExtent(t), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, Null(), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, Input(i), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, Output(i), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, This(), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, ThisPrimed(), env)
		 	-> True()

	is-defined:
		 (classname, method, Path(a,b), env)
		 	-> And(constraint, BinRel(a, NotEqual(), Null()))
		 where
		 	Optional(type) := <resolve-path-type>(classname, a, method, env);
		 	constraint := <is-defined> (classname, method, a, env) 

	is-defined:
		 (classname, method, Path(a,b), env)
		 	-> <is-defined> (classname, method, a, env)

	is-defined:
		 (classname, method, PathStart(a,maybeprimed), env)
		 	-> True()

	is-defined:
		 (classname, method, PathComponent(a,maybeprimed), env)
		 	-> <is-defined> (classname, method, a, env) 
		 	
	is-defined:
		 (classname, method, SetExtent([]), env)
		 	-> True()
	
	is-defined:
		 (classname, method, SetExtent([elem, elems*]), env)
		 	-> And(constraint1, constraint2)
		 where
		 	constraint1 := <is-defined> (classname, method, elem, env);
		 	constraint2 := <is-defined> (classname, method, SetExtent([elems*]), env) 
	
	
	// I removed this catch-rule again.
	/*
	 is-defined:
		(classname, method, expr,env) -> 
			True()
		where
			log(|Error(), " Error!", classname);
			log(|Error(), method, expr) 
	*/	 	
		
 