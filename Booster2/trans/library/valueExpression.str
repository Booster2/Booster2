module library/valueExpression

imports
  include/Booster2
  
  library/abstractBoosterModel
  library/constraint
  library/relation
  library/expression
  library/basicTypes
  library/environment
  
 rules
 	
	
/* 	get-mentioned-attributes:
		takes an expression, in the context of a class, maybe a method name,
		and a model, and returns the list of attributes that it
		constrains.			
*/		
	get-mentioned-attributes:
		(name, maybename, BasicValue(t), env)
			-> []
			

	get-mentioned-attributes:
		(name, maybename, TypeExtent(t), env)
			-> []

	get-mentioned-attributes:
		(name, maybename, Null(), env)
			-> []

	get-mentioned-attributes:
		(name, maybename, This(), env)
			-> []

	get-mentioned-attributes:
		(name, maybename, ThisPrimed(), env)
			-> []
					
	get-mentioned-attributes:
		(name, maybename, Input(i), env)
			-> []
					
	get-mentioned-attributes:
		(name, maybename, Output(o), env)
			-> []
					
	get-mentioned-attributes:
		(name, maybename, SetExtent([]), env)
			-> []

	get-mentioned-attributes:
		(name, maybename, SetExtent([expr, exprs*]), env)
			-> <union>(atts1, atts2)
		where
			atts1 := <get-mentioned-attributes>(name, maybename, expr, env);
			atts2 := <get-mentioned-attributes>(name, maybename, SetExtent([exprs*]), env)
			
	get-mentioned-attributes:
		(classname, maybename, PathStart(attname, maybeprimed), env)
			-> [(classname, attname)]
		where
			type := <lookup-attribute-type> ((classname, attname))
		// i.e. the attribute does exist
		
/*	get-mentioned-attributes:
		(classname, maybename, PathComponent(attname, maybeprimed), env)
			-> [(classname, attname)]
		where
			type := <lookup-attribute-type> ((classname, attname))
		// i.e. the attribute does exist
*/

	get-mentioned-attributes:
		(classname, maybename, Path(path, PathComponent(attname, maybeprimed)), env)
			-> <union>(atts1, [(otherclassname, attname)])
		where
			atts1 := <get-mentioned-attributes>(classname, maybename, path, env);
			Reference(otherclassname) := <resolve-path-type>(classname, path, (classname, maybename), env);
			type := <lookup-attribute-type> ((otherclassname, attname))
			
	get-mentioned-attributes:
		(classname, maybename, Path(path, PathComponent(attname, maybeprimed)), env)
			-> <union>(atts1, [(otherclassname, attname)])
		where
			atts1 := <get-mentioned-attributes>(classname, maybename, path, env);
			Optional(Reference(otherclassname)) := <resolve-path-type>(classname, path, (classname, maybename) , env);
			type := <lookup-attribute-type> ((otherclassname, attname))
	
	get-mentioned-attributes:
		(classname, maybename, PathStart(name, maybeprimed), env)
			-> []
		where
			setname := <lookup-set-name> name;
			<equal>(setname, name)

	get-mentioned-attributes:
		(classname, maybename, PathStart(name, maybeprimed), env)
			-> []
		where
			setname := <lookup-set-value> name

	get-mentioned-attributes:
		(classname, maybename, PathStart(varname, maybeprimed), env)
			-> atts
		where
			atts := <lookup-environment-mentioned-attributes> (varname, env)
			
	
/* 	is-old:
		takes a value expression, and returns True() or False()
		depending on whether the expression can be evaluated in the pre-state
		or not. 			
*/


	is-old:
		BasicValue(t) 
			-> True()
			
	is-old:
		TypeExtent(t)
			-> True()

			
	is-old:
		Null()
			-> True()
			
	is-old:
		Input(inputname)
			-> True()
			
	is-old:
		Output(outputname)
			-> False()
			
	is-old:
		This()
			-> True()
			
	is-old:
		ThisPrimed()
			-> False()

	is-old:
		Path(a,b)
			-> True()
		where
			True() := <is-old> (a);
			True() := <is-old> (b)		
	
	is-old:
		PathComponent(name, Some(Primed()))
			-> False()

	is-old:
		PathComponent(name, None())
			-> True()

	is-old:
		PathStart(name, Some(Primed()))
			-> False()

	is-old:
		PathStart(name, None())
			-> True()
			
	is-old:
		SetExtent([])
			-> True()

	is-old:
		SetExtent([expr1, exprs1*])
			-> True()
		where
			True() := <is-old> expr1;
			True() := <is-old> SetExtent([exprs1*])
			
	// default
	
	is-old:
		anything
			-> False()


/* 	get-path-initial-path:
		takes a path, and returns the path of the owner object			
*/

	get-path-initial-path:
		(This()) -> This()
		
	get-path-initial-path:
		(ThisPrimed()) -> This()
		
	get-path-initial-path:
		(PathStart(name, maybePrimed)) -> This()		

	get-path-initial-path:
		(Path(ps, pc)) -> ps		

	get-path-initial-path:
		(Input(name)) -> Input(name)
		
	get-path-initial-path:
		(Output(name)) -> Output(name)
		
		 
		
		

/* 	get-path-attribute-name:
		takes a path, and returns the name of the resulting attribute			
*/

	get-path-attribute-name:
		(This()) -> Null()
		
	get-path-attribute-name:
		(ThisPrimed()) -> Null()
		
	get-path-attribute-name:
		(PathStart(name, maybePrimed)) -> name		

	get-path-attribute-name:
		(Path(ps, PathComponent(name, maybePrimed))) -> name		

	get-path-attribute-name:
		(Input(name)) -> Null()
		
	get-path-attribute-name:
		(Output(name)) -> Null()
		

/* 	get-path-attribute:
		
*/
	get-path-attribute:
		(classname, methodname, Output(name), env)
			-> []

	get-path-attribute:
		(classname, methodname, Input(name), env)
			-> []

	get-path-attribute:
		(classname, methodname, Path(a,b), env)
			-> [(classname2, attname)]
		where
			Reference(classname2) := <resolve-path-type> (classname, a, (classname, methodname), env);
			attname := <get-path-attribute-name> (Path(a,b))

	get-path-attribute:
		(classname, methodname, Path(a,b), env)
			-> [(classname2, attname)]
		where
			Optional(Reference(classname2)) := <resolve-path-type> (classname, a, (classname, methodname), env);
			attname := <get-path-attribute-name> (Path(a,b))
			
/* 	get-expression-type
*/

	get-expression-type:
		(BasicValue(t), classname, methodname, env)
			-> <get-corresponding-booster-type> t


	get-expression-type:
		(TypeExtent(t), classname, methodname, env)
			-> Set(t)


	get-expression-type:
		(Null(), classname, methodname, env)
			-> Null()

	get-expression-type:
		(This(), classname, methodname, env)
			-> Reference(classname)


	get-expression-type:
		(ThisPrimed(), classname, methodname, env)
			-> Reference(classname)


	get-expression-type:
		(Input(inputname), classname, methodname, env)
			-> <lookup-input-type>((classname, methodname), inputname)

	get-expression-type:
		(Output(outputname), classname, methodname, env)
			-> <lookup-output-type>((classname, methodname), outputname)

	get-expression-type:
		(SetExtent([]), classname, methodname, env)
			-> Null()

	get-expression-type:
		(SetExtent([x, xs*]), classname, methodname, env)
			-> Set(t)
		where
			t := <get-expression-type> (x, classname, methodname, env);
			Set(t) := <get-expression-type>(SetExtent([xs*]), classname, methodname, env)

	get-expression-type:
		(SetExtent([x, xs*]), classname, methodname, env)
			-> Set(t)
		where
			t := <get-expression-type> (x, classname, methodname, env);
			Null() := <get-expression-type>(SetExtent([xs*]), classname, methodname, env)

	get-expression-type:
		(PathStart(attname, maybeprimed), classname, methodname, env)
			-> type
		where
			type := <lookup-attribute-type> ((classname, attname))

	get-expression-type:
		(PathStart(name, maybePrimed), classname, methodname, env)
			-> Set(Reference(name))
			where
				<equal>(name, <lookup-class-name> name)

	get-expression-type:
		(PathStart(name, maybePrimed), classname, methodname, env)
			-> Reference(name)
			where
				<equal>(name, <lookup-set-value> name)

	get-expression-type:
		(PathStart(name, maybePrimed), classname, methodname, env)
			-> Set(Reference(name))
			where
				<equal>(name, <lookup-set-name> name)

	get-expression-type:
		(Path(ps, PathComponent(attname, maybeprimed)), classname, methodname, env)
			-> t
		where
			Reference(otherclassname) := <get-expression-type> (ps, classname, methodname, env);
			t := <lookup-attribute-type> ((otherclassname, attname))
			
	get-expression-type:
		(Path(ps, PathComponent(attname, maybeprimed)), classname, methodname, env)
			-> t
		where
			Optional(Reference(otherclassname)) := <get-expression-type> (ps, classname, methodname, env);
			t := <lookup-attribute-type> ((otherclassname, attname))




	get-expression-type:
		something -> BasicValue(Int())
			where
				log(|Error(), "Get Expression Type", something)

	/*literal-substitute:
		(classname, methodname, path, paths, expression, env)
		 	-> expression
		 where
		 	log(|Error(), "literal-subst", (path, paths)) */

	literal-substitute:
		(classname, methodname, path, paths, expression, env)
		 	-> expression
		 where
		 	<elem>(path, paths)



	literal-substitute:
		(classname, methodname, BasicValue(t), paths, expression, env)
		 	-> BasicValue(t)
		 	
	literal-substitute:
		(classname, methodname, TypeExtent(t), paths, expression, env)
			-> TypeExtent(t)

	literal-substitute:
		(classname, methodname, Null(), paths, expression, env)
			-> Null()

	literal-substitute:
		(classname, methodname, This(), paths, expression, env)
			-> This()

	literal-substitute:
		(classname, methodname, PathStart(a, b), paths, expression, env)
			-> PathStart(a,b)


	literal-substitute:
		(classname, methodname, Path(a, b), paths, expression, env)
			-> Path(path1,b)
		where 
			path1 := <literal-substitute>(classname, methodname, a, paths, expression, env)
			
	literal-substitute:
		(classname, methodname, Input(i), paths, expression, env)
			-> Input(i)

	literal-substitute:
		(classname, methodname, Output(i), paths, expression, env)
			-> Output(i)

	literal-substitute:
		(classname, methodname, SetExtent([]), paths, expression, env)
			-> SetExtent([])

	literal-substitute:
		(classname, methodname, SetExtent([exp, exps*]), paths, expression, env)
			-> SetExtent([exp1, exps1*])
		where
			exp1 := <literal-substitute>(classname, methodname, exp, paths, expression, env);
			SetExtent([exps1*]) := <literal-substitute>(classname, methodname, SetExtent([exps*]), paths, expression, env)
						
/*	literal-substitute:
		(classname, methodname, expression1, paths, expression2, env)
			-> expression1
		where
			log(|Error(), "Literal Substitute nightmare", (classname, methodname, expression1, paths, expression2, env))
*/			
			
			
/* 	resolve-path-type:
		Takes a path, the class where it is found, the model, 
		and optionally a method where it is found, and returns its type 	
*/

	resolve-path-type:
		(classname, This(), method, env) 
			-> Reference(classname)

	resolve-path-type:
		(classname, ThisPrimed(), method, env) 
			-> Reference(classname)
			
	resolve-path-type:
		(classname, Input(attname), (classname, methname), env)
			-> type
		where
			type := <lookup-input-type>((classname, methname), attname)
			
	resolve-path-type:
		(classname, Output(attname), (classname, methname), env)
			-> type
		where
			type := <lookup-output-type>(((classname, methname), attname))


	
	resolve-path-type:
		(classname, PathStart(attname, None()), method, env)
			-> (Reference(attname))
		where
			<equal>(attname, <lookup-set-name>attname)

	resolve-path-type:
		(classname, PathStart(attname, None()), method, env)
			-> Reference(setname)
		where
			setname := <lookup-set-value> (attname);
			not(<equal>(setname, ()))

	resolve-path-type:
		(classname, PathStart(attname, maybeprimed), method, env)
			-> Set(Reference(attname))
		where
			<equal>(attname, <lookup-class-name>(attname))
						
	resolve-path-type:
		(classname, PathStart(attname, maybeprimed), method, env)
			-> type
		where
			type := <lookup-attribute-type>(classname, attname)

	resolve-path-type:
		(classname, PathStart(varname, maybeprimed), method, env)
			-> type
		where
			type := <lookup-environment-type>(varname, env)


	resolve-path-type:
		(classname, Path(path, PathComponent(attname, maybeprimed)), method, env)
			->  type
		where
			Optional(Reference(classname2)) := <resolve-path-type> (classname, path, method, env);
			type := <lookup-attribute-type>((classname2, attname))

	resolve-path-type:
		(classname, Path(path, PathComponent(attname, maybeprimed)), method, env)
			-> type
		where
			Reference(classname2) := <resolve-path-type> (classname, path, method, env);
			type := <lookup-attribute-type>((classname2, attname))
		
		
	/* resolve-path-type:
			e -> String()
		where
			log(|Error(), "resolve-path-type fail", e)	*/
		
/*	resolve-path-type:
		(arg1, arg2, arg3)
			-> <resolve-path-type> (arg1, arg2, arg3, [])
*/
					

/* 	make-old:
		Takes an expression, and returns its representation in the
		pre-state of a method
*/

	make-old:
		BasicValue(t)
			-> BasicValue(t)
			
	make-old:
		TypeExtent(t)
			-> TypeExtent(t)
			
	make-old:
		Null()
			-> Null()
			
	make-old:
		Input(inputname)
			-> Input(inputname)
			
	make-old:
		Output(outputname)
			-> Output(outputname)
			
	make-old:
		This()
			-> This()
			
	make-old:
		ThisPrimed()
			-> ThisPrimed()

	make-old:
		Path(a,b)
			-> Path(c,d)
		where
			c := <make-old> (a);
			d := <make-old> (b)		
	
	make-old:
		PathComponent(name, Some(Primed()))
			-> PathComponent(name, None())

	make-old:
		PathComponent(name, None())
			-> PathComponent(name, None())

	make-old:
		PathStart(name, Some(Primed()))
			-> PathStart(name, None())

	make-old:
		PathStart(name, None())
			-> PathStart(name, None())
			
	make-old:
		SetExtent([])
			-> SetExtent([])

	make-old:
		SetExtent([expr1, exprs1*])
			-> SetExtent([expr2, exprs2*])
		where
			expr2 := <make-old> expr1;
			SetExtent([exprs2*]) := <make-old> SetExtent([exprs1*])

/*	make-old:
		something -> True()
		 		where
 			log(|Error(),"make-old", something) 
*/
			

/* 	make-post-state:
		Takes an expression, and returns its representation in the
		pre-state of a method
*/

	make-post-state:
		BasicValue(t) 
			-> BasicValue(t)
			
	make-post-state:
		TypeExtent(t)
			-> TypeExtent(t)
			
	make-post-state:
		Null()
			-> Null()
			
	make-post-state:
		Input(inputname)
			-> Input(inputname)
			
	make-post-state:
		Output(outputname)
			-> Output(outputname)
			
	make-post-state:
		This()
			-> This()
			
	make-post-state:
		ThisPrimed()
			-> ThisPrimed()

	make-post-state:
		Path(a,b)
			-> Path(c,d)
		where
			c := <make-post-state> (a);
			d := <make-post-state> (b)		
	
	make-post-state:
		PathComponent(name, Some(Primed()))
			-> PathComponent(name, Some(Primed()))

	make-post-state:
		PathComponent(name, None())
			-> PathComponent(name, Some(Primed()))

	make-post-state:
		PathStart(name, Some(Primed()))
			-> PathStart(name, Some(Primed()))

	make-post-state:
		PathStart(name, None())
			-> PathStart(name, Some(Primed()))
			
	make-post-state:
		SetExtent([])
			-> SetExtent([])

	make-post-state:
		SetExtent([expr1, exprs1*])
			-> SetExtent([expr2, exprs2*])
		where
			expr2 := <make-post-state> expr1;
			SetExtent([exprs2*]) := <make-post-state> SetExtent([exprs1*])
	

 	/*make-post-state:
 		x
 		-> True()
 		where
 			log(|Error(),"make-post-state", x) */ 
 
 
/* 	get-mentioned-paths:
		takes an expression, in the context of a class, maybe a method name,
		and a model, and returns the list of attributes that it
		constrains.			
*/		
	get-mentioned-paths:
		(name, maybename, BasicValue(t), env)
			-> []
			

	get-mentioned-paths:
		(name, maybename, TypeExtent(t), env)
			-> []

	get-mentioned-paths:
		(name, maybename, Null(), env)
			-> []

	get-mentioned-paths:
		(name, maybename, This(), env)
			-> [This()]

	get-mentioned-paths:
		(name, maybename, ThisPrimed(), env)
			-> [This()]
					
	get-mentioned-paths:
		(name, maybename, Input(i), env)
			-> [Input(i)]
					
	get-mentioned-paths:
		(name, maybename, Output(o), env)
			-> [Output(o)]
					
	get-mentioned-paths:
		(name, maybename, SetExtent([]), env)
			-> []

	get-mentioned-paths:
		(name, maybename, SetExtent([expr, exprs*]), env)
			-> <union>(atts1, atts2)
		where
			atts1 := <get-mentioned-paths>(name, maybename, expr, env);
			atts2 := <get-mentioned-paths>(name, maybename, SetExtent([exprs*]), env)
			
	get-mentioned-paths:
		(classname, maybename, PathStart(attname, maybeprimed), env)
			-> [PathStart(attname, maybeprimed)]
		where
			type := <lookup-attribute-type> ((classname, attname))
		// i.e. the attribute does exist
		
/*	get-mentioned-attributes:
		(classname, maybename, PathComponent(attname, maybeprimed), env)
			-> [(classname, attname)]
		where
			type := <lookup-attribute-type> ((classname, attname))
		// i.e. the attribute does exist
*/

	get-mentioned-paths:
		(classname, methodname, Path(path, PathComponent(attname, maybeprimed)), env)
			-> <union>(paths1, [Path(path, PathComponent(attname, maybeprimed))])
		where
			paths1 := <get-mentioned-paths>(classname, methodname, path, env);
			Reference(otherclassname) := <resolve-path-type>(classname, path, (classname, methodname), env);
			type := <lookup-attribute-type> ((otherclassname, attname))
			
	get-mentioned-paths:
		(classname, methodname, Path(path, PathComponent(attname, maybeprimed)), env)
			-> <union>(paths1, [Path(path, PathComponent(attname, maybeprimed))])
		where
			paths1 := <get-mentioned-paths>(classname, methodname, path, env);
			Optional(Reference(otherclassname)) := <resolve-path-type>(classname, path, (classname, methodname), env);
			type := <lookup-attribute-type> ((otherclassname, attname))
	
	get-mentioned-paths:
		(classname, maybename, PathStart(name, maybeprimed), env)
			-> []
		where
			setname := <lookup-set-name> name;
			<equal>(setname, name)

	get-mentioned-paths:
		(classname, maybename, PathStart(name, maybeprimed), env)
			-> []
		where
			setname := <lookup-set-value> name

	get-mentioned-paths:
		(classname, maybename, PathStart(varname, maybeprimed), env)
			-> paths
		where
			paths := <lookup-environment-mentioned-paths> (varname, env)
 
/* 	get-mentioned-paths:
 		(classname, maybename, Path(path, PathComponent(attname, maybeprimed)), env)
			-> [] *//* 
			
			<union>(paths1, [Path(path, PathComponent(attname, maybeprimed))])
		where
			paths1 := <get-mentioned-paths>(classname, maybename, path, env);
			Optional(Reference(otherclassname)) := <resolve-path-type>(classname, path, maybename, env);
			type := <lookup-attribute-type> ((otherclassname, attname))

 		something -> []
*/ 		
/* 		where log(|Error(), "get-mentioned-paths Error", (classname, path, maybename, env)) */
 		
		/* 	is-defined
*/

	is-defined:
		 (classname, method, BasicValue(t), env)
		 	-> BinRel(BasicValue(t), In(), typeExtent)
		 where
		 	t' := <get-corresponding-booster-type> t;
		 	typeExtent := <get-type-extent> t'
		 		 	
	is-defined:
		 (classname, method, TypeExtent(t), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, Null(), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, Input(i), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, Output(i), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, This(), env)
		 	-> True()
		 	
	is-defined:
		 (classname, method, ThisPrimed(), env)
		 	-> True()

	is-defined:
		 (classname, method, Path(a,b), env)
		 	-> And(constraint, BinRel(a, NotEqual(), Null()))
		 where
		 	Optional(type) := <resolve-path-type>(classname, a, method, env);
		 	constraint := <is-defined> (classname, method, a, env) 

	is-defined:
		 (classname, method, Path(a,b), env)
		 	-> <is-defined> (classname, method, a, env)

	is-defined:
		 (classname, method, PathStart(a,maybeprimed), env)
		 	-> True()

	is-defined:
		 (classname, method, PathComponent(a,maybeprimed), env)
		 	-> <is-defined> (classname, method, a, env) 
		 	
	is-defined:
		 (classname, method, SetExtent([]), env)
		 	-> True()
	
	is-defined:
		 (classname, method, SetExtent([elem, elems*]), env)
		 	-> And(constraint1, constraint2)
		 where
		 	constraint1 := <is-defined> (classname, method, elem, env);
		 	constraint2 := <is-defined> (classname, method, SetExtent([elems*]), env) 
	
	
	// I removed this catch-rule again.
	/*
	 is-defined:
		(classname, method, expr,env) -> 
			True()
		where
			log(|Error(), " Error!", classname);
			log(|Error(), method, expr) 
	*/	 	
		
 