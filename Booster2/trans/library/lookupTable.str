module lookupTable

imports
  include/Booster2  
  
 

rules
			
	replaceClass(s):
		(oldClassName)
			-> (oldClassName)
		where
			currentlyKnownClasses := <LookupTable> "Class";
			oldClass := <lookup>(oldClassName, currentlyKnownClasses);
			newClasses := <union>(<diff>(currentlyKnownClasses, [(oldClassName, oldClass)]), [<s>(oldClassName, oldClass)]);
			rules(
				LookupTable :+ "Class" -> newClasses
			)
			
	replaceMethod(s):
		(cname, mname)
			-> (cname, mname)
		where
			currentlyKnownMethods := <LookupTable> "Method";
			oldMethod := <lookup>((cname, mname), currentlyKnownMethods);
			newMethods := <union>(<diff>(currentlyKnownMethods, [((cname, mname), oldMethod)]), [<s>((cname, mname), oldMethod)]);
			rules(
				LookupTable :+ "Method" -> newMethods
			)
			
	addInput:
		(cname, mname, input, type)
			-> (cname, mname, input, type)
		where
			<replaceMethod(\ ((c,a),(co,gc,e,d,is,os)) -> ((c,a),(co,gc,e,d,<union>(is, [(input, type)]),os)) \)> (cname, mname)
			
	addOutput:
		(cname, mname, output, type)
			-> (cname, mname, output, type)
		where 
			<replaceMethod(\ ((c,a),(co,gc,e,d,is,os)) -> ((c,a),(co,gc,e,d,is, <union>(os, [(output, type)]))) \)> (cname, mname)
			
	addClassAttribute = (\ (cname, aname, adef) -> (cname, aname, adef) where
				<replaceClass(\ (cn, (is,as,a,m,c,w)) -> (cn, (is,as, <union>(a, [aname]),m,c,w))\)> cname ;
				prevTable := <LookupTable> "Attribute";
				newTable := <union>(prevTable, [((cname, aname), adef)]);
				rules(
					LookupTable :+ "Attribute" -> newTable
				) \)		
				
	addClassMethod = (\ (cname, mname, mdef) -> (cname, mname, mdef) where
				<replaceClass(\ (cn, (is,as,a,m,c,w)) -> (cn, (is, as, a, <union>(m, [mname]),c,w))\)> cname ;
				prevTable := <LookupTable> "Method";
				<not(lookup)>((cname, mname), prevTable);
				newTable := <union>(prevTable, [((cname, mname), mdef)]);
				rules(
					LookupTable :+ "Method" -> newTable
				) \)
				
	updateClassMethod = (\ (cname, mname, constraint, extcname, exts, inputs, outputs) -> (cname, mname, constraint, extcname, exts, inputs, outputs) where
				<replaceMethod(\ ((cn, mn), (c, gc, exts', done, is, os)) -> ((cn, mn), (And(c, constraint), gc, <union>([extcname], <union>(exts', exts)), done, is, os)) \)> (cname, mname) \)
				

	addClassInvariant = (\ (cname, inv) -> (cname, inv) where
				<replaceClass(\ (cn, (is,as,a,m,c,w)) -> (cn, (is,as, a ,m,<union>(c, [inv]),w))\)> cname \) 

	updateMethodConstraint = (\ (cname, mname, newConstraint) -> (cname, mname, newConstraint) where
				<replaceMethod(\ ((c,m),(co,gc,e,d,is,os)) -> ((c,m),(newConstraint,gc,e,d,is,os)) \)> (cname, mname) \)
				

	getInputType:
		(cname, mname, iname)
			-> types
		where
			types := <lookup>(iname, (<\(c,gc,e,d, is,os) -> is \> <lookup> ((cname, mname), <LookupTable> "Method")))
	
	getOutputType:
		(cname, mname, oname)
			-> types
		where
			types := <lookup>(oname, (<\(c,gc,e,d, is,os) -> os \> <lookup> ((cname, mname), <LookupTable> "Method")))
							