module simplify

imports
  include/Booster2


library/lookupTable
translate/booster/booster  
  
rules

	simplify-main:
		system -> system
		where
			simp-programs := <map(\((cname, mname), (constraint, gc, exts, done, ins, outs)) -> <simp> (cname, mname, gc)\)> <LookupTable> "Method"
			
	simp:
		(cname, mname, prog) 
			-> (cname, mname, prog) 
		where 
			prog' := <innermost(simplify <+ simplify-assume-inv)> prog;
			<updateMethodProgram>(cname, mname, prog')
			
	
	simplify-assume-inv:
		BinRel(Path(ps, PathComponent(attname, None())){BasicType(t)}, 
				In(), 
				TypeExtent(ext){ Set(BasicType(t))})
			-> True() 
	
	simplify-assume-inv:
		BinRel(Path(ps {Reference(classname)}, PathComponent(attname, None())){Set(Reference(classname'))},
				SubsetEquals(),
				PathStart(classname', None()){Set(Reference(classname'))})
			-> True()
		where
			(ds, Set(Reference(classname')), opp, min, max, s) := <lookup>((classname, attname), <LookupTable>"Attribute")

	simplify-assume-inv:
		BinRel(Path(ps {Optional(Reference(classname))}, PathComponent(attname, None())){Set(Reference(classname'))},
				SubsetEquals(),
				PathStart(classname', None()){Set(Reference(classname'))})
			-> True()
		where
			(ds, Set(Reference(classname')), opp, min, max, s) := <lookup>((classname, attname), <LookupTable>"Attribute")

	simplify-assume-inv:
		BinRel(Path(ps {Optional(Reference(classname))}, PathComponent(attname, None())){Reference(classname')},
				In(),
				PathStart(classname', None()){Set(Reference(classname'))})
			-> True()
		where
			(ds, Reference(classname'), opp, min, max, s) := <lookup>((classname, attname), <LookupTable>"Attribute")

			
	// Some normalisation rules?
			
	 simplify:
		And(p, And(q,r))
			-> And(And(p,q), r)
	
	simplify:
		Parallel(p, Parallel(q,r))
			-> Parallel(Parallel(p,q),r)
	
	simplify:
		BinRel(a, Equal(), b)
			-> BinRel(b, Equal(), a)
		where
			<string-lt>(<expression>b, <expression>a);
			<not(equal)>(Null(), b)

	simplify:
		BinRel(a, NotEqual(), b)
			-> BinRel(b, NotEqual(), a)
		where
			<string-lt>(<expression>b, <expression>a);
			<not(equal)>(Null(), b)

	simplify:
		And(a, b)
			-> And(b, a)
		where
			<string-lt>(<constraint>b, <constraint>a)

	simplify:
		And(And(a, b), c)
			-> And(And(a, c), b)
		where
			<string-lt>(<constraint>b, <constraint>c)


	simplify:
		Or(a, b)
			-> Or(b, a)
		where
			<string-lt>(<constraint>b, <constraint>a)

	simplify:
		Parallel(a, b)
			-> Parallel(b, a)
		where
			<string-lt>(<guardedCommand>b, <guardedCommand>a)
			
	simplify:
		Parallel(p, Guard(c, q))
			-> Guard(c, Parallel(p,q))
			
	simplify:
		Implies(a, b) -> Or(b, Not(a))
			
/*	simplify:
		BinRel(expr, Equal(), This())
			-> BinRel(This(), Equal(), expr)
		where
			<not(eq)>(This(), expr)

	simplify:
		BinRel(expr, NotEqual(), This())
			-> BinRel(This(), NotEqual(), expr)
		where
			<not(eq)>(This(), expr)
*/
	simplify:
		Not(True()) -> False()

	simplify:
		Not(False()) -> True()
		
	simplify:
		Choice(Guard(And(c1,c2),p1),
		       Guard(And(c1,c3),p2))
		->
			Guard(c1, Choice(Guard(c2,p1),
		       				 Guard(c3,p2)))

	simplify:
		Choice(Guard(c1,p1),
		       Guard(And(c1,c3),p2))
		->
			Guard(c1, Choice(Guard(True(),p1),
		       				 Guard(c3,p2)))

	simplify:
		Choice(Guard(c1,p1),
		       Guard(c1,p2))
		->
			Guard(c1, Choice(p1,p2))

	simplify:
		Choice(Parallel(a,b),
			   Parallel(a,c))
		->
			Parallel(a, Choice(b,c))

	simplify:
		Choice(Parallel(b,a),
			   Parallel(c,a))
		->
			Parallel(a, Choice(b,c))

	simplify:
		Choice(Parallel(a, b),
			   Parallel(c,a))
		->
			Parallel(a, Choice(b,c))

	simplify:
		Choice(Parallel(b,a),
			   Parallel(a, c))
		->
			Parallel(a, Choice(b,c))

	simplify:
		And(True(), constraint)
			-> constraint
			
	simplify:
		And(constraint, True())
			-> constraint

	simplify:
		And(False(), constraint)
			-> False()

	simplify:
		And(constraint, False())
			-> False()

	simplify:
		And(constraint, constraint)
			-> constraint
			
	simplify:
		Or(constraint, True())
			-> True()
	
	simplify:
		Or(True(), constraint)
			-> True()

	simplify:
		Or(constraint, constraint)
			-> constraint
	
	simplify:
		And(Implies(p,q),q)
			-> q
	
	simplify:
		And(And(r, Implies(p,q)),q)
			-> And(r,q)
	
		
	simplify:
		Implies(True(), constraint)
			-> constraint

	simplify:
		Implies(False(), constraint)
			-> True()

	simplify:
		Implies(constraint, True())
			-> True()
			
	simplify:
		Implies(constraint, False())
			-> Not(constraint)
			
	simplify:
		Implies(p, Implies(p, constraint))
			-> Implies(p, constraint)

	simplify:
		Implies(constraint, constraint)
			-> True()


	simplify:
		Implies(
			BinRel(a, Equal(), b),
			Implies(
				BinRel(a, NotEqual(), b),
				constraint
		)) -> Implies(False(), constraint)

	simplify:
		Implies(
			BinRel(a, NotEqual(), b),
			Implies(
				BinRel(a, Equal(), b),
				constraint
		)) -> Implies(False(), constraint)
	
	simplify:
		Or(p, And(Not(p), q))
			-> Or(p,q)
	
	simplify:
		Guard(True(), program)
			-> program
			
	simplify:
		And(constraint, constraint)
			-> constraint

	simplify:
		And(constraint, And(constraint1, constraint) )
			-> And(constraint1, constraint)
			
	simplify:
		And(constraint, And(constraint, constraint1) )
			-> And(constraint1, constraint)
			
	simplify:
		Or(constraint, False())
			-> constraint

	simplify:
		Or(False(), constraint)
			-> constraint
		

	simplify:
		And(And(constraint, constraint1), constraint  )
			-> And(constraint1, constraint)

	simplify:
		And(And(constraint1, constraint), constraint  )
			-> And(constraint1, constraint)
/*			
	simplify:
		And(BinRel(expression1, Equal(), expression2), BinRel(expression1, NotEqual(), expression2))
			-> False()

	simplify:
		And(BinRel(expression1, NotEqual(), expression2), BinRel(expression1, Equal(), expression2))
			-> False()
			
	simplify:
		Implies(And(BinRel(e1, Equal(), e2), BinRel(e3, Equal(), e4)), BinRel(e3, NotEqual(), e4))
			-> Or(BinRel(e1, NotEqual(), e2),BinRel(e3,NotEqual(), e4)) 

	simplify:
		Implies(And(BinRel(e1, Equal(), e2), BinRel(e3, NotEqual(), e4)), BinRel(e3, Equal(), e4))
			-> Or(BinRel(e1, NotEqual(), e2),BinRel(e3, Equal(), e4)) 
			
	simplify:
		Or(
			And(
				BinRel(expression1, NotEqual(), expression2),
				BinRel(expression1, NotEqual(), expression3)),
			Or(BinRel(expression1, Equal(), expression2),
			   BinRel(expression1, Equal(), expression3)))
		-> True()
			
	simplify:
		Or(
			And(
				BinRel(expression1, NotEqual(), expression2),
				BinRel(expression1, NotEqual(), expression3)),
			Or(
				BinRel(expression1, Equal(), expression3),
				BinRel(expression1, Equal(), expression2)))
		-> True()
*/		
	simplify:
		Forall(name, expr, True())
			-> True()
			
	/* here we should really do a literal substitute - name for expr2 */
	simplify:
		Forall(name, expr, Implies(BinRel(PathStart(name, None()), Equal(), expr2), constraint))
			-> constraint
					
			
/*	simplify:
		Not(And(a, b))
			-> Or(Not(a), Not(b))
*/
	simplify:
		Not(Or(a, b))
			-> And(Not(a), Not(b))
			
	
	simplify:
		Not(Implies(a,b))
			-> And(a, Not(b))		
			
			
/*	simplify:
		And(Implies(a,c),Implies(b,c))
			->
				Implies(Or(a,b),c) */
				
/*	simplify:
		Implies(p, q)
			-> Or(Not(p), q)
*/

	simplify:
		And(Or(a,b), c)
			-> Or(And(a,c), And(b,c))


	simplify:
		BinRel(expr, NotEqual(), expr)
			-> False()

	simplify:
		BinRel(expr, Equal(), expr)
			-> True()
	
	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), LessThanEquals(), BasicValue(Integer(j)))
			-> BinRel(a, LessThanEquals(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i)

	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), LessThan(), BasicValue(Integer(j)))
			-> BinRel(a, LessThan(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i) 


	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), GreaterThanEquals(), BasicValue(Integer(j)))
			-> BinRel(a, GreaterThanEquals(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i)

	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), GreaterThan(), BasicValue(Integer(j)))
			-> BinRel(a, GreaterThan(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i)


	simplify:
		BinRel(expression1, In(), BinOp(expression2, Union(), SetExtent([expression1])))
			-> True()
			

	simplify:
		BinRel(BinOp(expression1, Union(), expression2), SubsetEquals(), expression3)
			-> And(BinRel(expression1, SubsetEquals(), expression3), 
					BinRel(expression2, SubsetEquals(), expression3))

	

	simplify:
		BinRel(SetExtent([]), SubsetEquals(), expression2)
			-> True()		

	simplify:
		BinRel(SetExtent([exp, exps*]), SubsetEquals(), expression2)
			-> And(BinRel(exp, In(), expression2), BinRel(SetExtent([exps*]), SubsetEquals(), expression2))

			
	simplify:
		Not(BinRel(e1, Equal(), e2))
		 	-> BinRel(e1, NotEqual(), e2)		

	simplify:
		Not(BinRel(e1, NotEqual(), e2))
		 	-> BinRel(e1, Equal(), e2)		
		 	
	simplify:
		Not(BinRel(e1, In(), e2))
		 	-> BinRel(e1, NotIn(), e2)		

	simplify:
		Not(BinRel(e1, NotIn(), e2))
		 	-> BinRel(e1, In(), e2)	
		 	
	

	simplify:
		(BinOp(BasicValue(Integer(i)), Times(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <mulS>(<string-to-int>i, <string-to-int>j)

			
	simplify:
		(BinOp(BasicValue(Integer(i)), Plus(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <addS>(<string-to-int>i, <string-to-int>j)

	simplify:
		(BinOp(BasicValue(Integer(i)), Minus(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <subtS>(<string-to-int>i, <string-to-int>j)

	simplify:
		(BinOp(BasicValue(Integer(i)), Divide(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <divS>(<string-to-int>i,<string-to-int>j)

			
	simplify:
		UnOp(Cardinality(),BinOp(a,Union(), b))
			-> BinOp(UnOp(Cardinality(),a), Plus(), UnOp(Cardinality(),b))
	
	simplify:
		UnOp(Cardinality(),SetExtent([]))
			-> BasicValue(Integer(0))	

	// F - {this.f} <<: F
	
	simplify:
		BinRel(BinOp(exp1, Minus(), exp2), SubsetEquals(), exp1) -> True()

	simplify:
		BinRel(BinOp(exp1, Minus(), exp2), Subset(), exp1) -> True()
	
	simplify:
		BinRel(BinOp(exp1, Minus(), exp2), Subset(), exp3) -> BinRel(exp1, Subset(), exp3)
	
	
	simplify:
		BinRel(exp1, SubsetEquals(), exp1) -> True()

	simplify:
		BinRel(exp1, SupersetEquals(), exp1) -> True()
		
	
	

	// if n <= 0 and 
	//     card(something) >= n
	// then True
	//
	// The cardinality of anything is always greater than 0
	simplify:
		BinRel(UnOp(Cardinality(),something), GreaterThanEquals(), BasicValue(Integer(v)))
			-> True()
		where
			<leq>(v,0)	

/*	simplify:
		BinRel(UnOp(Cardinality(),something), GreaterThan(), BasicValue(Integer(v)))
			-> True()
		where
			<lt>(v,0) */	

	simplify:
		BinRel(UnOp(Cardinality(),something), LessThanEquals(), BasicValue(Integer(v)))
			-> False()
		where
			<leq>(v,0)	

	simplify:
		BinRel(UnOp(Cardinality(),something), LessThan(), BasicValue(Integer(v)))
			-> False()
		where
			<lt>(v,0)	


	simplify:
		BinRel(BinOp(expr, Plus(), expr'), Equal(), BinOp(expr, Plus(), expr''))
			-> BinRel(expr', Equal(), expr'')


/*	simplify:
		Cardinality(SetExtent([a]))
			-> BasicValue(Integer(1))
*/			
	simplify:
		UnOp(Cardinality(),SetExtent([a, as*]))
			-> BasicValue(Integer(k)){BasicType(Int())}
		where
			BasicValue(Integer(i)) := <simplify> UnOp(Cardinality(),SetExtent([as*]));
			k := <add>(i,1)
			

	simplify:
		BinRel(BasicValue(Integer(x)),Equal(), BasicValue(Integer(y)))
			-> False()
		where
			<not(equal)>(x,y)
			
	simplify:
		Implies(BinRel(a, Equal(), b), Implies(BinRel(b, Equal(), a), q))
			-> Implies(BinRel(a, Equal(), b), Implies(BinRel(a, Equal(), b), q))

	simplify:
		Implies(BinRel(a, NotEqual(), b), Implies(BinRel(b, NotEqual(), a), q))
			-> Implies(BinRel(a, NotEqual(), b), Implies(BinRel(a, NotEqual(), b), q))
	
/*	simplify:
		And(Implies(BinRel(a, Equal(), b), c), Implies(BinRel(b, Equal(), a), c))
			-> Implies(BinRel(a, Equal(), b), c)
*/				
	simplify:
		Guard(e1, Guard(e2, p))
			-> Guard(And(e1,e2),p)

	simplify:
		Guard(True(), p)
			-> p
			
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Reference(cname')},PathComponent(aname2, maybePrimed)){Reference(cname)}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Optional(Reference(cname'))},PathComponent(aname2, maybePrimed)){Optional(Reference(cname))}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Reference(cname')},PathComponent(aname2, maybePrimed)){Optional(Reference(cname))}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Optional(Reference(cname'))},PathComponent(aname2, maybePrimed)){Reference(cname)}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
	
	simplify:
		Parallel(Guard(c, g), g')
			-> Guard(c,Parallel(g,g'))
				
	simplify:
		Parallel(prog, Skip()) -> prog
		
		
	simplify:
		Parallel(Skip(), prog) -> prog
		
	simplify:
		UnOp(Cardinality(), SetExtent([_]))
			-> BasicValue(Integer(1)) {BasicType(Int())}	
	
	simplify:
		BinRel(BinOp(exp, Plus(), BasicValue(Integer(i))), GreaterThanEquals(), BasicValue(Integer(0)))
			-> True()
		where
			<gt>(i,0)
			
	simplify:
		BinRel(expr1, In(), SetExtent(exprs))
			-> True()
			where
				<elem>(expr1, exprs)

	simplify:
		BinRel(expr1, NotIn(), SetExtent(exprs))
			-> False()
			where
				<elem>(expr1, exprs)
	
	simplify:
		Or(BinRel(expr1, Equal(), expr2),BinRel(expr1, NotEqual(), expr2))
			-> True()

	simplify:
		Or(BinRel(expr1, NotEqual(), expr2),BinRel(expr1, Equal(), expr2))
			-> True()


	simplify:
		Or(BinRel(expr1, In(), expr2),BinRel(expr1, NotIn(), expr2))
			-> True()
			
	simplify:
		Or(BinRel(expr1, In(), expr2),And(BinRel(expr1, NotIn(), expr2), constraint))
			-> Or(BinRel(expr1, In(), expr2), constraint)
			
	simplify:
		Or(BinRel(expr1, In(), SetExtent(exprs)), BinRel(expr1, Equal(), expr2))
			-> BinRel(expr1, In(), SetExtent(exprs))
		where
			<elem>(expr2, exprs)
			
/*	simplify:
		Or(And(expr1, expr2), And(epx2, expr3))
			-> And(Or(expr1, expr3), expr2)
*/	
	simplify:
		(Then(True(), x)) -> x		

	simplify:
		(Then(x, True())) -> x		
				
						