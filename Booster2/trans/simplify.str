module simplify

imports
  include/Booster2

library/lookupTable
  
rules

	simplify-main:
		system -> system
		with
			simp-programs := <map(\((cname, mname), (constraint, gc, exts, done, ins, outs)) -> <simp> (cname, mname, gc)\)> <LookupTable> "Method"
			
	simp:
		(cname, mname, prog) 
			-> (cname, mname, prog) 
		where 
			prog' := <innermost(simplify)> prog;
			<updateMethodProgram>(cname, mname, prog')
			
			
			// Some normalisation rules?
/*	simplify:
		BinRel(expr, Equal(), This())
			-> BinRel(This(), Equal(), expr)
		where
			<not(eq)>(This(), expr)

	simplify:
		BinRel(expr, NotEqual(), This())
			-> BinRel(This(), NotEqual(), expr)
		where
			<not(eq)>(This(), expr)
*/


	simplify:
		And(True(), constraint)
			-> constraint
			
	simplify:
		And(constraint, True())
			-> constraint

	simplify:
		And(False(), constraint)
			-> False()

	simplify:
		And(constraint, False())
			-> False()

	simplify:
		And(constraint, constraint)
			-> constraint
			
	simplify:
		Or(constraint, True())
			-> True()
	
	simplify:
		Or(True(), constraint)
			-> True()

	simplify:
		Or(constraint, constraint)
			-> constraint
			
	simplify:
		Implies(True(), constraint)
			-> constraint

	simplify:
		Implies(False(), constraint)
			-> True()

	simplify:
		Implies(constraint, True())
			-> True()
			
	simplify:
		Implies(constraint, False())
			-> Not(constraint)
			
	simplify:
		Implies(p, Implies(p, constraint))
			-> Implies(p, constraint)

	simplify:
		Implies(constraint, constraint)
			-> True()


	simplify:
		Implies(
			BinRel(a, Equal(), b),
			Implies(
				BinRel(a, NotEqual(), b),
				constraint
		)) -> Implies(False(), constraint)

	simplify:
		Implies(
			BinRel(a, NotEqual(), b),
			Implies(
				BinRel(a, Equal(), b),
				constraint
		)) -> Implies(False(), constraint)
	
	simplify:
		Or(p, And(Not(p), q))
			-> Or(p,q)
	
	simplify:
		Guard(True(), program)
			-> program
			
	simplify:
		And(constraint, constraint)
			-> constraint

	simplify:
		And(constraint, And(constraint1, constraint) )
			-> And(constraint1, constraint)
			
	simplify:
		And(constraint, And(constraint, constraint1) )
			-> And(constraint1, constraint)
			
	simplify:
		Or(constraint, False())
			-> constraint

	simplify:
		Or(False(), constraint)
			-> constraint
		

	simplify:
		And(And(constraint, constraint1), constraint  )
			-> And(constraint1, constraint)

	simplify:
		And(And(constraint1, constraint), constraint  )
			-> And(constraint1, constraint)
			
	simplify:
		And(BinRel(expression1, Equal(), expression2), BinRel(expression1, NotEqual(), expression2))
			-> False()

	simplify:
		And(BinRel(expression1, NotEqual(), expression2), BinRel(expression1, Equal(), expression2))
			-> False()
			
	simplify:
		Implies(And(BinRel(e1, Equal(), e2), BinRel(e3, Equal(), e4)), BinRel(e3, NotEqual(), e4))
			-> Or(BinRel(e1, NotEqual(), e2),BinRel(e3,NotEqual(), e4)) 

	simplify:
		Implies(And(BinRel(e1, Equal(), e2), BinRel(e3, NotEqual(), e4)), BinRel(e3, Equal(), e4))
			-> Or(BinRel(e1, NotEqual(), e2),BinRel(e3, Equal(), e4)) 
			
	simplify:
		Or(
			And(
				BinRel(expression1, NotEqual(), expression2),
				BinRel(expression1, NotEqual(), expression3)),
			Or(BinRel(expression1, Equal(), expression2),
			   BinRel(expression1, Equal(), expression3)))
		-> True()
			
	simplify:
		Or(
			And(
				BinRel(expression1, NotEqual(), expression2),
				BinRel(expression1, NotEqual(), expression3)),
			Or(
				BinRel(expression1, Equal(), expression3),
				BinRel(expression1, Equal(), expression2)))
		-> True()
		
	simplify:
		Forall(name, expr, True())
			-> True()
			
	/* here we should really do a literal substitute - name for expr2 */
	simplify:
		Forall(name, expr, Implies(BinRel(PathStart(name, None()), Equal(), expr2), constraint))
			-> constraint
					
			
	simplify:
		Not(And(a, b))
			-> Or(Not(a), Not(b))

	simplify:
		Not(Or(a, b))
			-> And(Not(a), Not(b))
			
	simplify:
		Not(Implies(a,b))
			-> And(a, Not(b))		
			
			
/*	simplify:
		And(Implies(a,c),Implies(b,c))
			->
				Implies(Or(a,b),c) */
				
/*	simplify:
		Implies(p, q)
			-> Or(Not(p), q)
*/



	simplify:
		BinRel(expr, NotEqual(), expr)
			-> False()

	simplify:
		BinRel(expr, Equal(), expr)
			-> True()
	
	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), LessThanEquals(), BasicValue(Integer(j)))
			-> BinRel(a, LessThanEquals(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i)

	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), LessThan(), BasicValue(Integer(j)))
			-> BinRel(a, LessThan(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i) 


	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), GreaterThanEquals(), BasicValue(Integer(j)))
			-> BinRel(a, GreaterThanEquals(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i)

	simplify:
		BinRel(BinOp(a, Plus(), BasicValue(Integer(i))), GreaterThan(), BasicValue(Integer(j)))
			-> BinRel(a, GreaterThan(), BasicValue(Integer(k)))
		where
			k := <subt>(<string-to-int>j,<string-to-int>i)


	simplify:
		BinRel(expression1, In(), BinOp(expression2, Union(), SetExtent([expression1])))
			-> True()
			

	simplify:
		BinRel(BinOp(expression1, Union(), expression2), SubsetEquals(), expression3)
			-> And(BinRel(expression1, SubsetEquals(), expression3), 
					BinRel(expression2, SubsetEquals(), expression3))

	

	simplify:
		BinRel(SetExtent([]), SubsetEquals(), expression2)
			-> True()		

	simplify:
		BinRel(SetExtent([exp, exps*]), SubsetEquals(), expression2)
			-> And(BinRel(exp, In(), expression2), BinRel(SetExtent([exps*]), SubsetEquals(), expression2))

			
	simplify:
		Not(BinRel(e1, Equal(), e2))
		 	-> BinRel(e1, NotEqual(), e2)		

	simplify:
		Not(BinRel(e1, NotEqual(), e2))
		 	-> BinRel(e1, Equal(), e2)		
		 	
	simplify:
		Not(BinRel(e1, In(), e2))
		 	-> BinRel(e1, NotIn(), e2)		

	simplify:
		Not(BinRel(e1, NotIn(), e2))
		 	-> BinRel(e1, In(), e2)	
		 	
	

	simplify:
		(BinOp(BasicValue(Integer(i)), Times(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <mulS>(<string-to-int>i, <string-to-int>j)

			
	simplify:
		(BinOp(BasicValue(Integer(i)), Plus(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <addS>(<string-to-int>i, <string-to-int>j)

	simplify:
		(BinOp(BasicValue(Integer(i)), Minus(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <subtS>(<string-to-int>i, <string-to-int>j)

	simplify:
		(BinOp(BasicValue(Integer(i)), Divide(), BasicValue(Integer(j))))
			-> BasicValue(Integer( k ))
		where
			k := <divS>(<string-to-int>i,<string-to-int>j)

			
	simplify:
		UnOp(Cardinality(),BinOp(a,Union(), b))
			-> BinOp(UnOp(Cardinality(),a), Plus(), UnOp(Cardinality(),b))
	
	simplify:
		UnOp(Cardinality(),SetExtent([]))
			-> BasicValue(Integer(0))	

	// F - {this.f} <<: F
	
	simplify:
		BinRel(BinOp(exp1, Minus(), exp2), SubsetEquals(), exp1) -> True()

	simplify:
		BinRel(BinOp(exp1, Minus(), exp2), Subset(), exp1) -> True()
	
	
	
	simplify:
		BinRel(exp1, SubsetEquals(), exp1) -> True()

	simplify:
		BinRel(exp1, SupersetEquals(), exp1) -> True()
		
	
	

	// if n < 0 and 
	//     card(something) >= n
	// then True
	//
	// The cardinality of anything is always greater than 0
	simplify:
		BinRel(UnOp(Cardinality(),something), GreaterThanEquals(), BasicValue(Integer(v)))
			-> True()
		where
			<lt>(<string-to-int>v,0)	

	simplify:
		BinRel(UnOp(Cardinality(),something), GreaterThan(), BasicValue(Integer(v)))
			-> True()
		where
			<lt>(<string-to-int>v,0)	

	simplify:
		BinRel(UnOp(Cardinality(),something), LessThanEquals(), BasicValue(Integer(v)))
			-> False()
		where
			<lt>(<string-to-int>v,0)	

	simplify:
		BinRel(UnOp(Cardinality(),something), LessThan(), BasicValue(Integer(v)))
			-> False()
		where
			<lt>(<string-to-int>v,0)	


	simplify:
		BinRel(BinOp(expr, Plus(), expr'), Equal(), BinOp(expr, Plus(), expr''))
			-> BinRel(expr', Equal(), expr'')


/*	simplify:
		Cardinality(SetExtent([a]))
			-> BasicValue(Integer(1))
*/			
	simplify:
		UnOp(Cardinality(),SetExtent([a, as*]))
			-> BasicValue(Integer(k)){BasicType(Int())}
		where
			BasicValue(Integer(i)) := <simplify> UnOp(Cardinality(),SetExtent([as*]));
			k := <add>(<string-to-int>i,1)
			

			
	simplify:
		Guard(e1, Guard(e2, p))
			-> Guard(And(e1,e2),p)

	simplify:
		Guard(True(), p)
			-> p
			
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Reference(cname')},PathComponent(aname2, maybePrimed)){Reference(cname)}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Optional(Reference(cname'))},PathComponent(aname2, maybePrimed)){Optional(Reference(cname))}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Reference(cname')},PathComponent(aname2, maybePrimed)){Optional(Reference(cname))}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Path(Path(ps {Reference(cname)}, PathComponent(aname1, maybePrimed)){Optional(Reference(cname'))},PathComponent(aname2, maybePrimed)){Reference(cname)}
			-> ps {Reference(cname)}
			where
				(cname', aname2) := <lookup-opposite>(cname, aname1)
				
	simplify:
		Parallel(prog, Skip()) -> prog
		
		
	simplify:
		Parallel(Skip(), prog) -> prog
		
	simplify:
		UnOp(Cardinality(), SetExtent([_]))
			-> BasicValue(Integer(1)) {BasicType(Int())}	
	
	simplify:
		BinRel(BinOp(exp, Plus(), BasicValue(Integer(i))), GreaterThanEquals(), BasicValue(Integer(0)))
			-> True()
		where
			<gt>(i,0)
			
	simplify:
		BinRel(expr1, In(), SetExtent(exprs))
			-> True()
			where
				<elem>(expr1, exprs)

	simplify:
		BinRel(expr1, NotIn(), SetExtent(exprs))
			-> False()
			where
				<elem>(expr1, exprs)
	
	simplify:
		Or(BinRel(expr1, In(), expr2),BinRel(expr1, NotIn(), expr2))
			-> True()
			
	simplify:
		Or(BinRel(expr1, In(), expr2),And(BinRel(expr1, NotIn(), expr2), constraint))
			-> Or(BinRel(expr1, In(), expr2), constraint)
			
	simplify:
		Or(BinRel(expr1, In(), SetExtent(exprs)), BinRel(expr1, Equal(), expr2))
			-> BinRel(expr1, In(), SetExtent(exprs))
		where
			<elem>(expr2, exprs)
			
	simplify:
		Or(And(expr1, expr2), And(epx2, expr3))
			-> And(Or(expr1, expr3), expr2)
	
	simplify:
		(Then(True(), x)) -> x		

	simplify:
		(Then(x, True())) -> x		
				
						