 module elaborate/expression

imports
  include/Booster2

  elaborate/valueExpression

 
 rules
 	
/* 	infer-type:
		Description goes here	
*/




 	infer-type:
 		(classname, methodname, BinOp(expr1, op, expr2), type, alreadyknown)
 			-> <union>(vars1, vars2)
 		with
 			vars1 := <infer-type> (classname, methodname, expr1, type, alreadyknown);
 			vars2 := <infer-type> (classname, methodname, expr2, type, alreadyknown)



  					
 	infer-type:
 		(classname, methodname, Head(expr1), type, inorout)
 			-> vars1
 		with
 			vars1 := <infer-type> (classname, methodname, expr1, type, inorout)

 	infer-type:
 		(classname, methodname, Tail(expr1), type, inorout)
 			-> vars1
 		with
 			vars1 := <infer-type> (classname, methodname, expr1, type, inorout)

 	infer-type:
 		(classname, methodname, Cardinality(expr1), type, inorout)
 			-> vars1
 		with
 			vars1 := <infer-type> (classname, methodname, expr1, type, inorout)

 	infer-type:
 		(classname, methodname, Negative(expr1), type, inorout)
 			-> vars1
 		with
 			vars1 := <infer-type> (classname, methodname, expr1, type, inorout)


 	
/*	deduce-types:
		Description goes here
*/ 	

			

/* 	insert-this:
		Takes an expression, and returns it with any paths transformed so that
		they have 'this' at the front, if applicable 
*/
			
	insert-this:
		(Head(expr1), classname)
			-> Head(expr2)
		where
			expr2 := <insert-this> (expr1, classname)

	insert-this:
		(Tail(expr1), classname)
			-> Tail(expr2)
		where
			expr2 := <insert-this> (expr1, classname)

	insert-this:
		(Negative(expr1), classname)
			-> Negative(expr2)
		where
			expr2 := <insert-this> (expr1, classname)

	insert-this:
		(Cardinality(expr1), classname)
			-> Cardinality(expr2)
		where
			expr2 := <insert-this> (expr1, classname)


	insert-this:
		(BinOp(expr1, op, expr2), classname)
			-> BinOp(expr3, op, expr4)
		where
			expr3 := <insert-this> (expr1, classname);
			expr4 := <insert-this> (expr2, classname)

			

	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, BinOp(expr1, op, expr2))
			-> (And(constraint1, constraint2), BinOp(expr3, op, expr4))
		where
			(constraint1, expr3) := <replace-this-for-attribute> (thisclassname, otherclassname, attname, expr1);
			(constraint2, expr4) := <replace-this-for-attribute> (thisclassname, otherclassname, attname, expr2)


	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Head(expr1))
			-> (constraint1, Head(expr2))
		where
			(constraint1, expr2) := <replace-this-for-attribute> (thisclassname, otherclassname, attname, expr1)

	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Tail(expr1))
			-> (constraint1, Tail(expr2))
		where
			(constraint1, expr2) := <replace-this-for-attribute> (thisclassname, otherclassname, attname, expr1)

	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Cardinality(expr1))
			-> (constraint1, Cardinality(expr2))
		where
			(constraint1, expr2) := <replace-this-for-attribute> (thisclassname, otherclassname, attname, expr1)

	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Negative(expr1))
			-> (constraint1, Negative(expr2))
		where
			(constraint1, expr2) := <replace-this-for-attribute> (thisclassname, otherclassname, attname, expr1)
			