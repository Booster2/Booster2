module elaborate/constraint

imports
  include/Booster2
  elaborate/relation
  elaborate/expression
  elaborate/valueExpression
 
  library/abstractBoosterModel
  library/valueExpression
 
 rules
 	
 	

/*	insert-this:
		Takes a constraint, and returns it with any paths transformed so that
		they have 'this' at the front, if applicable 
*/ 	

	insert-this: 
		(True(), classname)
			-> True()
			
	insert-this: 
		(False(), classname)
			-> False()
			
	insert-this:
			(Not(constraint), classname)
				-> Not(constraint2)
			where
				constraint2 := <insert-this> (constraint, classname)			
			
	insert-this: 
		(And(constraint1, constraint2), classname)
			-> And(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

	insert-this: 
		(Or(constraint1, constraint2), classname)
			-> Or(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

	insert-this: 
		(Then(constraint1, constraint2), classname)
			-> Then(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

	insert-this: 
		(Implies(constraint1, constraint2), classname)
			-> Implies(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

/*	deduce-types:
		Description goes here
*/ 	

	deduce-types:
		(classname, methodname, Then(expr1, expr2), alreadyknown)
		 	-> types2
		where
			types1 := <deduce-types> (classname, methodname, expr1, alreadyknown );
			types2 := <deduce-types> (classname, methodname, expr2, types1)

	deduce-types:
		(classname, methodname, And(expr1, expr2), alreadyknown)
		 	-> types2
		where
			types1 := <deduce-types> (classname, methodname, expr1, alreadyknown );
			types2 := <deduce-types> (classname, methodname, expr2, types1)


	deduce-types:
		(classname, methodname, Equal(expr1, expr2), alreadyknown)
		 	-> types2
		where
			(Int(), types1) := <deduce-types> (classname, methodname, expr1, alreadyknown );
			(Int(), types2) := <deduce-types> (classname, methodname, expr2, types1)

	deduce-types:
		(classname, methodname, Equal(expr1, expr2), alreadyknown)
		 	-> types2
		where
			(String(), types1) := <deduce-types> (classname, methodname, expr1, alreadyknown );
			types2 := <infer-type> (classname, methodname, expr2, String(), types1)

	
	deduce-types:
		(classname, methodname, In(expr1, expr2), alreadyknown)
		 	-> types2
		where
			(Set(type1), types1) := <deduce-types> (classname, methodname, expr2, alreadyknown);
			types2 := <infer-type> (classname, methodname, expr1, type1, types1)

	deduce-types:
		(classname, methodname, PathStart(a,maybeprimed), alreadyknown)
			-> (Set(Class(a)), alreadyknown)
		where
			<equal>(a, <lookup-class-name>(a))

	deduce-types:
		(classname, methodname, Output(name), alreadyknown)
			-> (type, alreadyknown)
		where
			type := <lookup>(Output(name), alreadyknown)

	deduce-types:
		(classname, methodname, Integer(i), alreadyknown)
			-> (Int(), alreadyknown)


	deduce-types:
		(classname, methodname, Path(path, component), alreadyknown)
			-> (type, newlyknown)
		where
			(type2, newlyknown) := <deduce-types> (classname, methodname, path, alreadyknown);		
			type := <resolve-path-type>
					(classname, Path(path,component), (classname, methodname), newlyknown)

	deduce-types:
		(classname, methodname, Path(path, component), alreadyknown)
			-> (type2, newlyknown)
		where
			(type, newlyknown) := <deduce-types> (classname, methodname, path, alreadyknown);		
			/*log(|Error(), "deduce-types-path", ((classname, Path(path,component), (classname, methodname), newlyknown)))
			*/
			type2 := <resolve-path-type>
					(classname, Path(path,component), (classname, methodname), newlyknown)
					

	infer-type:
		(classname, methodname, Output(name), type1, [alreadyknown*])
			->[(Output(name), type1), alreadyknown*]

	infer-type:
		(classname, methodname, Input(name), type1, [alreadyknown*])
			->[(Input(name), type1), alreadyknown*]
			

	deduce-types:
		something
			-> []
		where
			log(|Error(), "Error in deduce-types", something)				

	infer-type:
		something
			-> []
		where
			log(|Error(), "Error in infer-type", something)				
			
		
		 	
		 	





	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, And(constraint1, constraint2))
			-> (And(constraint3, constraint4), 
				And(constraint5, constraint6))
			where
				(constraint3, constraint5) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint1);
				(constraint4, constraint6) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint2)
			
			
	replace-this-for-attribute:
		(classname, attname, Or(constraint1, constraint2))
			-> (And(constraint3, constraint4), 
				Or(constraint5, constraint6))
			where
				(constraint3, constraint5) := <replace-this-for-attribute>(classname, attname, constraint1);
				(constraint4, constraint6) := <replace-this-for-attribute>(classname, attname, constraint2)
	
	
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Implies(constraint1, constraint2))
			-> (And(constraint3, constraint4), 
				Implies(constraint5, constraint6))
			where
				(constraint3, constraint5) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint1);
				(constraint4, constraint6) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint2)
				
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, True())
			-> (True(), 
				True())

	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, False())
			-> (True(), 
				False())
	
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Not(constraint1))
			-> (constraint2, Not(constraint3))
		where
			(constraint2, constraint3) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint1)


