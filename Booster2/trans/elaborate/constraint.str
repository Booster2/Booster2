module elaborate/constraint

imports
  include/Booster2
  
  elaborate/relation
  elaborate/expression
  elaborate/valueExpression
 
  library/abstractBoosterModel
  library/valueExpression
  library/basicTypes
 
 rules
 	
 	

/*	insert-this:
		Takes a constraint, and returns it with any paths transformed so that
		they have 'this' at the front, if applicable 
*/ 	

	insert-this: 
		(True(), classname)
			-> True()
			
	insert-this: 
		(False(), classname)
			-> False()
			
	insert-this:
			(Not(constraint), classname)
				-> Not(constraint2)
			where
				constraint2 := <insert-this> (constraint, classname)			
			
	insert-this: 
		(And(constraint1, constraint2), classname)
			-> And(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

	insert-this: 
		(Or(constraint1, constraint2), classname)
			-> Or(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

	insert-this: 
		(Then(constraint1, constraint2), classname)
			-> Then(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

	insert-this: 
		(Implies(constraint1, constraint2), classname)
			-> Implies(constraint3, constraint4)
		with 
			constraint3 := <insert-this>(constraint1, classname);
			constraint4 := <insert-this>(constraint2, classname)

/*	deduce-types:
		Description goes here
*/ 	

	deduce-types:
		(classname, methodname, Then(expr1, expr2), alreadyknown)
		 	-> types2
		where
			types1 := <deduce-types> (classname, methodname, expr1, alreadyknown );
			types2 := <deduce-types> (classname, methodname, expr2, types1)

	deduce-types:
		(classname, methodname, And(expr1, expr2), alreadyknown)
		 	-> types2
		where
			types1 := <deduce-types> (classname, methodname, expr1, alreadyknown );
			types2 := <deduce-types> (classname, methodname, expr2, types1)





	




 	deduce-types:
		(classname, methodname, BinOp(expr1, op, expr2), alreadyknown)
		 	-> (BasicType(t), types2)
		where
			(BasicType(t), types1) := <deduce-types> (classname, methodname, expr1, alreadyknown );
			(BasicType(t), types2) := <deduce-types> (classname, methodname, expr2, types1)

 	deduce-types:
		(classname, methodname, BinOp(expr1, op, expr2), alreadyknown)
		 	-> (BasicType(t), types2)
		where
			(BasicType(t), types1) := <deduce-types> (classname, methodname, expr2, alreadyknown );
			(BasicType(t), types2) := <deduce-types> (classname, methodname, expr1, types1)


    deduce-types:
		(classname, methodname, BinOp(expr1, op, expr2), alreadyknown)
		 	-> (BasicType(t), types2)
		where
			(BasicType(t), types1) := <deduce-types> (classname, methodname, expr1, alreadyknown );
			types2 := <infer-type> (classname, methodname, expr2, BasicType(t), types1)

    deduce-types:
		(classname, methodname, BinOp(expr1, op, expr2), alreadyknown)
		 	-> (BasicType(t), types2)
		where
			(BasicType(t), types1) := <deduce-types> (classname, methodname, expr2, alreadyknown );
			types2 := <infer-type> (classname, methodname, expr1, BasicType(t), types1)
			
			

	deduce-types:
		(classname, methodname, PathStart(a,maybeprimed), alreadyknown)
			-> (Set(Class(a)), alreadyknown)
		where
			<equal>(a, <lookup-class-name>(a))

	
	deduce-types:
		(classname, methodname, Output(name), alreadyknown)
			-> (type, alreadyknown)
		where
			type := <lookup>(Output(name), alreadyknown)

	deduce-types:
		(classname, methodname, BasicValue(t), alreadyknown)
			-> (BasicType(t'), alreadyknown)
			where
				t' := <get-corresponding-booster-type> t

	deduce-types:
		(classname, methodname, This(), alreadyknown)
			->(Class(classname), <union>([(Input("this"), Class(classname))], alreadyknown))


	deduce-types:
		(classname, methodname, Path(path, PathComponent(att, maybeprimed)), alreadyknown)
			-> (type, alreadyknown)
		where
			(Class(c), newlyknown) := <deduce-types> (classname, methodname, path, alreadyknown);		
			type := <lookup-attribute-type> (c, att)
			/* type := <resolve-path-type>
					(classname, Path(path,component), (classname, methodname), newlyknown) */
			


				

			

			
		
		 	
		 	




/*
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, And(constraint1, constraint2))
			-> (And(constraint3, constraint4), 
				And(constraint5, constraint6))
			where
				(constraint3, constraint5) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint1);
				(constraint4, constraint6) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint2)
			
			
	replace-this-for-attribute:
		(classname, attname, Or(constraint1, constraint2))
			-> (And(constraint3, constraint4), 
				Or(constraint5, constraint6))
			where
				(constraint3, constraint5) := <replace-this-for-attribute>(classname, attname, constraint1);
				(constraint4, constraint6) := <replace-this-for-attribute>(classname, attname, constraint2)
	
	
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Implies(constraint1, constraint2))
			-> (And(constraint3, constraint4), 
				Implies(constraint5, constraint6))
			where
				(constraint3, constraint5) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint1);
				(constraint4, constraint6) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint2)
				
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, True())
			-> (True(), 
				True())

	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, False())
			-> (True(), 
				False())
	
	replace-this-for-attribute:
		(thisclassname, otherclassname, attname, Not(constraint1))
			-> (constraint2, Not(constraint3))
		where
			(constraint2, constraint3) := <replace-this-for-attribute>(thisclassname, otherclassname, attname, constraint1)

*/
