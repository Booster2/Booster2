definition
module Common
exports
  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]* -> ID            
    'this'                  -> ID            {reject}
    'null'                  -> ID            {reject}
    'false'                 -> ID            {reject}
    'true'                  -> ID            {reject}
    'string'                -> ID            {reject}
    'int'                   -> ID            {reject}
    'decimal'               -> ID            {reject}
    'date'                  -> ID            {reject}
    'time'                  -> ID            {reject}
    'datetime'              -> ID            {reject}
    'boolean'               -> ID            {reject}
    'password'              -> ID            {reject}
    'attributes'            -> ID            {reject}
    'extends'               -> ID            {reject}
    'system'                -> ID            {reject}
    'invariant'             -> ID            {reject}
    'methods'               -> ID            {reject}
    'skip'                  -> ID            {reject}
    'currentdatetime'       -> ID            {reject}
    'currentdate'           -> ID            {reject}
    'currenttime'           -> ID            {reject}
    'currentuser'           -> ID            {reject}
    [0-9]+                  -> INT           
    [0-9]+ '.' [0-9]+       -> DECIMAL       
    "\"" StringChar* "\""   -> STRING        
    ~[\"\n]                 -> StringChar    
    "\\\""                  -> StringChar    
    BackSlashChar           -> StringChar    
    "\\"                    -> BackSlashChar 
    "'" SQLStringChar* "'"  -> SQLSTRING     
    ~[\'\n]                 -> SQLStringChar 
    "\\'"                   -> SQLStringChar 
    BackSlashChar           -> SQLStringChar 
    [\ \t\n\r]              -> LAYOUT        
    [\*]                    -> CommentChar   
    "/*" Alt1* "*/"         -> LAYOUT        
    ~[\*]                   -> Alt1          
    CommentChar             -> Alt1          
    "//" ~[\n\r]* Alt2      -> LAYOUT        
    [\n\r]                  -> Alt2          
    EOF                     -> Alt2          
                            -> EOF           

  lexical restrictions
    CommentChar -/- [\/]
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_]
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]

module AbstractBoosterModel
imports Common Booster2

exports
  context-free start-symbols
    MaxMult Ordering Type GuardedCommand

  context-free syntax
    INT                                        -> MaxMult        {cons("MaxMult")}
    "*"                                        -> MaxMult        {cons("MaxMult")}
    MaxMult                                    -> BoosterTerm    
    "SET"                                      -> Ordering       {cons("SetOrdering")}
    "OSET"                                     -> Ordering       {cons("OSetOrdering")}
    "SEQ"                                      -> Ordering       {cons("SeqOrdering")}
    Ordering                                   -> BoosterTerm    
    "null"                                     -> Type           {cons("Null")}
    "INT"                                      -> Type           {cons("Int")}
    "STRING"                                   -> Type           {cons("String")}
    ID                                         -> Type           {cons("Reference")}
    "[" Type "]"                               -> Type           {cons("Optional")}
    "set" "(" Type ")"                         -> Type           {cons("Set")}
    "skip"                                     -> GuardedCommand {cons("Skip"), prefer}
    Path ":=" Expression                       -> GuardedCommand {cons("Assign"), left}
    "new" ID "!" ":" ID                        -> GuardedCommand {cons("New")}
    Constraint "-->" GuardedCommand            -> GuardedCommand {cons("Guard"), right}
    GuardedCommand "||" GuardedCommand         -> GuardedCommand {cons("Parallel"), left}
    GuardedCommand ";" GuardedCommand          -> GuardedCommand {cons("Sequence"), left}
    GuardedCommand "[" "]" GuardedCommand      -> GuardedCommand {cons("Choice"), left}
    "ALL" ID ":" Expression "." GuardedCommand -> GuardedCommand {cons("Any"), prefer}
    "ANY" ID ":" Expression "." GuardedCommand -> GuardedCommand {cons("All"), prefer}
    "(" GuardedCommand ")"                     -> GuardedCommand {bracket}
    "parallels" {GuardedCommand "||"}*         -> GuardedCommand {cons("Parallels")}
    GuardedCommand                             -> BoosterTerm    

  context-free syntax
    "[[INT]]"            -> INT            {cons("INT-Plhdr"), placeholder}
    "[[MaxMult]]"        -> MaxMult        {cons("MaxMult-Plhdr"), placeholder}
    "[[Ordering]]"       -> Ordering       {cons("Ordering-Plhdr"), placeholder}
    "[[Type]]"           -> Type           {cons("Type-Plhdr"), placeholder}
    "[[Path]]"           -> Path           {cons("Path-Plhdr"), placeholder}
    "[[Constraint]]"     -> Constraint     {cons("Constraint-Plhdr"), placeholder}
    "[[ID]]"             -> ID             {cons("ID-Plhdr"), placeholder}
    "[[Expression]]"     -> Expression     {cons("Expression-Plhdr"), placeholder}
    "[[BoosterTerm]]"    -> BoosterTerm    {cons("BoosterTerm-Plhdr"), placeholder}
    "[[GuardedCommand]]" -> GuardedCommand {cons("GuardedCommand-Plhdr"), placeholder}

  context-free priorities
    Path ":=" Expression -> GuardedCommand >
    Constraint "-->" GuardedCommand -> GuardedCommand >
    GuardedCommand "||" GuardedCommand -> GuardedCommand >
    GuardedCommand "[" "]" GuardedCommand -> GuardedCommand >
    GuardedCommand ";" GuardedCommand -> GuardedCommand

module Triple
imports Common

exports
  context-free start-symbols
    Statement

  context-free syntax
    "@prefix" "rr:" "<http://www.w3.org/ns/r2rml#>." "@prefix" "rdf:" "<http://www.w3.org/1999/02/22-rdf-syntax-ns#>." "@prefix" "rdfs:" "<http://www.w3.org/2000/01/rdf-schema#>." "@prefix" "xsd:" "<http://www.w3.org/2001/XMLSchema#>." -> Statement          {cons("Prefixes")}
    "@prefix" ID ":" "<http://example.com/ns#" ID ">."                                                                                                                                                                                      -> Statement          {cons("Prefix")}
    Statement*                                                                                                                                                                                                                              -> Statement          {cons("StatementList")}
    "<#" ID ">" "a" "rr:TriplesMap;" "rr:logicalTable" "[" "rr:tableName" "\"" DBTableName "\";" "];" "."                                                                                                                                   -> Statement          {cons("CreateMapping")}
    "`" ID "`" "." "`" ID "`"                                                                                                                                                                                                               -> DBTableName        {cons("DBTableName")}
    "rr:subjectMap" "[" "rr:class" "`" DBName "`;" "rr:template" "\"http://example.com/{" ColumnName "}\";" "];"                                                                                                                            -> SubjectMap         {cons("SubjectMap")}
    "rr:predicateObjectMap" "[" "rr:predicate" "`" DBName "`:`" ColumnName "`;" "rr:objectMap" "[" "rr:column" "\"`" ColumnName "`\";" "];" "];"                                                                                            -> PredicateObjectMap {cons("PredicateObjectMap")}
    "`" ID "`"                                                                                                                                                                                                                              -> TableName          {cons("TableName")}
    "`" ID "`"                                                                                                                                                                                                                              -> DBName             {cons("DBName")}
    "`" ID "`"                                                                                                                                                                                                                              -> ColumnName         {cons("ColumnName")}
    "`" ID "`" "." "`" ID "`"                                                                                                                                                                                                               -> TableColumnName    {cons("TableColumnName")}

  context-free syntax
    "[[Statement]]"          -> Statement          {cons("Statement-Plhdr"), placeholder}
    "[[DBTableName]]"        -> DBTableName        {cons("DBTableName-Plhdr"), placeholder}
    "[[SubjectMap]]"         -> SubjectMap         {cons("SubjectMap-Plhdr"), placeholder}
    "[[PredicateObjectMap]]" -> PredicateObjectMap {cons("PredicateObjectMap-Plhdr"), placeholder}
    "[[TableName]]"          -> TableName          {cons("TableName-Plhdr"), placeholder}
    "[[DBName]]"             -> DBName             {cons("DBName-Plhdr"), placeholder}
    "[[ColumnName]]"         -> ColumnName         {cons("ColumnName-Plhdr"), placeholder}
    "[[TableColumnName]]"    -> TableColumnName    {cons("TableColumnName-Plhdr"), placeholder}
    "[[ID]]"                 -> ID                 {cons("ID-Plhdr"), placeholder}

  context-free syntax
    

module Relational
imports Common

exports
  context-free start-symbols
    Statement

  context-free syntax
    "drop" "database" "if" "exists" "`" ID "`;"                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> Statement          {cons("DropDatabase")}
    "create" "database" "`" ID "`" "default" "charset=utf8;"                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Statement          {cons("CreateDatabase")}
    "use" "`" ID "`;" "SET" "autocommit=1;"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> Statement          {cons("UseDatabase")}
    "drop" "table" "if" "exists" "`" ID "`;"                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Statement          {cons("DropTable")}
    "create" "table" "`" ID "`" "(" PrimaryKeyColumn ")" ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Statement          {cons("CreateTable")}
    "`" ID "`" SQLType ColumnNullable? ColumnDefault? Extra? "primary" "key" Reference?                                                                                                                                                                                                                                                                                                                                                                                                                                    -> PrimaryKeyColumn   {cons("PrimaryKeyColumn")}
    "alter" "table" "`" ID "`" "add" "column" "`" ID "`" SQLType ColumnNullable? ColumnDefault? Extra? Key? Reference? ";"                                                                                                                                                                                                                                                                                                                                                                                                 -> Statement          {cons("CreateColumn")}
    "default" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> ColumnDefault      {cons("ColumnDefault")}
    "null"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> ColumnNullable     {cons("ColumnNullable")}
    "not" "null"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> ColumnNullable     {cons("ColumnNotNullable")}
    "varchar" "(" INT ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SQLType            {cons("Varchar")}
    "int"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SQLType            {cons("Int")}
    "bit"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SQLType            {cons("Bit")}
    "datetime"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> SQLType            {cons("DateTime")}
    "timestamp"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> SQLType            {cons("TimeStamp")}
    "date"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> SQLType            {cons("Date")}
    "time"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> SQLType            {cons("Time")}
    "text"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> SQLType            {cons("Text")}
    "decimal"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> SQLType            {cons("Decimal")}
    "true"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> BOOL               {cons("True")}
    "false"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> BOOL               {cons("False")}
    "auto_increment"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> Extra              {cons("AutoIncrement")}
    "/\"/\""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Extra              {cons("NoExtra")}
    "primary" "key"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> Key                {cons("Primary")}
    "Unique"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Key                {cons("Unique")}
    "Multiple"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Key                {cons("Multiple")}
    "None"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Key                {cons("NoKey")}
    "," "add" "foreign" "key" "(" "`" ID "`" ")" "references" "`" ID "`" "(" {ColumnName ","}* ")"                                                                                                                                                                                                                                                                                                                                                                                                                         -> Reference          {cons("Reference")}
    Statement*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Statement          {cons("StatementList")}
    "drop" "procedure" "if" "exists" "`" ID "`;"                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> Statement          {cons("DropProcedure")}
    "delimiter" "//" "create" "procedure" "`" ID "`" "(" {Parameter ","}* ")" "begin" "declare" "_errcode" "CHAR" "(" "5" ")" "DEFAULT" "'00000';" "declare" "_msg" "TEXT;" "declare" "exit" "handler" "for" "sqlwarning," "sqlexception," "not" "found" "begin" "get" "diagnostics" "condition" "1" "_errcode" "=" "RETURNED_SQLSTATE," "_msg" "=" "MESSAGE_TEXT;" "rollback;" "call" "log_debug" "(" "'" ID "'," "_errcode," "_msg" ")" ";" "end;" "start" "transaction;" Statement "commit;" "end" "//" "delimiter" ";" -> Statement          {cons("CreateProcedure")}
    "drop" "function" "if" "exists" "`" ID "`;"                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> Statement          {cons("DropFunction")}
    "delimiter" "//" "create" "function" "`" ID "`" "(" {FunctionParameter ","}* ")" "returns" SQLType "begin" Statement "end" "//" "delimiter" ";"                                                                                                                                                                                                                                                                                                                                                                        -> Statement          {cons("CreateFunction")}
    "create" "view" "`" ID "`" "as" Query ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> Statement          {cons("CreateView")}
    ID SQLType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> FunctionParameter  {cons("Input")}
    "in" ID SQLType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> Parameter          {cons("Input")}
    "out" ID SQLType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> Parameter          {cons("Output")}
    "inout" ID SQLType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> Parameter          {cons("InOut")}
    "if" SQLExpression "then" Statement ElseIf* Else? "end" "if;"                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Statement          {cons("IfThen")}
    "begin" DeclareList Statement "end;"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> Statement          {cons("BeginEnd")}
    Update                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Statement          
    Insert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Statement          
    InsertInto                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Statement          
    Delete                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Statement          
    Return                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Statement          
    VariableAssign                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> Statement          
    ProcCall                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Statement          
    "*"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -> SQLExpression      {cons("Star")}
    "true"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> SQLExpression      {cons("True")}
    "false"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> SQLExpression      {cons("False")}
    "elseif" "(" SQLExpression ")" "then" Statement                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> ElseIf             {cons("ElseIf")}
    "else" Statement                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> Else               {cons("Else")}
    SQLExpression "OR" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> SQLExpression      {cons("Or")}
    SQLExpression "||" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> SQLExpression      {cons("Or")}
    SQLExpression "XOR" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> SQLExpression      {cons("Xor")}
    SQLExpression "AND" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> SQLExpression      {cons("And")}
    SQLExpression "&&" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> SQLExpression      {cons("And")}
    "NOT" "(" SQLExpression ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> SQLExpression      {cons("Not")}
    "!" "(" SQLExpression ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> SQLExpression      {cons("Not")}
    BooleanPrimary "IS" Not? TFU                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> SQLExpression      {cons("Is")}
    BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> SQLExpression      
    SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> SQLExpression      
    "True"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> TFU                {cons("True")}
    "False"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> TFU                {cons("False")}
    "Unknown"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> TFU                {cons("Unknown")}
    "Not"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> Not                {cons("Not")}
    BooleanPrimary "IS" Not? "NULL"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BooleanPrimary     {cons("IsNull")}
    BooleanPrimary "<=>" Predicate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> BooleanPrimary     {cons("Iff")}
    BooleanPrimary "=" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> BooleanPrimary     {cons("Equal")}
    BooleanPrimary ">=" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> BooleanPrimary     {cons("GreaterThanEquals")}
    BooleanPrimary ">" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> BooleanPrimary     {cons("GreaterThan")}
    BooleanPrimary "<=" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> BooleanPrimary     {cons("LessThanEquals")}
    BooleanPrimary "<" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> BooleanPrimary     {cons("LessThan")}
    BooleanPrimary "<>" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> BooleanPrimary     {cons("NotEqual")}
    BooleanPrimary "!=" BooleanPrimary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> BooleanPrimary     {cons("NotEqual")}
    BooleanPrimary "=" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BooleanPrimary     {cons("Equal")}
    BooleanPrimary ">=" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BooleanPrimary     {cons("GreaterThanEquals")}
    BooleanPrimary ">" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BooleanPrimary     {cons("GreaterThan")}
    BooleanPrimary "<=" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BooleanPrimary     {cons("LessThanEquals")}
    BooleanPrimary "<" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BooleanPrimary     {cons("LessThan")}
    BooleanPrimary "<>" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BooleanPrimary     {cons("NotEqual")}
    BooleanPrimary "!=" AllAny Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BooleanPrimary     {cons("NotEqual")}
    "ALL"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> AllAny             {cons("All")}
    "ANY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> AllAny             {cons("All")}
    Predicate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> BooleanPrimary     
    BitExpression Not? "IN" Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Predicate          {cons("InQuery")}
    BitExpression Not? "IN" SetExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> Predicate          {cons("InSet")}
    BitExpression Not? "BETWEEN" BitExpression "AND" Predicate                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Predicate          {cons("Between")}
    BitExpression "SOUNDS" "LIKE" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> Predicate          {cons("SoundsLike")}
    BitExpression Not? "LIKE" SimpleExpression Escape?                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> Predicate          {cons("Like")}
    BitExpression Not? "REGEXP" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> Predicate          {cons("Regexp")}
    BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Predicate          
    "ESCAPE" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> Escape             {cons("Escape")}
    BitExpression "|" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("BitOr")}
    BitExpression "&" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("BitAnd")}
    BitExpression "<<" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BitExpression      {cons("BitShiftLeft")}
    BitExpression ">>" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BitExpression      {cons("BitShiftRight")}
    BitExpression "+" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("Plus")}
    BitExpression "-" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("Minus")}
    BitExpression "*" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("Times")}
    BitExpression "/" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("Divide")}
    BitExpression "DIV" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> BitExpression      {cons("Div")}
    BitExpression "MOD" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> BitExpression      {cons("Mod")}
    BitExpression "%" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("Percent")}
    BitExpression "^" BitExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> BitExpression      {cons("Power")}
    BitExpression "+" IntervalExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> BitExpression      {cons("PlusInt")}
    BitExpression "-" IntervalExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> BitExpression      {cons("MinusInt")}
    SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> BitExpression      
    Literal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> SimpleExpression   
    Identifier                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> SimpleExpression   
    FunctionCall                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> SimpleExpression   
    SimpleExpression "COLLATE" CollationName                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> SimpleExpression   {cons("Collate")}
    ParamMarker                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> SimpleExpression   
    Variable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> SimpleExpression   
    SimpleExpression "||" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> SimpleExpression   {cons("BitOr")}
    "+" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> SimpleExpression   {cons("UnaryPlus")}
    "-" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> SimpleExpression   {cons("UnaryMinus")}
    "~" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> SimpleExpression   {cons("Reverse")}
    "!" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> SimpleExpression   {cons("BitNot")}
    "BINARY" SimpleExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> SimpleExpression   {cons("Binary")}
    "(" {SQLExpression ","}+ ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> SetExpression      {cons("SetExpression")}
    SetExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> SimpleExpression   
    "ROW" SQLExpression "," {SQLExpression ","}+                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> SimpleExpression   {cons("Row")}
    Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SimpleExpression   
    "EXISTS" Query                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> SimpleExpression   {cons("Exists")}
    "{" Identifier SQLExpression "}"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> SimpleExpression   {cons("EscapeSyntax")}
    MatchExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> SimpleExpression   
    CaseExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> SimpleExpression   
    IntervalExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> SimpleExpression   
    "'" SQLSTRING "'"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> Literal            {cons("String")}
    INT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -> Literal            {cons("Int")}
    DECIMAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> Literal            {cons("Decimal")}
    "true"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> BoolTrue           {cons("BoolTrue")}
    "false"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> BoolFalse          {cons("BoolFalse")}
    BoolTrue                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Literal            
    BoolFalse                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> Literal            
    "null"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Literal            {cons("Null")}
    "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Identifier         {cons("ColumnName")}
    "`" ID "`" "." "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> Identifier         {cons("TableColumnName")}
    "`" ID "`" "." "`" ID "`" "." "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Identifier         {cons("DBTableColumnName")}
    "@" ID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Variable           {cons("LocalVariable")}
    ID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> Variable           {cons("SystemVariable")}
    "?"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -> ParamMarker        {cons("Marker")}
    "MATCH" "(" {ID ","}+ ")" "AGAINST" "(" SQLExpression SearchModifier? ")"                                                                                                                                                                                                                                                                                                                                                                                                                                              -> MatchExpression    {cons("MatchExpression")}
    "IN" "BOOLEAN" "MODE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SearchModifier     {cons("InBooleanMode")}
    "WITH" "QUERY" "EXPANSION"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> SearchModifier     {cons("WithQueryExpansion")}
    "INTERVAL" SQLExpression Unit                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> IntervalExpression {cons("IntervalExpression")}
    "MICROSECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Unit               {cons("MicroSecondUnit")}
    "SECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Unit               {cons("SecondUnit")}
    "MINUTE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Unit               {cons("MinuteUnit")}
    "HOUR"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Unit               {cons("HourUnit")}
    "DAY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> Unit               {cons("DayUnit")}
    "WEEK"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Unit               {cons("WeekUnit")}
    "MONTH"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> Unit               {cons("MonthUnit")}
    "QUARTER"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> Unit               {cons("QuarterUnit")}
    "YEAR"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Unit               {cons("YearUnit")}
    "SECOND_MICROSECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> Unit               {cons("SecondMicroSecondUnit")}
    "MINUTE_MICROSECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> Unit               {cons("MinuteMicroSecondUnit")}
    "MINUTE_SECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> Unit               {cons("MinuteSecondUnit")}
    "HOUR_MICROSECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> Unit               {cons("HourMicroSecondUnit")}
    "HOUR_SECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Unit               {cons("HourSecondUnit")}
    "HOUR_MINUTE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Unit               {cons("HourMinuteUnit")}
    "DAY_MICROSECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> Unit               {cons("DayMicroSecondUnit")}
    "DAY_SECOND"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> Unit               {cons("DaySecondUnit")}
    "DAY_MINUTE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> Unit               {cons("DayMinuteUnit")}
    "DAY_HOUR"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Unit               {cons("DayHourUnit")}
    "YEAR_MONTH"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> Unit               {cons("YearMonthUnit")}
    "CASE" SQLExpression CaseWhen+ CaseElse? "END"                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> CaseExpression     {cons("CaseExpression")}
    "WHEN" SQLExpression "THEN" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> CaseWhen           {cons("CaseWhen")}
    "ELSE" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> CaseElse           {cons("CaseElse")}
    ID "(" {Parameter ","}* ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> FunctionCall       {cons("FunctionCall")}
    SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> Parameter          
    ID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> CollationName      
    "(" "SELECT" SelectType* {SelectExpression ","}+ FromPart? WherePart? GroupByPart? HavingPart? OrderByPart? LimitPart? ProcedurePart? IntoPart? ModePart? ")"                                                                                                                                                                                                                                                                                                                                                          -> Query              {cons("SelectQuery")}
    "SELECT" SelectType* {SelectExpression ","}+ FromPart? WherePart? GroupByPart? HavingPart? OrderByPart? LimitPart? ProcedurePart? IntoPart? ModePart? ";"                                                                                                                                                                                                                                                                                                                                                              -> Statement          {cons("SelectStatement")}
    "ALL"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SelectType         {cons("All")}
    "DISTINCT"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> SelectType         {cons("Distinct")}
    "DISTINCTROW"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> SelectType         {cons("DistinctRow")}
    "HIGH_PRIORITY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> SelectType         {cons("HighPriority")}
    "STRAIGHT_JOIN"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> SelectType         {cons("StraightJoin")}
    "SQL_SMALL_RESULT"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> SelectType         {cons("SmallResult")}
    "SQL_BIG_RESULT"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> SelectType         {cons("BigResult")}
    "SQL_BUFFER_RESULT"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -> SelectType         {cons("BufferResult")}
    "SQL_CACHE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> SelectType         {cons("Cache")}
    "SQL_NO_CACHE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> SelectType         {cons("NoCache")}
    "SQL_CALC_FOUND_ROWS"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SelectType         {cons("CalcFoundRows")}
    SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -> SelectExpression   
    "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> SelectExpression   {cons("ColumnName")}
    "`" ID "`" "." "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> SelectExpression   {cons("TableColumnName")}
    SQLExpression "AS" ID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> SelectExpression   {cons("ExpressionAs")}
    "`" ID "`" "AS" "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> SelectExpression   {cons("ColumnNameAs")}
    "`" ID "`" "." "`" ID "`" "AS" "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> SelectExpression   {cons("TableColumnNameAs")}
    "*"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -> SelectExpression   {cons("Star")}
    "FROM" TableReference*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> FromPart           {cons("FromPart")}
    "WHERE" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> WherePart          {cons("Where")}
    "GROUP" "BY" SQLExpression Order? Rollup?                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> GroupByPart        {cons("GroupByPart")}
    "WITH" "ROLLUP"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> Rollup             {cons("Rollup")}
    "ASC"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> Order              {cons("Ascending")}
    "DESC"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Order              {cons("Descending")}
    "HAVING" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> HavingPart         {cons("HavingPart")}
    "ORDER" "BY" SQLExpression Order?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> OrderByPart        {cons("OrderByPart")}
    "LIMIT" INT? INT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> LimitPart          {cons("LimitOffset")}
    "LIMIT" INT "OFFSET" INT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> LimitPart          {cons("LimitOffset")}
    "PROCEDURE" ID "(" {Parameter ","}* ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> ProcedurePart      {cons("ProcedurePart")}
    "INTO" "OUTFILE" SQLSTRING CharSet? ExportOptions                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> IntoPart           {cons("IntoOutFile")}
    "INTO" "DUMPFILE" SQLSTRING                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> IntoPart           {cons("IntoDumpFile")}
    "INTO" {TableName ","}*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> IntoPart           {cons("Into")}
    "CHARACTER" "SET" ID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> CharSet            {cons("CharSet")}
    "FOR" "UPDATE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> ModePart           {cons("ForUpdate")}
    "LOCK" "IN" "SHARE" "MODE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> ModePart           {cons("LockShareMode")}
    "ExportOptionsUnknown"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> ExportOptions      {cons("ExportOptions")}
    TableFactor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> TableReference     
    JoinTable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> TableReference     
    TableName                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> TableFactor        
    "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> TableName          {cons("TableName")}
    "`" ID "`" Alias IndexHint*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> TableFactor        {cons("Aliased")}
    Query Alias                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> TableFactor        {cons("Query")}
    "(" TableReference* ")"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> TableFactor        {cons("Bracket")}
    "OJ" TableReference "LEFT" "OUTER" "JOIN" TableReference "ON" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                            -> TableFactor        {cons("OJ")}
    "AS" ID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> Alias              {cons("Alias")}
    TableReference "INNER" "JOIN" TableFactor JoinCondition?                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> JoinTable          {cons("InnerJoin")}
    TableReference "CROSS" "JOIN" TableFactor JoinCondition?                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> JoinTable          {cons("CrossJoin")}
    TableReference "STRAIGHT_JOIN" TableFactor JoinCondition?                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> JoinTable          {cons("StraightJoin")}
    TableReference "LEFT" "JOIN" TableReference JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> JoinTable          {cons("LeftJoin")}
    TableReference "LEFT" "OUTER" "JOIN" TableReference JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> JoinTable          {cons("LeftOuterJoin")}
    TableReference "RIGHT" "JOIN" TableReference JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> JoinTable          {cons("RightJoin")}
    TableReference "RIGHT" "OUTER" "JOIN" TableReference JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> JoinTable          {cons("RightOuterJoin")}
    TableReference "NATURAL" "LEFT" "JOIN" TableFactor JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> JoinTable          {cons("NaturalLeftJoin")}
    TableReference "NATURAL" "LEFT" "OUTER" "JOIN" TableFactor JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                               -> JoinTable          {cons("NaturalLeftOuterJoin")}
    TableReference "NATURAL" "RIGHT" "JOIN" TableFactor JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> JoinTable          {cons("NaturalRightJoin")}
    TableReference "NATURAL" "RIGHT" "OUTER" "JOIN" TableFactor JoinCondition                                                                                                                                                                                                                                                                                                                                                                                                                                              -> JoinTable          {cons("NaturalRightOuterJoin")}
    "ON" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> JoinCondition      {cons("On")}
    "USING" {ID ","}+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> JoinCondition      {cons("Using")}
    "USE" IndexKey ForClause?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> IndexHint          {cons("Use")}
    "IGNORE" IndexKey ForClause?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> IndexHint          {cons("Ignore")}
    "FORCE" IndexKey ForClause?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -> IndexHint          {cons("Force")}
    "INDEX"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> IndexKey           {cons("Index")}
    "KEY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  -> IndexKey           {cons("Key")}
    "FOR" Jog {ID ","}+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -> ForClause          {cons("ForClause")}
    "JOIN"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Jog                {cons("Join")}
    "ORDER" "BY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> Jog                {cons("OrderBy")}
    "GROUP" "BY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> Jog                {cons("GroupBy")}
    "UPDATE" UpdateOption* TableReference "SET" {UpdateSet ","}+ WherePart? OrderByPart? LimitPart? ";"                                                                                                                                                                                                                                                                                                                                                                                                                    -> Update             {cons("Update")}
    "LOW_PRIORITY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> UpdateOption       {cons("LowPriority")}
    "IGNORE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> UpdateOption       {cons("Ignore")}
    ColumnName "=" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -> UpdateSet          {cons("UpdateSet")}
    ID "=" "DEFAULT"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -> UpdateSet          {cons("UpdateSetDefault")}
    "insert" InsertPriority? Ignore? Into? "`" ID "`" "(" {ColumnName ","}* ")" "values" "(" {SQLExpression ","}* ")" OnDuplicate? ";"                                                                                                                                                                                                                                                                                                                                                                                     -> Insert             {cons("Insert")}
    "`" ID "`"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> ColumnName         {cons("ColumnName")}
    "insert" "into" ID "(" {ID ","}* ")" Query ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> InsertInto         {cons("InsertInto")}
    "LOW_PRIORITY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> InsertPriority     {cons("LowPriority")}
    "DELAYED"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -> InsertPriority     {cons("DelayedPriority")}
    "HIGH_PRIORITY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> InsertPriority     {cons("HighPriority")}
    "IGNORE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Ignore             {cons("Ignore")}
    "into"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -> Into               {cons("Into")}
    "Values"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> Values             {cons("Values")}
    "Value"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> Values             {cons("Values")}
    "ON" "DUPLICATE" "KEY" "UPDATE" {UpdatePart ","}*                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -> OnDuplicate        {cons("OnDuplicate")}
    "DELETE" DeletePriority? Quick? Ignore? "FROM" ID WherePart? OrderByPart? LimitPart? ";"                                                                                                                                                                                                                                                                                                                                                                                                                               -> Delete             {cons("Delete")}
    "LOW_PRIORITY"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> DeletePriority     {cons("DeletePriority")}
    "QUICK"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> Quick              {cons("Quick")}
    ID "=" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -> UpdatePart         {cons("UpdatePart")}
    Declare*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -> DeclareList        {cons("DeclareList")}
    "DECLARE" {ID ","}+ SQLType DefaultDeclare? ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -> Declare            {cons("Declare")}
    "default" SQLExpression                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -> DefaultDeclare     {cons("DefaultDeclare")}
    "return" SQLExpression ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -> Return             {cons("Return")}
    "set" "@" ID "=" SQLExpression ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -> VariableAssign     {cons("VariableAssign")}
    "call" "`" ID "`" "(" {Parameter ","}* ")" ";"                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -> ProcCall           {cons("ProcCall")}

  context-free syntax
    "[[PrimaryKeyColumn]]"   -> PrimaryKeyColumn   {cons("PrimaryKeyColumn-Plhdr"), placeholder}
    "[[ColumnDefault]]"      -> ColumnDefault      {cons("ColumnDefault-Plhdr"), placeholder}
    "[[ColumnNullable]]"     -> ColumnNullable     {cons("ColumnNullable-Plhdr"), placeholder}
    "[[BOOL]]"               -> BOOL               {cons("BOOL-Plhdr"), placeholder}
    "[[Extra]]"              -> Extra              {cons("Extra-Plhdr"), placeholder}
    "[[Key]]"                -> Key                {cons("Key-Plhdr"), placeholder}
    "[[Reference]]"          -> Reference          {cons("Reference-Plhdr"), placeholder}
    "[[FunctionParameter]]"  -> FunctionParameter  {cons("FunctionParameter-Plhdr"), placeholder}
    "[[ElseIf]]"             -> ElseIf             {cons("ElseIf-Plhdr"), placeholder}
    "[[Else]]"               -> Else               {cons("Else-Plhdr"), placeholder}
    "[[TFU]]"                -> TFU                {cons("TFU-Plhdr"), placeholder}
    "[[AllAny]]"             -> AllAny             {cons("AllAny-Plhdr"), placeholder}
    "[[BooleanPrimary]]"     -> BooleanPrimary     {cons("BooleanPrimary-Plhdr"), placeholder}
    "[[Not]]"                -> Not                {cons("Not-Plhdr"), placeholder}
    "[[Predicate]]"          -> Predicate          {cons("Predicate-Plhdr"), placeholder}
    "[[Escape]]"             -> Escape             {cons("Escape-Plhdr"), placeholder}
    "[[BitExpression]]"      -> BitExpression      {cons("BitExpression-Plhdr"), placeholder}
    "[[SetExpression]]"      -> SetExpression      {cons("SetExpression-Plhdr"), placeholder}
    "[[SimpleExpression]]"   -> SimpleExpression   {cons("SimpleExpression-Plhdr"), placeholder}
    "[[DECIMAL]]"            -> DECIMAL            {cons("DECIMAL-Plhdr"), placeholder}
    "[[BoolTrue]]"           -> BoolTrue           {cons("BoolTrue-Plhdr"), placeholder}
    "[[BoolFalse]]"          -> BoolFalse          {cons("BoolFalse-Plhdr"), placeholder}
    "[[Literal]]"            -> Literal            {cons("Literal-Plhdr"), placeholder}
    "[[Identifier]]"         -> Identifier         {cons("Identifier-Plhdr"), placeholder}
    "[[Variable]]"           -> Variable           {cons("Variable-Plhdr"), placeholder}
    "[[ParamMarker]]"        -> ParamMarker        {cons("ParamMarker-Plhdr"), placeholder}
    "[[MatchExpression]]"    -> MatchExpression    {cons("MatchExpression-Plhdr"), placeholder}
    "[[SearchModifier]]"     -> SearchModifier     {cons("SearchModifier-Plhdr"), placeholder}
    "[[IntervalExpression]]" -> IntervalExpression {cons("IntervalExpression-Plhdr"), placeholder}
    "[[Unit]]"               -> Unit               {cons("Unit-Plhdr"), placeholder}
    "[[CaseExpression]]"     -> CaseExpression     {cons("CaseExpression-Plhdr"), placeholder}
    "[[CaseWhen]]"           -> CaseWhen           {cons("CaseWhen-Plhdr"), placeholder}
    "[[CaseElse]]"           -> CaseElse           {cons("CaseElse-Plhdr"), placeholder}
    "[[FunctionCall]]"       -> FunctionCall       {cons("FunctionCall-Plhdr"), placeholder}
    "[[CollationName]]"      -> CollationName      {cons("CollationName-Plhdr"), placeholder}
    "[[Statement]]"          -> Statement          {cons("Statement-Plhdr"), placeholder}
    "[[SelectType]]"         -> SelectType         {cons("SelectType-Plhdr"), placeholder}
    "[[SelectExpression]]"   -> SelectExpression   {cons("SelectExpression-Plhdr"), placeholder}
    "[[FromPart]]"           -> FromPart           {cons("FromPart-Plhdr"), placeholder}
    "[[GroupByPart]]"        -> GroupByPart        {cons("GroupByPart-Plhdr"), placeholder}
    "[[Rollup]]"             -> Rollup             {cons("Rollup-Plhdr"), placeholder}
    "[[HavingPart]]"         -> HavingPart         {cons("HavingPart-Plhdr"), placeholder}
    "[[Order]]"              -> Order              {cons("Order-Plhdr"), placeholder}
    "[[INT]]"                -> INT                {cons("INT-Plhdr"), placeholder}
    "[[ProcedurePart]]"      -> ProcedurePart      {cons("ProcedurePart-Plhdr"), placeholder}
    "[[SQLSTRING]]"          -> SQLSTRING          {cons("SQLSTRING-Plhdr"), placeholder}
    "[[IntoPart]]"           -> IntoPart           {cons("IntoPart-Plhdr"), placeholder}
    "[[CharSet]]"            -> CharSet            {cons("CharSet-Plhdr"), placeholder}
    "[[ModePart]]"           -> ModePart           {cons("ModePart-Plhdr"), placeholder}
    "[[ExportOptions]]"      -> ExportOptions      {cons("ExportOptions-Plhdr"), placeholder}
    "[[TableName]]"          -> TableName          {cons("TableName-Plhdr"), placeholder}
    "[[Alias]]"              -> Alias              {cons("Alias-Plhdr"), placeholder}
    "[[JoinTable]]"          -> JoinTable          {cons("JoinTable-Plhdr"), placeholder}
    "[[TableFactor]]"        -> TableFactor        {cons("TableFactor-Plhdr"), placeholder}
    "[[JoinCondition]]"      -> JoinCondition      {cons("JoinCondition-Plhdr"), placeholder}
    "[[IndexHint]]"          -> IndexHint          {cons("IndexHint-Plhdr"), placeholder}
    "[[IndexKey]]"           -> IndexKey           {cons("IndexKey-Plhdr"), placeholder}
    "[[ForClause]]"          -> ForClause          {cons("ForClause-Plhdr"), placeholder}
    "[[Jog]]"                -> Jog                {cons("Jog-Plhdr"), placeholder}
    "[[Update]]"             -> Update             {cons("Update-Plhdr"), placeholder}
    "[[TableReference]]"     -> TableReference     {cons("TableReference-Plhdr"), placeholder}
    "[[UpdateOption]]"       -> UpdateOption       {cons("UpdateOption-Plhdr"), placeholder}
    "[[UpdateSet]]"          -> UpdateSet          {cons("UpdateSet-Plhdr"), placeholder}
    "[[Insert]]"             -> Insert             {cons("Insert-Plhdr"), placeholder}
    "[[ColumnName]]"         -> ColumnName         {cons("ColumnName-Plhdr"), placeholder}
    "[[InsertInto]]"         -> InsertInto         {cons("InsertInto-Plhdr"), placeholder}
    "[[Query]]"              -> Query              {cons("Query-Plhdr"), placeholder}
    "[[InsertPriority]]"     -> InsertPriority     {cons("InsertPriority-Plhdr"), placeholder}
    "[[Into]]"               -> Into               {cons("Into-Plhdr"), placeholder}
    "[[Values]]"             -> Values             {cons("Values-Plhdr"), placeholder}
    "[[OnDuplicate]]"        -> OnDuplicate        {cons("OnDuplicate-Plhdr"), placeholder}
    "[[Delete]]"             -> Delete             {cons("Delete-Plhdr"), placeholder}
    "[[Ignore]]"             -> Ignore             {cons("Ignore-Plhdr"), placeholder}
    "[[WherePart]]"          -> WherePart          {cons("WherePart-Plhdr"), placeholder}
    "[[OrderByPart]]"        -> OrderByPart        {cons("OrderByPart-Plhdr"), placeholder}
    "[[LimitPart]]"          -> LimitPart          {cons("LimitPart-Plhdr"), placeholder}
    "[[DeletePriority]]"     -> DeletePriority     {cons("DeletePriority-Plhdr"), placeholder}
    "[[Quick]]"              -> Quick              {cons("Quick-Plhdr"), placeholder}
    "[[UpdatePart]]"         -> UpdatePart         {cons("UpdatePart-Plhdr"), placeholder}
    "[[DeclareList]]"        -> DeclareList        {cons("DeclareList-Plhdr"), placeholder}
    "[[Declare]]"            -> Declare            {cons("Declare-Plhdr"), placeholder}
    "[[SQLType]]"            -> SQLType            {cons("SQLType-Plhdr"), placeholder}
    "[[DefaultDeclare]]"     -> DefaultDeclare     {cons("DefaultDeclare-Plhdr"), placeholder}
    "[[Return]]"             -> Return             {cons("Return-Plhdr"), placeholder}
    "[[VariableAssign]]"     -> VariableAssign     {cons("VariableAssign-Plhdr"), placeholder}
    "[[SQLExpression]]"      -> SQLExpression      {cons("SQLExpression-Plhdr"), placeholder}
    "[[ProcCall]]"           -> ProcCall           {cons("ProcCall-Plhdr"), placeholder}
    "[[ID]]"                 -> ID                 {cons("ID-Plhdr"), placeholder}
    "[[Parameter]]"          -> Parameter          {cons("Parameter-Plhdr"), placeholder}

  context-free syntax
    

module Booster2
imports Common AbstractBoosterModel Relational Triple

exports
  context-free start-symbols
    System

  context-free syntax
    "system" ID SystemComponent*                                               -> System                     {cons("System")}
    "System" ID SystemComponent*                                               -> System                     {cons("System")}
    SetDef                                                                     -> SystemComponent            
    Class                                                                      -> SystemComponent            
    Import                                                                     -> SystemComponent            
    "import" STRING                                                            -> Import                     {cons("Import")}
    "Import" STRING                                                            -> Import                     {cons("Import")}
    "IMPORT" STRING                                                            -> Import                     {cons("Import")}
    SystemComponent                                                            -> BoosterTerm                
    "set" ID "{" {ID ","}+ "}"                                                 -> SetDef                     {cons("SetDef")}
    SetDef                                                                     -> BoosterTerm                
    "class" ID Extends? "{" ClassComponents* "}"                               -> Class                      {cons("Class")}
    Class                                                                      -> BoosterTerm                
    "extends" {Extension ","}+                                                 -> Extends                    {cons("Extend")}
    Extends                                                                    -> BoosterTerm                
    ID                                                                         -> Extension                  {cons("Extension")}
    "attributes" Attribute*                                                    -> ClassComponents            {cons("Attributes")}
    "methods" Method*                                                          -> ClassComponents            {cons("Methods")}
    "invariants" Invariant*                                                    -> ClassComponents            {cons("Invariants")}
    "workflows" WorkflowComponent*                                             -> ClassComponents            {cons("Workflows")}
    ClassComponents                                                            -> BoosterTerm                
    ID Decoration* ":" TypeDecl                                                -> Attribute                  {cons("Attribute")}
    Attribute                                                                  -> BoosterTerm                
    "(" "ID" ")"                                                               -> Identity                   {cons("Identity")}
    "(" "NA" ")"                                                               -> NoAudit                    {cons("NoAudit")}
    Identity                                                                   -> Decoration                 
    NoAudit                                                                    -> Decoration                 
    PrimTypeDecl                                                               -> TypeDecl                   
    "[" PrimTypeDecl "]"                                                       -> TypeDecl                   {cons("Optional")}
    "set" "(" PrimTypeDecl ")" Multiplicity                                    -> TypeDecl                   {cons("Set")}
    "SET" "(" PrimTypeDecl ")" Multiplicity                                    -> TypeDecl                   {cons("Set")}
    TypeDecl                                                                   -> BoosterTerm                
    BasicTypeDecl                                                              -> PrimTypeDecl               {cons("BasicType")}
    ID                                                                         -> PrimTypeDecl               {cons("UniDirectional")}
    ID "." ID                                                                  -> PrimTypeDecl               {cons("BiDirectional")}
    PrimTypeDecl                                                               -> BoosterTerm                
    "STRING"                                                                   -> BasicTypeDecl              {cons("String")}
    "String"                                                                   -> BasicTypeDecl              {cons("String")}
    "string"                                                                   -> BasicTypeDecl              {cons("String")}
    "INT"                                                                      -> BasicTypeDecl              {cons("Int")}
    "Int"                                                                      -> BasicTypeDecl              {cons("Int")}
    "int"                                                                      -> BasicTypeDecl              {cons("Int")}
    "DECIMAL"                                                                  -> BasicTypeDecl              {cons("Decimal")}
    "Decimal"                                                                  -> BasicTypeDecl              {cons("Decimal")}
    "decimal"                                                                  -> BasicTypeDecl              {cons("Decimal")}
    "DATE"                                                                     -> BasicTypeDecl              {cons("Date")}
    "Date"                                                                     -> BasicTypeDecl              {cons("Date")}
    "date"                                                                     -> BasicTypeDecl              {cons("Date")}
    "TIME"                                                                     -> BasicTypeDecl              {cons("Time")}
    "Time"                                                                     -> BasicTypeDecl              {cons("Time")}
    "time"                                                                     -> BasicTypeDecl              {cons("Time")}
    "DATETIME"                                                                 -> BasicTypeDecl              {cons("DateTime")}
    "DateTime"                                                                 -> BasicTypeDecl              {cons("DateTime")}
    "Datetime"                                                                 -> BasicTypeDecl              {cons("DateTime")}
    "datetime"                                                                 -> BasicTypeDecl              {cons("DateTime")}
    "BOOLEAN"                                                                  -> BasicTypeDecl              {cons("Boolean")}
    "Boolean"                                                                  -> BasicTypeDecl              {cons("Boolean")}
    "boolean"                                                                  -> BasicTypeDecl              {cons("Boolean")}
    "PASSWORD"                                                                 -> BasicTypeDecl              {cons("Password")}
    "Password"                                                                 -> BasicTypeDecl              {cons("Password")}
    "password"                                                                 -> BasicTypeDecl              {cons("Password")}
    "[" INT ".." INT "]"                                                       -> Multiplicity               {cons("MultMinAndMax")}
    "[" ".." INT "]"                                                           -> Multiplicity               {cons("MultJustMax")}
    "[" INT ".." "*]"                                                          -> Multiplicity               {cons("MultJustMin")}
    "[" INT ".." "]"                                                           -> Multiplicity               {cons("MultJustMin")}
    "[" INT "]"                                                                -> Multiplicity               {cons("MultSingle")}
    "[" "*" "]"                                                                -> Multiplicity               {cons("MultAny")}
                                                                               -> Multiplicity               {cons("MultAny")}
    Multiplicity                                                               -> BoosterTerm                
    ID Decoration* "{" ConstraintOrGuardedCommand "}"                          -> Method                     {cons("Method")}
    Constraint                                                                 -> Invariant                  {cons("Invariant")}
    Constraint                                                                 -> ConstraintOrGuardedCommand 
    GuardedCommand                                                             -> ConstraintOrGuardedCommand 
    Constraint "|" GuardedCommand                                              -> ConstraintOrGuardedCommand {cons("Both")}
    Method                                                                     -> BoosterTerm                
    "true"                                                                     -> Constraint                 {cons("True")}
    "false"                                                                    -> Constraint                 {cons("False")}
    Relation                                                                   -> Constraint                 
    "not" Constraint                                                           -> Constraint                 {cons("Not")}
    Constraint "&" Constraint                                                  -> Constraint                 {cons("And"), assoc}
    Constraint "or" Constraint                                                 -> Constraint                 {cons("Or"), assoc}
    Constraint "=>" Constraint                                                 -> Constraint                 {cons("Implies"), assoc}
    Constraint ";" Constraint                                                  -> Constraint                 {cons("Then"), assoc}
    "(" Constraint ")"                                                         -> Constraint                 {bracket}
    "exists" ID ":" Expression "@" Constraint                                  -> Constraint                 {cons("Exists")}
    "forall" ID ":" Expression "@" Constraint                                  -> Constraint                 {cons("Forall")}
    MethodReference                                                            -> Constraint                 
    Constraint                                                                 -> BoosterTerm                
    Relation                                                                   -> BoosterTerm                
    Expression "=" Expression                                                  -> Relation                   {cons("Equal"), left}
    Expression "/=" Expression                                                 -> Relation                   {cons("NotEqual"), left}
    Expression ":" Expression                                                  -> Relation                   {cons("In"), left}
    Expression "/:" Expression                                                 -> Relation                   {cons("NotIn"), left}
    Expression "<" Expression                                                  -> Relation                   {cons("LessThan"), left}
    Expression ">" Expression                                                  -> Relation                   {cons("GreaterThan"), left}
    Expression "<=" Expression                                                 -> Relation                   {cons("LessThanEquals"), left}
    Expression ">=" Expression                                                 -> Relation                   {cons("GreaterThanEquals"), left}
    Expression "<:" Expression                                                 -> Relation                   {cons("Subset"), left}
    Expression "<<:" Expression                                                -> Relation                   {cons("SubsetEquals"), left}
    Expression ":>" Expression                                                 -> Relation                   {cons("Superset"), left}
    Expression ":>>" Expression                                                -> Relation                   {cons("SupersetEquals"), left}
    "head" Expression                                                          -> Expression                 {cons("Head"), right}
    "tail" Expression                                                          -> Expression                 {cons("Tail"), right}
    "card" Expression                                                          -> Expression                 {cons("Cardinality"), right}
    "-" Expression                                                             -> Expression                 {cons("Negative"), right}
    Expression "+" Expression                                                  -> Expression                 {cons("Plus"), left}
    Expression "-" Expression                                                  -> Expression                 {cons("Minus"), left}
    Expression "*" Expression                                                  -> Expression                 {cons("Times"), left}
    Expression "/" Expression                                                  -> Expression                 {cons("Divide"), left}
    Expression "max" Expression                                                -> Expression                 {cons("Maximum"), left}
    Expression "min" Expression                                                -> Expression                 {cons("Minimum"), left}
    Expression "/\\" Expression                                                -> Expression                 {cons("Intersection"), left}
    Expression "\\/" Expression                                                -> Expression                 {cons("Union"), left}
    Expression "++" Expression                                                 -> Expression                 {cons("Concat"), left}
    ValueExpression                                                            -> Expression                 
    "(" Expression ")"                                                         -> Expression                 {bracket}
    Expression                                                                 -> BoosterTerm                
    BasicValue                                                                 -> ValueExpression            {cons("BasicValue")}
    TypeExtent                                                                 -> ValueExpression            {cons("TypeExtent")}
    Path                                                                       -> ValueExpression            
    "null"                                                                     -> ValueExpression            {cons("Null"), prefer}
    "{" ID ":" Expression "@" Path "}"                                         -> ValueExpression            {cons("SetComprehension")}
    "{" ID ":" Expression "|" Constraint "@" Path "}"                          -> ValueExpression            {cons("SetComprehension")}
    "{" {Expression ","}* "}"                                                  -> ValueExpression            {cons("SetExtent")}
    ValueExpression                                                            -> BoosterTerm                
    INT                                                                        -> BasicValue                 {cons("Integer")}
    STRING                                                                     -> BasicValue                 {cons("String")}
    DECIMAL                                                                    -> BasicValue                 {cons("Decimal")}
    "true"                                                                     -> BasicValue                 {cons("True")}
    "false"                                                                    -> BasicValue                 {cons("False")}
    "currentdatetime"                                                          -> BasicValue                 {cons("CurrentDateTime")}
    "CurrentDateTime"                                                          -> BasicValue                 {cons("CurrentDateTime")}
    "currentDateTime"                                                          -> BasicValue                 {cons("CurrentDateTime")}
    "currentdate"                                                              -> BasicValue                 {cons("CurrentDate")}
    "currenttime"                                                              -> BasicValue                 {cons("CurrentTime")}
    "currentUser"                                                              -> CurrentUser                {cons("CurrentUser")}
    "CurrentUser"                                                              -> CurrentUser                {cons("CurrentUser")}
    "currentuser"                                                              -> CurrentUser                {cons("CurrentUser")}
    "STRING"                                                                   -> TypeExtent                 {cons("String"), prefer}
    "String"                                                                   -> TypeExtent                 {cons("String"), prefer}
    "string"                                                                   -> TypeExtent                 {cons("String"), prefer}
    "INT"                                                                      -> TypeExtent                 {cons("Int"), prefer}
    "Int"                                                                      -> TypeExtent                 {cons("Int"), prefer}
    "int"                                                                      -> TypeExtent                 {cons("Int"), prefer}
    "DECIMAL"                                                                  -> TypeExtent                 {cons("Decimal"), prefer}
    "Decimal"                                                                  -> TypeExtent                 {cons("Decimal"), prefer}
    "decimal"                                                                  -> TypeExtent                 {cons("Decimal"), prefer}
    "DATE"                                                                     -> TypeExtent                 {cons("Date"), prefer}
    "Date"                                                                     -> TypeExtent                 {cons("Date"), prefer}
    "date"                                                                     -> TypeExtent                 {cons("Date"), prefer}
    "TIME"                                                                     -> TypeExtent                 {cons("Time"), prefer}
    "Time"                                                                     -> TypeExtent                 {cons("Time"), prefer}
    "time"                                                                     -> TypeExtent                 {cons("Time"), prefer}
    "DATETIME"                                                                 -> TypeExtent                 {cons("DateTime"), prefer}
    "DateTime"                                                                 -> TypeExtent                 {cons("DateTime"), prefer}
    "Datetime"                                                                 -> TypeExtent                 {cons("DateTime"), prefer}
    "datetime"                                                                 -> TypeExtent                 {cons("DateTime"), prefer}
    "BOOLEAN"                                                                  -> TypeExtent                 {cons("Boolean"), prefer}
    "Boolean"                                                                  -> TypeExtent                 {cons("Boolean"), prefer}
    "boolean"                                                                  -> TypeExtent                 {cons("Boolean"), prefer}
    "PASSWORD"                                                                 -> TypeExtent                 {cons("Password"), prefer}
    "Password"                                                                 -> TypeExtent                 {cons("Password"), prefer}
    "password"                                                                 -> TypeExtent                 {cons("Password"), prefer}
    PathStart                                                                  -> Path                       
    Path "." PathComponent                                                     -> Path                       {cons("Path"), prefer}
    Path                                                                       -> BoosterTerm                
    Input                                                                      -> PathStart                  
    Output                                                                     -> PathStart                  
    This                                                                       -> PathStart                  
    ThisPrimed                                                                 -> PathStart                  
    CurrentUser                                                                -> PathStart                  
    ID Primed?                                                                 -> PathStart                  {cons("PathStart")}
    PathStart                                                                  -> BoosterTerm                
    ID "?"                                                                     -> Input                      {cons("Input")}
    ID "!"                                                                     -> Output                     {cons("Output")}
    "this"                                                                     -> This                       {cons("This")}
    "this'"                                                                    -> ThisPrimed                 {cons("ThisPrimed")}
    "'"                                                                        -> Primed                     {cons("Primed")}
    ID Primed?                                                                 -> PathComponent              {cons("PathComponent")}
                                                                               -> PathComponent              {cons("PathComponent"), deprecated}
    PathComponent                                                              -> BoosterTerm                
    Path "(" {Subst ","}* ")"                                                  -> MethodReference            {cons("MethodReference")}
    Input "=" Expression                                                       -> Subst                      {cons("Subst")}
    MethodReference                                                            -> BoosterTerm                
    SeqWf                                                                      -> WorkflowComponent          
    ParWf                                                                      -> WorkflowComponent          
    "seq" ID ":" SeqWfExpression                                               -> SeqWf                      {cons("SeqWf")}
    "par" ID ":" ParWfExpression                                               -> ParWf                      {cons("ParWf")}
    "par" Constraint "&" ID ":" ParWfExpression                                -> ParWf                      {cons("ParWf2")}
    "Skip"                                                                     -> SeqWfExpression            {cons("Skip")}
    "SKIP"                                                                     -> SeqWfExpression            {cons("Skip")}
    GuardedAction "->" SeqWfExpression "[]" GuardedAction "->" SeqWfExpression -> SeqWfExpression            {cons("Choice")}
    "WAIT{" {INT ","}+ "}" "->" SeqWfExpression                                -> SeqWfExpression            {cons("Wait")}
    "Wait{" {INT ","}+ "}" "->" SeqWfExpression                                -> SeqWfExpression            {cons("Wait")}
    ID                                                                         -> SeqWfExpression            {cons("WorkflowReference")}
    GuardedAction "->" SeqWfExpression                                         -> SeqWfExpression            {cons("Prefix")}
    "(" SeqWfExpression ")"                                                    -> SeqWfExpression            {bracket}
    Guard "&" MethodReference                                                  -> GuardedAction              {cons("GA")}
    "(" GuardedAction ")"                                                      -> GuardedAction              {bracket}
    Constraint                                                                 -> Guard                      {cons("Normal")}
    "Delayed" Constraint                                                       -> Guard                      {cons("Delayed")}
    ID                                                                         -> ParWfExpression            {cons("Single")}
    ID "|||" ParWfExpression                                                   -> ParWfExpression            {cons("Multiple")}

  context-free syntax
    "[[System]]"                     -> System                     {cons("System-Plhdr"), placeholder}
    "[[Import]]"                     -> Import                     {cons("Import-Plhdr"), placeholder}
    "[[SystemComponent]]"            -> SystemComponent            {cons("SystemComponent-Plhdr"), placeholder}
    "[[SetDef]]"                     -> SetDef                     {cons("SetDef-Plhdr"), placeholder}
    "[[Class]]"                      -> Class                      {cons("Class-Plhdr"), placeholder}
    "[[Extends]]"                    -> Extends                    {cons("Extends-Plhdr"), placeholder}
    "[[Extension]]"                  -> Extension                  {cons("Extension-Plhdr"), placeholder}
    "[[ClassComponents]]"            -> ClassComponents            {cons("ClassComponents-Plhdr"), placeholder}
    "[[Attribute]]"                  -> Attribute                  {cons("Attribute-Plhdr"), placeholder}
    "[[Identity]]"                   -> Identity                   {cons("Identity-Plhdr"), placeholder}
    "[[NoAudit]]"                    -> NoAudit                    {cons("NoAudit-Plhdr"), placeholder}
    "[[TypeDecl]]"                   -> TypeDecl                   {cons("TypeDecl-Plhdr"), placeholder}
    "[[PrimTypeDecl]]"               -> PrimTypeDecl               {cons("PrimTypeDecl-Plhdr"), placeholder}
    "[[BasicTypeDecl]]"              -> BasicTypeDecl              {cons("BasicTypeDecl-Plhdr"), placeholder}
    "[[Multiplicity]]"               -> Multiplicity               {cons("Multiplicity-Plhdr"), placeholder}
    "[[Decoration]]"                 -> Decoration                 {cons("Decoration-Plhdr"), placeholder}
    "[[Invariant]]"                  -> Invariant                  {cons("Invariant-Plhdr"), placeholder}
    "[[ConstraintOrGuardedCommand]]" -> ConstraintOrGuardedCommand {cons("ConstraintOrGuardedCommand-Plhdr"), placeholder}
    "[[GuardedCommand]]"             -> GuardedCommand             {cons("GuardedCommand-Plhdr"), placeholder}
    "[[Method]]"                     -> Method                     {cons("Method-Plhdr"), placeholder}
    "[[Relation]]"                   -> Relation                   {cons("Relation-Plhdr"), placeholder}
    "[[ValueExpression]]"            -> ValueExpression            {cons("ValueExpression-Plhdr"), placeholder}
    "[[STRING]]"                     -> STRING                     {cons("STRING-Plhdr"), placeholder}
    "[[DECIMAL]]"                    -> DECIMAL                    {cons("DECIMAL-Plhdr"), placeholder}
    "[[BasicValue]]"                 -> BasicValue                 {cons("BasicValue-Plhdr"), placeholder}
    "[[TypeExtent]]"                 -> TypeExtent                 {cons("TypeExtent-Plhdr"), placeholder}
    "[[CurrentUser]]"                -> CurrentUser                {cons("CurrentUser-Plhdr"), placeholder}
    "[[PathStart]]"                  -> PathStart                  {cons("PathStart-Plhdr"), placeholder}
    "[[Output]]"                     -> Output                     {cons("Output-Plhdr"), placeholder}
    "[[This]]"                       -> This                       {cons("This-Plhdr"), placeholder}
    "[[ThisPrimed]]"                 -> ThisPrimed                 {cons("ThisPrimed-Plhdr"), placeholder}
    "[[Primed]]"                     -> Primed                     {cons("Primed-Plhdr"), placeholder}
    "[[PathComponent]]"              -> PathComponent              {cons("PathComponent-Plhdr"), placeholder}
    "[[Path]]"                       -> Path                       {cons("Path-Plhdr"), placeholder}
    "[[Subst]]"                      -> Subst                      {cons("Subst-Plhdr"), placeholder}
    "[[Input]]"                      -> Input                      {cons("Input-Plhdr"), placeholder}
    "[[Expression]]"                 -> Expression                 {cons("Expression-Plhdr"), placeholder}
    "[[BoosterTerm]]"                -> BoosterTerm                {cons("BoosterTerm-Plhdr"), placeholder}
    "[[WorkflowComponent]]"          -> WorkflowComponent          {cons("WorkflowComponent-Plhdr"), placeholder}
    "[[SeqWf]]"                      -> SeqWf                      {cons("SeqWf-Plhdr"), placeholder}
    "[[ParWf]]"                      -> ParWf                      {cons("ParWf-Plhdr"), placeholder}
    "[[INT]]"                        -> INT                        {cons("INT-Plhdr"), placeholder}
    "[[SeqWfExpression]]"            -> SeqWfExpression            {cons("SeqWfExpression-Plhdr"), placeholder}
    "[[MethodReference]]"            -> MethodReference            {cons("MethodReference-Plhdr"), placeholder}
    "[[GuardedAction]]"              -> GuardedAction              {cons("GuardedAction-Plhdr"), placeholder}
    "[[Guard]]"                      -> Guard                      {cons("Guard-Plhdr"), placeholder}
    "[[Constraint]]"                 -> Constraint                 {cons("Constraint-Plhdr"), placeholder}
    "[[ID]]"                         -> ID                         {cons("ID-Plhdr"), placeholder}
    "[[ParWfExpression]]"            -> ParWfExpression            {cons("ParWfExpression-Plhdr"), placeholder}

  context-free priorities
    GuardedAction "->" SeqWfExpression -> SeqWfExpression >
    GuardedAction "->" SeqWfExpression "[]" GuardedAction "->" SeqWfExpression
    -> SeqWfExpression

  context-free priorities
    { "forall" ID ":" Expression "@" Constraint -> Constraint
      "exists" ID ":" Expression "@" Constraint -> Constraint } >
    "not" Constraint -> Constraint >
    Constraint "&" Constraint -> Constraint >
    Constraint "or" Constraint -> Constraint >
    Constraint "=>" Constraint -> Constraint >
    Constraint ";" Constraint -> Constraint

  context-free priorities

  context-free priorities
    {right:
      "-" Expression -> Expression
      "card" Expression -> Expression
      "head" Expression -> Expression
      "tail" Expression -> Expression
    } >
    {left:
      Expression "*" Expression -> Expression
      Expression "/" Expression -> Expression
      Expression "/\\" Expression -> Expression
      Expression "\\/" Expression -> Expression
    } >
    {left:
      Expression "+" Expression -> Expression
      Expression "-" Expression -> Expression
      Expression "++" Expression -> Expression
    } >
    {left:
      Expression "max" Expression -> Expression
      Expression "min" Expression -> Expression
    }

module EmbeddedBooster[E]

imports
  Booster2
  AbstractBoosterModel
  Common
 
exports
  variables
    %% [ij]  [0-9\']*            -> DeciLiteral {prefer}
    %% [ij]  [\_] [a-zA-Z0-9\']* -> DeciLiteral {prefer}
    [xyz] [0-9]*            -> ID          {prefer}
    [xyz] [\_] [a-zA-Z0-9]* -> ID          {prefer}

  context-free restrictions
    ID -/- [\_a-zA-Z0-9] 

exports
	
  %%%
  %% Quotations for Constraint and GuardedCommand
  %%%
  context-free syntax
    "c" "|[" Constraint "]|"     -> E {cons("ToMetaExpr")}
    "g" "|[" GuardedCommand "]|" -> E {cons("ToMetaExpr")}
    "e" "|[" Expression "]|"     -> E {cons("ToMetaExpr")}
    "p" "|[" Path "]|"           -> E {cons("ToMetaExpr")}
				"|[" BoosterTerm "]|"    -> E {cons("ToMetaExpr")}
            
  %%%
  %% Anti Quotations for Constraint and GuardedCommand
  %%%
  context-free syntax
    "~"       E  -> Constraint     {cons("FromMetaExpr")}
    "~"       E  -> GuardedCommand {cons("FromMetaExpr")}
    "~"       E  -> Expression     {cons("FromMetaExpr")}
    "~"       E  -> Path           {cons("FromMetaExpr")}

module Stratego-Sugar-Overlays
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax
    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}

  syntax
    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}


  context-free syntax
    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
  > {

    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    }
  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    
    Anno+ RuleDef               -> Def {cons("AnnoDef")}

    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
       
    %% Rule definition with pattern matched term parameters
    Id "(" {Typedid ","}* 
       "|" {Term ","}* ")" ":" Rule 		-> RuleDef {cons("RDefP"), avoid}

  sorts Rule RuleCond
  context-free syntax
    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}

    "where" Strategy -> RuleCond {cons("WhereClause")}
    "with"  Strategy -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

    %% Strategy definition with pattern matched term parameters
    Id "(" {Typedid ","}* "|" {Term ","}* ")" "=" Strategy -> StrategyDef {cons("SDefP"), avoid}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
   "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
%%    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  sorts SwitchCase
  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}

    "if" Strategy "then" Strategy 
                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase*
         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}

    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

    Term ":=" Term			  -> Strategy {cons("Assign")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy
      Strategy "#" StrategyParen          -> Strategy
    }
  > { "!" Term 				  -> Strategy
      "?" Term 				  -> Strategy
    }
  > StrategyAngle Term 		          -> Strategy
  > Strategy "=>" Term 		  	  -> Strategy
  > Strategy ";" Strategy 		  -> Strategy
  > {right: 
     Strategy "+" Strategy 		  -> Strategy
     Strategy "<+" Strategy 		  -> Strategy
     Strategy "+>" Strategy 		  -> Strategy
     
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy
    }

  context-free priorities
    Strategy 				  -> StrategyMid
  > Strategy "+" Strategy 		  -> Strategy

  context-free priorities
    { Strategy StrategyCurly      -> Strategy
      Strategy "#" StrategyParen  -> Strategy
    }
    .> Term ":=" Term -> Strategy




module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LID				-> ID

  context-free syntax
    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
    "_" Term 			 -> Term {cons("BuildDefault"),prefer}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}

    StrategyAngle		 -> PreTerm {cons("RootApp")}
    StrategyAngle		 -> Term {cons("RootApp"),prefer}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType
  context-free syntax
    Sort	                -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
    "(" Type ")"                -> ArgType {bracket}
    ConstType			-> ArgType
    Type	                -> RetType
    FunType			-> RetType {reject}

    FunType			-> Type
    ConstType			-> Type

  %%%
   %% Restriction is required for the Sort* in Sdecl: List(a) is
   %% ambiguous.
   %%%
  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var Wld
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    %% ":" Var                  -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    Var 			 -> PreTerm 
    Var 			 -> Term {prefer}

    "_" 			 -> Wld {cons("Wld")}
    Wld 			 -> PreTerm
    Wld 			 -> Term {prefer}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}

    Var "@" Term 		 -> Term {cons("As"),prefer}
    Var "@" PreTerm 		 -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}

    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    Anno+ StrategyDef -> Def {cons("AnnoDef")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}

    "external"
    EmptyId "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts EmptyId
  lexical syntax
  
    -> EmptyId

  sorts Anno
  context-free syntax
    "extend"      -> Anno {cons("Extend")}
    "override"    -> Anno {cons("Override")}
    "internal"    -> Anno {cons("Internal")}
%%  "sealed"      -> Anno {cons("Sealed")}
%%  "extensible"  -> Anno {cons("Extensible")}
%%  "overridable" -> Anno {cons("Overridable")}

  lexical syntax
    
    "extend"      -> Keyword
    "override"    -> Keyword
    "internal"    -> Keyword
    "sealed"      -> Keyword
    "extensible"  -> Keyword
    "overridable" -> Keyword

  lexical restrictions
  
    "extend"
    "override"
    "internal"
    "sealed"
    "extensible"
    "overridable" -/- [a-zA-Z0-9\'\-\_]

  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports
  Stratego-Core-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ImportModName* 	-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

  sorts ImportModName
  context-free syntax
    ModName              -> ImportModName {cons("Import")}
  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 




module Stratego-Sugar-StringQuotations
exports

  sorts
    StringQuotation
    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
    Padding

  context-free syntax

    StringQuotation -> PreTerm

  syntax

    StringQuotation -> <PreTerm-CF>

    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
    [\[\]]                                                  -> <QuotedBracket1-LEX>
    "$"                                                     -> <Dollar1-LEX>

    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
    [\{\}]                                                  -> <QuotedBracket2-LEX>
    "$"                                                     -> <Dollar2-LEX>

    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
    [\(\)]                                                  -> <QuotedBracket3-LEX>
    "$"                                                     -> <Dollar3-LEX>

    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
    [\<\>]                                                  -> <QuotedBracket4-LEX>
    "$"                                                     -> <Dollar4-LEX>
   
    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
    <Padding-LEX>                                           -> Padding
                                                            -> <Padding-LEX> {indentpadding}

  lexical restrictions

    StringQuotedChars1 -/- ~[\[\]\$]   
    StringQuotedChars2 -/- ~[\{\}\$]    
    StringQuotedChars3 -/- ~[\(\)\$]    
    StringQuotedChars4 -/- ~[\<\>\$]
    Dollar1            -/- [\[\]] . [\$]
    Dollar2            -/- [\{\}] . [\$]
    Dollar3            -/- [\(\)] . [\$]
    Dollar4            -/- [\<\>] . [\$]

module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar




module Stratego-Sugar-Constants
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
  Stratego-Sugar-StringQuotations
exports
  sorts Char CharChar
  lexical syntax
    "'" CharChar "'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart
  lexical syntax
    {ModNamePart "/"}+ -> ModName
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID Wld
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
    [\'] [a-z]+                       -> Id

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID

  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\_\*]
    Id   -/- [\-].~[\>]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id {reject}
    "'"     -> Id {reject}

    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all"
    "case" %% not reserved kw
    "constructors"
    "else" %% not reserved kw
    "end" %% not reserved kw
    "external" %% not reserved kw
    "fail"
    "id"
    "if" %% not reserved kw
    "in"
    "imports" %% not reserved kw
    "let"
    "module"
    "not"
    "one"
    "overlays"
    "otherwise" %% not reserved kw
    "prim"
    "rec" %% not reserved kw
    "rules"
    "script"
    "signature"
    "some"
    "sorts"
    "strategies"
    "stratego"
    "switch" %% not reserved kw
    "test"
    "then" %% not reserved kw
    "where"
    "import-term"
      -/- [a-zA-Z0-9\'\-\_]
  
  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword
  lexical syntax
    "all"               -> Keyword
    "constructors" 	-> Keyword
    "fail" 		-> Keyword
    "id" 		-> Keyword
    "in" 		-> Keyword
    "let" 		-> Keyword
    "module" 		-> Keyword
    "not" 		-> Keyword
    "one" 		-> Keyword
    "overlays" 		-> Keyword
    "prim" 		-> Keyword
    "rules" 		-> Keyword
    "script" 		-> Keyword
    "signature" 	-> Keyword
    "some" 		-> Keyword
    "sorts" 		-> Keyword
    "strategies" 	-> Keyword
    "stratego" 		-> Keyword
    "test" 		-> Keyword
    "where" 		-> Keyword
    "import-term"	-> Keyword




module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar* "*/"	-> LongCom
				-> Eof  

    ~[\*]     -> CommChar

    "*"       -> Asterisk
    Asterisk  -> CommChar

  lexical restrictions
    Asterisk -/- [\/]
    Eof      -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\*]
    LAYOUT? -/- [\/].[\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
%%exports
%%  sorts VeryLongCom Eof VLCchar Backslash
%%  lexical syntax
%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
%%    "\\begin{code}" 			   -> VeryLongCom
%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
%%    ~[\\] 				   -> VLCchar
%%    Backslash 				   -> VLCchar
%%    [\\] 				   -> Backslash

%%  lexical restrictions
%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
%%    Eof -/- ~[]

%%  lexical syntax
%%    VeryLongCom -> LAYOUT





module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Core-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego
imports Stratego-Sugar
hiddens
  context-free start-symbols Module

module StrategoMix[Ctx0]
imports Stratego
          [ RuleNames          => RuleNames[[Ctx0]]
            RuleDec            => RuleDec[[Ctx0]]
            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
            DynRuleId          => DynRuleId[[Ctx0]]
            DynRuleDef         => DynRuleDef[[Ctx0]]
            ScopeLabels        => ScopeLabels[[Ctx0]]
            RuleCond           => RuleCond[[Ctx0]]
            Rule               => Rule[[Ctx0]]
            RuleDef            => RuleDef[[Ctx0]]
            Overlay            => Overlay[[Ctx0]]
            SwitchCase         => SwitchCase[[Ctx0]]
            StrategyCurly      => StrategyCurly[[Ctx0]]
            StrategyAngle      => StrategyAngle[[Ctx0]]
            Kind               => Kind[[Ctx0]]
            LID                => LID[[Ctx0]]
            ImportModName      => ImportModName[[Ctx0]]
            Decl               => Decl[[Ctx0]]
            Module             => Module[[Ctx0]]
            StrategyParen      => StrategyParen[[Ctx0]]
            Typedid            => Typedid[[Ctx0]]
            Anno               => Anno[[Ctx0]]
            EmptyId            => EmptyId[[Ctx0]]
            StrategyDef        => StrategyDef[[Ctx0]]
            SVar               => SVar[[Ctx0]]
            Def                => Def[[Ctx0]]
            Type               => Type[[Ctx0]]
            RetType            => RetType[[Ctx0]]
            ArgType            => ArgType[[Ctx0]]
            FunType            => FunType[[Ctx0]]
            ConstType          => ConstType[[Ctx0]]
            Opdecl             => Opdecl[[Ctx0]]
            Sort               => Sort[[Ctx0]]
            Sdecl              => Sdecl[[Ctx0]]
            Wld                => Wld[[Ctx0]]
            ID                 => ID[[Ctx0]]
            Var                => Var[[Ctx0]]
            CharChar           => CharChar[[Ctx0]]
            Char               => Char[[Ctx0]]
            Padding            => Padding[[Ctx0]]
            Dollar4            => Dollar4[[Ctx0]]
            QuotedBracket4     => QuotedBracket4[[Ctx0]]
            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
            Dollar3            => Dollar3[[Ctx0]]
            QuotedBracket3     => QuotedBracket3[[Ctx0]]
            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
            Dollar2            => Dollar2[[Ctx0]]
            QuotedBracket2     => QuotedBracket2[[Ctx0]]
            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
            Dollar1            => Dollar1[[Ctx0]]
            QuotedBracket1     => QuotedBracket1[[Ctx0]]
            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
            StringQuotation    => StringQuotation[[Ctx0]]
            StrChar            => StrChar[[Ctx0]]
            String             => String[[Ctx0]]
            Real               => Real[[Ctx0]]
            Int                => Int[[Ctx0]]
            Keyword            => Keyword[[Ctx0]]
            UCID               => UCID[[Ctx0]]
            LCID               => LCID[[Ctx0]]
            LId                => LId[[Ctx0]]
            Id                 => Id[[Ctx0]]
            ModNamePart        => ModNamePart[[Ctx0]]
            ModName            => ModName[[Ctx0]]
            PreTerm            => PreTerm[[Ctx0]]
            Term               => Term[[Ctx0]]
            StrategyMid        => StrategyMid[[Ctx0]]
            Strategy           => Strategy[[Ctx0]] ]


module Stratego-Booster2

imports
	StrategoMix[StrategoHost]
	EmbeddedBooster[Term[[StrategoHost]]]

imports
	Booster2 
	AbstractBoosterModel
	Common
	
exports
context-free start-symbols Module [[StrategoHost]]